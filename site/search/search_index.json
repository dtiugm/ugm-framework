{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"UGM Framework","text":"<p> Membangun Harmoni Sistem Informasi </p>"},{"location":"#transformasi-ugm-framework","title":"Transformasi UGM Framework","text":"<p>UGM Framework (UGMFW), yang sebelumnya dibangun dengan PHP CodeIgniter (CI), kini mengalami perubahan besar. UGMFW tidak lagi terbatas pada framework berbasis CodeIgniter, melainkan akan bertransformasi menjadi panduan teknis pengembangan sistem informasi yang seragam dan fleksibel. Transformasi ini bertujuan untuk mengatasi keterbatasan teknologi yang sudah usang dan memastikan bahwa pengembangan sistem informasi di UGM lebih efisien, terstruktur, dan dapat mengikuti perkembangan teknologi terbaru.</p>"},{"location":"#pembaruan-teknologi-dan-pendekatan","title":"Pembaruan Teknologi dan Pendekatan","text":"<p>UGMFW kini mengarah pada API first design dengan fokus pada pengembangan modular monolit. Dalam pendekatan ini, API akan menjadi inti dari pengembangan aplikasi, memastikan interoperabilitas yang lebih baik antar sistem dan memungkinkan sistem untuk lebih mudah beradaptasi dengan teknologi baru. Dengan pendekatan API-first, seluruh aplikasi dan sistem informasi di UGM akan dibangun di sekitar API yang jelas dan terstandarisasi, sehingga memudahkan pengembangan dan integrasi di berbagai platform.</p>"},{"location":"#visi-dan-misi-baru","title":"Visi dan Misi Baru","text":"<p>UGMFW kini bertujuan untuk menyelaraskan pengembangan sistem informasi dengan praktik terbaik dan teknologi terkini, untuk menciptakan sebuah platform yang lebih modular dan adaptif. Visi kami adalah untuk merancang dan mengembangkan kerangka kerja yang handal, modular, aman, dan mendukung interoperabilitas antara sistem informasi yang ada di UGM.</p>"},{"location":"#misi-ugmfw","title":"Misi UGMFW","text":"<ul> <li>Meningkatkan efisiensi pengembangan dengan menyediakan panduan teknis yang jelas dan standar pengembangan yang selaras.</li> <li>Menyediakan landasan teknologi yang relevan dan fleksibel, mendukung berbagai framework dan kebutuhan pengembangan.</li> <li>Mengedepankan kolaborasi yang lebih luas di lingkungan UGM, memfasilitasi pengembang dalam bekerja dengan alat dan standar yang seragam.</li> </ul>"},{"location":"#tujuan-ugmfw-yang-baru","title":"Tujuan UGMFW yang Baru","text":"<p>UGMFW kini berfokus pada pengembangan tatanan pengembangan yang seragam dan terstandarisasi untuk memastikan setiap pengembang di UGM memiliki pola dan perilaku pengembangan yang sama. Berikut adalah tujuan utama UGMFW yang baru:</p>"},{"location":"#penyelarasan-tatanan-pengembangan","title":"Penyelarasan Tatanan Pengembangan","text":"<p>UGMFW menyediakan standar design patterns yang konsisten untuk memastikan bahwa setiap aplikasi dikembangkan dengan struktur kode yang mudah dipahami, terorganisir dengan baik, dan bebas dari bug.</p>"},{"location":"#penyelarasan-perilaku-pengembangan","title":"Penyelarasan Perilaku Pengembangan","text":"<p>Semua pengembang di UGM diharapkan menggunakan toolset yang seragam dan mengikuti standar kode yang konsisten. Panduan pengembangan yang lebih lengkap akan mencakup dokumentasi kode, penamaan variabel, struktur kode, serta standar pengujian untuk memastikan kualitas aplikasi yang lebih baik.</p>"},{"location":"#standar-pengalaman-pengguna","title":"Standar Pengalaman Pengguna","text":"<p>UGMFW menetapkan standar material design yang konsisten untuk pengalaman pengguna yang lebih baik. Setiap aplikasi yang dikembangkan menggunakan UGMFW akan memiliki antarmuka yang familiar, memudahkan pengguna dalam berinteraksi dengan sistem.</p>"},{"location":"#pembaruan-teknologi-dan-devops-ideal","title":"Pembaruan Teknologi dan DevOps Ideal","text":"<p>UGMFW akan menyediakan panduan pengembangan yang ideal untuk memastikan implementasi Continuous Integration dan Continuous Delivery (CI/CD) yang efektif. Setiap perubahan kode akan diuji dan diterapkan secara otomatis, memungkinkan pengembang untuk fokus pada pengembangan tanpa mengkhawatirkan gangguan akibat integrasi manual.</p>"},{"location":"#pengembangan-api-dan-modular-monolit","title":"Pengembangan API dan Modular Monolit","text":"<p>Salah satu langkah besar dalam transformasi UGMFW adalah peralihan ke API first design. Sistem informasi di UGM akan berfokus pada pengembangan API yang menjadi fondasi bagi semua aplikasi yang dibangun di atasnya. Pendekatan ini memungkinkan aplikasi untuk lebih fleksibel, lebih mudah diintegrasikan, dan lebih modular. API yang dikembangkan akan mengikuti standar yang telah ditentukan, memastikan bahwa sistem informasi di UGM dapat berinteroperasi dengan baik.</p> <p>Dengan ini, UGMFW mengarah pada pengembangan modular monolit, dimana aplikasi tetap memiliki satu kesatuan arsitektur namun dengan modularitas yang tinggi berkat penggunaan API yang jelas dan terstandarisasi.</p>"},{"location":"#transformasi-menuju-harmoni-sistem-informasi","title":"Transformasi Menuju Harmoni Sistem Informasi","text":"<p>Transformasi UGMFW adalah langkah penting untuk meningkatkan kualitas pengembangan sistem informasi di Universitas Gadjah Mada. Dengan mengedepankan modularitas, fleksibilitas, dan keamanan, UGMFW akan menjadi fondasi yang kokoh bagi pengembangan sistem informasi di masa depan. Pembaruan teknologi, dokumentasi yang lebih jelas, dan standar pengembangan yang konsisten akan memperkuat kualitas aplikasi di lingkungan UGM.</p> <p>Kami percaya bahwa dengan panduan ini, UGMFW akan mendukung integrasi dan kolaborasi yang lebih baik di seluruh unit dan fakultas, mempercepat transformasi digital yang lebih efisien dan aman.</p>"},{"location":"#terima-kasih","title":"Terima Kasih","text":"<p>Kami mengucapkan terima kasih kepada semua pihak yang telah berkontribusi dalam penyusunan panduan ini, khususnya kepada:</p> <ul> <li>Rektor Universitas Gadjah Mada</li> <li>Wakil Rektor Universitas Gadjah Mada</li> <li>Direktur Teknologi Informasi</li> <li>Sekretaris Direktorat Teknologi Informasi</li> <li>Kepala Sub Bidang Direktorat Teknologi Informasi</li> <li>Koordinator Fungsional Direktorat Teknologi Informasi</li> <li>Tim Task Force UGM Framework, Simaster vNext, UGM Lean, dan Modernisasi Data</li> <li>Semua pihak yang terlibat, baik secara langsung maupun tidak langsung</li> </ul> <p>Semoga panduan ini dapat memberikan kontribusi signifikan dalam peningkatan kualitas sistem informasi di Universitas Gadjah Mada.</p>"},{"location":"#pelajari-lebih-lanjut","title":"Pelajari Lebih Lanjut","text":"<p>Temukan dokumentasi lengkap UGMFW untuk mulai membangun aplikasi Anda.</p>"},{"location":"contact/","title":"KONTAK","text":""},{"location":"contact/#direktorat-teknologi-informasi","title":"Direktorat Teknologi Informasi","text":"<p>Rumah Dinas E1, Jl. Bungur Selatan, Bulaksumur, Yogyakarta 55281 - Email: dti@ugm.ac.id - Phone: +62 (274) 515660 - Fax: +62 (274) 515664</p>"},{"location":"api/cache-api/","title":"7.11 Caching","text":"<p>Caching adalah mekanisme penyimpanan sementara data untuk mengurangi beban sistem, mempercepat waktu respons, dan meningkatkan performa aplikasi. Dalam konteks API, caching dapat dilakukan pada berbagai tingkat, termasuk respons API dan query database.</p>"},{"location":"api/cache-api/#7111-response-caching","title":"7.11.1 Response Caching","text":"<p>Response caching menyimpan hasil respons API sehingga permintaan berikutnya untuk data yang sama tidak perlu diproses ulang. Ini sangat berguna untuk data yang jarang berubah.</p>"},{"location":"api/cache-api/#cara-implementasi-di-fastapi","title":"Cara Implementasi di FastAPI","text":"<ul> <li>Gunakan Header <code>Cache-Control</code></li> </ul> <p>Tambahkan header <code>Cache-Control</code> untuk mengatur durasi penyimpanan cache di klien atau CDN.</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.get(\"/cached-response\")\ndef get_cached_response():\n    data = {\"message\": \"Data ini akan di-cache\"}\n    response = JSONResponse(content=data)\n    response.headers[\"Cache-Control\"] = \"public, max-age=3600\"  # Cache selama 1 jam\n    return response\n</code></pre> <ul> <li>Gunakan Middleware untuk Response Caching</li> </ul> <p>API dapat menggunakan middleware seperti Starlette's BaseHTTPMiddleware untuk mengimplementasikan caching lebih lanjut.</p>"},{"location":"api/cache-api/#7112-database-query-caching","title":"7.11.2 Database Query Caching","text":"<p>Database query caching menyimpan hasil query database sehingga query yang sama di masa depan dapat dijawab lebih cepat tanpa mengeksekusi ulang query.</p>"},{"location":"api/cache-api/#menggunakan-redis-untuk-query-caching-di-fastapi","title":"Menggunakan Redis untuk Query Caching di FastAPI","text":"<p>Redis adalah database in-memory yang cepat dan populer untuk caching.</p>"},{"location":"api/cache-api/#langkah-implementasi-di-fastapi","title":"Langkah Implementasi di FastAPI","text":"<ul> <li> <p>Instalasi Redis dan Library Redis untuk Python: Install Redis dan library <code>redis-py</code> <pre><code>pip install redis\n</code></pre></p> </li> <li> <p>Konfigurasi Redis Connection: Buat koneksi ke Redis <pre><code>import redis\n\nredis_client = redis.Redis(host=\"localhost\", port=6379, db=0)\n</code></pre></p> </li> <li> <p>Caching Query Database: Gunakan Redis untuk menyimpan hasil query <pre><code>from fastapi import FastAPI, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom redis import Redis\nfrom app.models import User  # Ganti dengan model Anda\n\napp = FastAPI()\n\n# Redis connection\nredis_client = Redis(host=\"localhost\", port=6379, db=0)\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, db: AsyncSession):\n    cache_key = f\"user:{user_id}\"\n\n    # Cek data di cache Redis\n    cached_data = redis_client.get(cache_key)\n    if cached_data:\n        return {\"source\": \"cache\", \"data\": cached_data.decode(\"utf-8\")}\n\n    # Jika tidak ada di cache, query database\n    query = select(User).where(User.id == user_id)\n    result = await db.execute(query)\n    user = result.scalar()\n\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    # Simpan data ke Redis dengan waktu kadaluarsa 1 jam\n    redis_client.setex(cache_key, 3600, str(user.dict()))\n\n    return {\"source\": \"database\", \"data\": user.dict()}\n</code></pre></p> </li> <li> <p>Menghapus Cache Saat Data Diupdate: Ketika data berubah, pastikan cache dihapus atau diperbarui untuk menjaga konsistensi <pre><code>@app.put(\"/users/{user_id}\")\nasync def update_user(user_id: int, user_data: dict, db: AsyncSession):\n    query = select(User).where(User.id == user_id)\n    result = await db.execute(query)\n    user = result.scalar()\n\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    # Update data di database\n    for key, value in user_data.items():\n        setattr(user, key, value)\n    db.add(user)\n    await db.commit()\n\n    # Hapus cache yang terkait\n    cache_key = f\"user:{user_id}\"\n    redis_client.delete(cache_key)\n\n    return {\"message\": \"User updated\", \"data\": user_data}\n</code></pre></p> </li> </ul>"},{"location":"api/cache-api/#best-practices-untuk-caching","title":"Best Practices untuk Caching","text":"<ol> <li>Tetapkan Expiration Time: Semua cache harus memiliki waktu kedaluwarsa (<code>TTL</code>) untuk menghindari penyimpanan data lama yang tidak relevan.</li> <li>Cache Hanya Data yang Sering Diakses: Tidak semua data perlu dicache. Prioritaskan data yang mahal untuk dihasilkan atau sering diminta.</li> <li>Gunakan Cache Invalidation: Pastikan cache diperbarui atau dihapus saat data dasar berubah.</li> <li>Monitoring dan Debugging: Gunakan alat seperti Redis Insight untuk memantau performa dan penggunaan Redis.</li> </ol>"},{"location":"api/cache-api/#keuntungan-caching","title":"Keuntungan Caching","text":"<p>Beberapa keuntungan dari caching adalah sebagai berikut:</p> <ol> <li>Mengurangi beban database.</li> <li>Meningkatkan kecepatan respons API.</li> <li>Menyediakan fallback data jika sistem backend tidak tersedia sementara.</li> </ol> <p>Caching adalah alat yang kuat untuk meningkatkan performa sistem, tetapi harus digunakan dengan hati-hati untuk memastikan konsistensi data.</p>"},{"location":"api/format-response-api/","title":"7.5 Format Response","text":""},{"location":"api/format-response-api/#751-response-json","title":"7.5.1 Response JSON","text":"<p>Semua response dari API harus berformat JSON. Struktur response harus konsisten dan jelas. Misalnya:</p> <pre><code>{ \"status\": \"success\", \"data\": {...}, \"message\": \"Operation completed successfully\" }\n{\"data1\": {...}, \"data2\": \"value2\", \"data3\": \"value3\"}\n</code></pre>"},{"location":"api/format-response-api/#752-kode-status-http","title":"7.5.2 Kode Status HTTP","text":"<p>Dalam hal ini mewajibkan penggunaan kode status HTTP yang tepat dan harus sesuai ketentuan. Kode status HTTP sangat penting untuk memberi tahu klien tentang status permintaan mereka. Beberapa kode status umum yang harus digunakan adalah:</p> <ol> <li><code>200 OK</code> untuk permintaan yang berhasil.</li> <li><code>201 Created</code> ketika data baru berhasil dibuat.</li> <li><code>400 Bad Request</code> apabila permintaan tidak valid.</li> <li><code>404 Not Found</code> apabila resource tidak ditemukan.</li> <li><code>401 Unauthorized</code> apabila permintaan membutuhakn autentikasi namun klient tidak mengirimkan kredensial yang sah.</li> <li><code>409 Confict</code> apabila permintaan tidak bisa diproses karena adanya konflik dengan status sumber daya.</li> <li><code>422 Unprocessable Entity</code> apabila data yang dikirim klient gagal divalidasi oleh server.</li> <li><code>500 Internal Server Error</code> untuk kesalahan di server.</li> </ol>"},{"location":"api/framework-api/","title":"7.2 Framework API","text":"<p>Framework adalah komponen penting dalam pengembangan aplikasi untuk memastikan efisiensi, konsistensi, dan skalabilitas. Pemilihan framework harus mempertimbangkan aspek teknis, performa, dan kemudahan pemeliharaan.</p> <p>Kami memberikan rekomendasi framework yang sesuai dengan kebutuhan modern, tetapi tidak membatasi penggunaan framework tertentu selama memenuhi kriteria yang telah ditetapkan.</p>"},{"location":"api/framework-api/#721-ketentuan","title":"7.2.1 Ketentuan","text":""},{"location":"api/framework-api/#7211-bahasa-pemrograman-versi-terbaru","title":"7.2.1.1 Bahasa Pemrograman Versi Terbaru","text":"<p>Aplikasi wajib menggunakan versi terbaru atau yang masih didukung aktif dari bahasa pemrograman untuk memastikan keamanan dan performa optimal.</p> <p>Contoh versi yang direkomendasikan:</p> <ol> <li>PHP: Minimal versi 8 atau lebih baru.</li> <li>Node.js: Minimal versi 20 atau lebih baru.</li> <li>TypeScript: Minimal versi 5 atau lebih baru.</li> <li>Python: Minimal versi 3.10 atau lebih baru.</li> <li>Go: Minimal versi 1.23 atau lebih baru.</li> </ol>"},{"location":"api/framework-api/#7212-dukungan-untuk-autentikasi","title":"7.2.1.2 Dukungan untuk Autentikasi","text":"<p>Framework yang digunakan wajib mendukung implementasi JWT Token dan OAuth 2.0 untuk autentikasi dan otorisasi, yang berfungsi untuk menjaga keamanan akses API.</p>"},{"location":"api/framework-api/#7213-dokumentasi-otomatis","title":"7.2.1.3 Dokumentasi Otomatis","text":"<p>Framework harus mendukung dokumentasi otomatis berbasis OpenAPI (Swagger atau ReDoc), sehingga mempermudah pengembang dan pengguna API dalam memahami endpoint, parameter, dan respons.</p>"},{"location":"api/framework-api/#7214-modularitas-dan-ekstensibilitas","title":"7.2.1.4 Modularitas dan Ekstensibilitas","text":"<p>Framework harus mendukung arsitektur modular agar setiap komponen aplikasi dapat dikembangkan, diuji, atau dimodifikasi secara independen. Ekstensibilitas memastikan framework dapat disesuaikan dengan kebutuhan spesifik proyek.</p>"},{"location":"api/framework-api/#7215-dukungan-komunitas-dan-pembaruan","title":"7.2.1.5 Dukungan Komunitas dan Pembaruan","text":"<p>Framework yang digunakan harus memiliki komunitas yang aktif dan mendapat pembaruan berkelanjutan, sehingga aplikasi tetap aman dan kompatibel dengan teknologi terbaru.</p>"},{"location":"api/framework-api/#7216-performansi-tinggi","title":"7.2.1.6 Performansi Tinggi","text":"<p>Framework harus memiliki performansi yang andal untuk menangani aplikasi dengan skala besar, terutama untuk skenario API dengan permintaan tinggi.</p>"},{"location":"api/framework-api/#722-rekomendasi","title":"7.2.2 Rekomendasi","text":"<p>Kami merekomendasikan FastAPI sebagai framework utama untuk pengembangan aplikasi berbasis Python karena memperharikan hal-hal sebagai berikut:</p>"},{"location":"api/framework-api/#7221-dokumentasi-otomatis","title":"7.2.2.1 Dokumentasi Otomatis","text":"<p>FastAPI secara otomatis menghasilkan dokumentasi interaktif berbasis OpenAPI (Swagger/ReDoc) dari definisi endpoint, mempermudah kolaborasi antar tim pengembang dan pengguna API.</p>"},{"location":"api/framework-api/#7222-mudah-dipelajari","title":"7.2.2.2 Mudah Dipelajari","text":"<p>Sintaks FastAPI yang sederhana dan berbasis tipe (type hints) membuatnya mudah dipelajari, bahkan untuk pengembang yang baru mengenal Python.</p>"},{"location":"api/framework-api/#7223-performa-tinggi","title":"7.2.2.3 Performa Tinggi","text":"<p>Dibangun diatas ASGI (Asynchronous Server Gateway Interface) dan mendukung penggunaan async/await, FastAPI menawarkan performa tinggi setara dengan framework modern seperti Node.js atau Go.</p>"},{"location":"api/framework-api/#7224-dukungan-komunitas","title":"7.2.2.4 Dukungan Komunitas","text":"<p>FastAPI memiliki komunitas aktif dengan ekosistem pendukung yang kaya, termasuk pustaka populer Python seperti SQLAlchemy, Pydantic, dan lainnya.</p>"},{"location":"api/framework-api/#7225-skalabilitas","title":"7.2.2.5 Skalabilitas","text":"<p>FastAPI dirancang untuk aplikasi modern yang membutuhkan skalabilitas tinggi dan arsitektur API yang robust.</p>"},{"location":"api/metode-http-api/","title":"7.4 Metode HTTP","text":""},{"location":"api/metode-http-api/#741-get","title":"7.4.1 GET","text":"<p>Metode GET digunakan untuk mengambil data dari server. Pada API, GET biasanya digunakan untuk mengambil daftar resource atau detail resource tertentu. Contoh penggunaan:</p> <ol> <li><code>GET /api/v1/products</code> untuk mengambil daftar produk.</li> <li><code>GET /api/v1/products/{id}</code> untuk mengambil informasi produk berdasarkan ID.</li> </ol>"},{"location":"api/metode-http-api/#742-post","title":"7.4.2 POST","text":"<p>Metode POST digunakan untuk membuat data baru di server. POST biasanya digunakan ketika pengguna mengirimkan data untuk disimpan pada database. </p> <p>Contohnya:<code>POST /api/v1/products</code> untuk membuat produk baru.</p>"},{"location":"api/metode-http-api/#743-putpatch","title":"7.4.3 PUT/PATCH","text":"<p>PUT digunakan untuk memperbarui resource secara keseluruhan, sementara PATCH digunakan untuk pembaruan parsial. Keduanya berguna untuk mengubah data yang sudah ada di server. Contoh penggunaannya sebagai berikut:</p> <ol> <li><code>PUT /api/v1/products/{id}</code> untuk memperbarui data produk sepenuhnya.</li> <li><code>PATCH /api/v1/products/{id}</code> untuk memperbarui sebagian informasi produk.</li> </ol>"},{"location":"api/metode-http-api/#744-delete","title":"7.4.4 DELETE","text":"<p>DELETE digunakan untuk menghapus resource dari server. </p> <p>Misalnya: <code>DELETE /api/v1/products/{id}</code> untuk menghapus produk berdasarkan ID.</p>"},{"location":"api/orm-database/","title":"7.10 Versioning Database","text":"<p>Mengelola versi skema database (schema versioning) adalah praktik penting untuk menjaga keselarasan antara database dan API, terutama dalam lingkungan yang terus berkembang. Selain itu, kompatibilitas mundur (backward compatibility) adalah keharusan untuk memastikan bahwa API versi lama tetap berfungsi meskipun ada perubahan pada skema database.</p>"},{"location":"api/orm-database/#7101-schema-versioning","title":"7.10.1 Schema Versioning","text":"<p>Schema versioning memastikan bahwa perubahan pada database (misalnya: menambah kolom, membuat tabel baru, atau menghapus kolom) dapat dikelola secara sistematis. Hal ini penting untuk:</p> <ol> <li>Mempermudah rollback jika terjadi kesalahan.</li> <li>Mendokumentasikan perubahan skema untuk koordinasi antar tim.</li> <li>Menjamin bahwa perubahan tidak merusak API atau sistem lain yang bergantung pada skema database.</li> </ol> <p>Tools yang direkomendasikan:</p> <ol> <li>Alembic (untuk SQLAlchemy): Mendukung migrasi skema database berbasis Python, dan sangat cocok digunakan dengan FastAPI.</li> <li>Flyway atau Liquibase: Alat alternatif untuk database versioning yang mendukung berbagai platform dan bahasa.</li> </ol>"},{"location":"api/orm-database/#implementasi-dengan-alembic","title":"Implementasi dengan Alembic","text":""},{"location":"api/orm-database/#konfigurasi-alembic","title":"Konfigurasi Alembic","text":"<p>Adapun untuk langkah-langkah konfigurasinya adalah sebagai berikut:</p> <ol> <li>Pastikan proyek API menggunakan SQLAlchemy, kemudian instal Alembic: <code>pip install alembic</code></li> <li>Inisialisasi Alembic di proyek API: <code>alembic init migrations</code></li> <li>Periksa file <code>alembic.ini</code> untuk mengatur koneksi API ke database.</li> </ol>"},{"location":"api/orm-database/#membuat-dan-menerapkan-migrasi","title":"Membuat dan Menerapkan Migrasi","text":"<p>Dengan tahapan sebagai berikut:</p> <ul> <li>Contoh tambah kolom baru: tambahkan kolom <code>birth_date</code> ke tabel <code>users</code>. </li> <li>Buat model SQLAlchemy yang diperbarui:</li> </ul> <pre><code>from sqlalchemy import Column, Integer, String, Date\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(50))\n    email = Column(String(50))\n    birth_date = Column(Date)  # Kolom baru\n</code></pre> <ul> <li>Buat file migrasi menggunakan Alembic: <code>alembic revision --autogenerate -m \"Add birth_date to users table\"</code></li> <li>Terapkan migrasi: <code>alembic upgrade head</code></li> </ul>"},{"location":"api/orm-database/#rollback-jika-terjadi-masalah","title":"Rollback jika terjadi masalah","text":"<p>Apabila terjadi kesalahan, maka dapat kembali ke versi sebelumnya: <code>alembic downgrade -1</code></p>"},{"location":"api/orm-database/#penyesuaian-otomatis","title":"Penyesuaian otomatis","text":"<p>Penggunaan fitur autogenerate Alembic untuk mendeteksi perubahan pada model SQLAlchemy dan dapat menghasilkan migrasi secara otomatis.</p>"},{"location":"api/orm-database/#7102-backward-compability","title":"7.10.2 Backward Compability","text":"<p>Kompatibilitas mundur adalah kemampuan sistem untuk mendukung versi API lama meskipun ada perubahan pada database. Praktik ini penting untuk memastikan klien yang menggunakan versi API lama tetap dapat berfungsi dengan baik.</p> <p>Prinsip Utama:</p> <ol> <li> <p>Non-destruktif Changes</p> <p>Tambahkan kolom baru daripada mengganti atau menghapus kolom lama. Apabila kolom perlu dihapus, pastikan API lama tetap dapat bekerja dengan fallback atau nilai default.</p> </li> <li> <p>Data Migration:</p> <p>Saat membuat perubahan besar pada skema, migrasikan data yang diperlukan agar API lama tetap dapat mengakses data yang sesuai.</p> </li> <li> <p>Versi API dan Database:</p> <p>Gunakan penanda versi pada tabel atau skema database jika memungkinkan. Misalnya, tabel <code>users_v1</code> untuk API lama, dan <code>users_v2</code> untuk API baru.</p> </li> </ol> <p>Contoh Backward Compatibility di FastAPI:</p> <p>Misalkan API diperbaruhi untuk mendukung kolom baru <code>birth_date</code>, tetapi versi API lama hanya menggunakan <code>name</code> dan <code>email</code>.</p> <p>Model Baru:</p> <pre><code>from sqlalchemy import Column, Integer, String, Date\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(50))\n    email = Column(String(50))\n    birth_date = Column(Date)  # Kolom baru\n</code></pre> <p>Endpoint FastAPI untuk API Lama (API v1) dan Baru (API v2):</p> <pre><code>from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\n\napp = FastAPI()\n\n@app.get(\"/v1/users\")\nasync def get_users_v1(db: AsyncSession = Depends(get_db)):\n    result = await db.execute(select(User.id, User.name, User.email))\n    users = result.fetchall()\n    return {\"users\": [dict(user) for user in users]}\n\n@app.get(\"/v2/users\")\nasync def get_users_v2(db: AsyncSession = Depends(get_db)):\n    result = await db.execute(select(User))\n    users = result.scalars().all()\n    return {\"users\": [user.to_dict() for user in users]}\n</code></pre> <p>Penjelasan:</p> <ol> <li>API v1 hanya mengembalikan <code>name</code> dan <code>email</code>.</li> <li>API v2 mendukung kolom baru <code>birth_date</code>.</li> </ol>"},{"location":"api/pagination-filtering-sorting/","title":"7.7 Pagination, Filtering, dan Sorting","text":"<p>Saat API mengembalikan banyak data (misalnya daftar pengguna, produk, atau artikel), penting untuk mendukung fitur Pagination, Filtering, dan Sorting. Hal ini meningkatkan performa aplikasi, mengurangi konsumsi bandwidth, dan memberi pengguna fleksibilitas untuk mendapatkan data yang relevan.</p>"},{"location":"api/pagination-filtering-sorting/#771-pagination","title":"7.7.1 Pagination","text":"<p>Pagination adalah proses membagi data dalam beberapa halaman untuk menghindari pengembalian data dalam jumlah besar sekaligus.</p>"},{"location":"api/pagination-filtering-sorting/#langkah-implementasi-pagination","title":"Langkah Implementasi Pagination","text":"<ol> <li> <p>Gunakan Query Parameters</p> <p>Penggunaan <code>limit</code> untuk menentukan jumlah item per halaman, sedangkan <code>offset</code> atau <code>page</code> untuk menentukan posisi awal data atau halaman tertentu.</p> </li> <li> <p>Contoh Implementasi:</p> </li> </ol> <pre><code>from fastapi import FastAPI, Query\nfrom typing import List\n\napp = FastAPI()\n\n# Contoh data\ndata = [{\"id\": i, \"name\": f\"Item {i}\"} for i in range(1, 101)]  # 100 item\n\n@app.get(\"/items/\")\nasync def get_items(limit: int = Query(10, ge=1, le=50), offset: int = Query(0, ge=0)):\n    \"\"\"\n    limit: Jumlah item per halaman (default 10, maksimum 50).\n    offset: Posisi awal data (default 0).\n    \"\"\"\n    paginated_data = data[offset: offset + limit]\n    return {\n        \"total\": len(data),\n        \"limit\": limit,\n        \"offset\": offset,\n        \"data\": paginated_data,\n    }\n</code></pre> <p>Penjelasan:</p> <ol> <li><code>Query(10, ge=1, le=50)</code> memastikan nilai <code>limit</code> minimal 1 dan maksimal 50.</li> <li><code>offset</code> digunakan untuk menghitung posisi awal data yang ingin dikembalikan.</li> <li>Respons menyertakan metadata (<code>total</code>, <code>limit</code>, <code>offset</code>) untuk membantu pengguna memahami jumlah data yang tersedia.</li> </ol> <p>Contoh Permintaan: </p> <p><code>/items/?limit=5&amp;offset=10</code> mengambil 5 item, mulai dari item ke-11.</p>"},{"location":"api/pagination-filtering-sorting/#772-filtering-dan-sorting","title":"7.7.2 Filtering dan Sorting","text":"<p>Filtering memungkinkan pengguna memilih subset data berdasarkan kriteria tertentu, sementara Sorting memungkinkan pengguna mengurutkan data berdasarkan satu atau lebih kolom.</p>"},{"location":"api/pagination-filtering-sorting/#langkah-implementasi-filtering","title":"Langkah Implementasi Filtering","text":"<ol> <li>Gunakan query parameters untuk menerima kriteria filter.</li> <li>Terapkan filter di dalam kode sebelum mengembalikan data.</li> </ol>"},{"location":"api/pagination-filtering-sorting/#contoh-implementasi-filtering","title":"Contoh Implementasi Filtering:","text":"<pre><code>@app.get(\"/items/filter\")\nasync def filter_items(name: str = Query(None), min_id: int = Query(None), max_id: int = Query(None)):\n    \"\"\"\n    Filter berdasarkan:\n    - `name` yang mengandung string tertentu.\n    - `min_id` untuk ID minimum.\n    - `max_id` untuk ID maksimum.\n    \"\"\"\n    filtered_data = data\n\n    if name:\n        filtered_data = [item for item in filtered_data if name.lower() in item[\"name\"].lower()]\n    if min_id is not None:\n        filtered_data = [item for item in filtered_data if item[\"id\"] &gt;= min_id]\n    if max_id is not None:\n        filtered_data = [item for item in filtered_data if item[\"id\"] &lt;= max_id]\n\n    return {\"total\": len(filtered_data), \"data\": filtered_data}\n</code></pre> <p>Contoh Permintaan: </p> <p><code>/items/filter?name=item&amp;min_id=10&amp;max_id=20</code> menampilkan item yang mengandung \"item\" di nama, dengan ID antara 10 dan 20.</p>"},{"location":"api/pagination-filtering-sorting/#pagination-filtering-dan-sorting-secara-bersamaan","title":"Pagination, Filtering, dan Sorting Secara Bersamaan","text":"<p>Untuk mendukung ketiga fitur dalam satu endpoint, gabungkan logika di atas.</p> <p>Contoh Implementasi Kombinasi:</p> <pre><code>@app.get(\"/items/advanced\")\nasync def advanced_query(\n    limit: int = Query(10, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    name: str = Query(None),\n    min_id: int = Query(None),\n    max_id: int = Query(None),\n    sort_by: str = Query(\"id\"),\n    order: str = Query(\"asc\"),\n):\n    filtered_data = data\n\n    # Filtering\n    if name:\n        filtered_data = [item for item in filtered_data if name.lower() in item[\"name\"].lower()]\n    if min_id is not None:\n        filtered_data = [item for item in filtered_data if item[\"id\"] &gt;= min_id]\n    if max_id is not None:\n        filtered_data = [item for item in filtered_data if item[\"id\"] &lt;= max_id]\n\n    # Sorting\n    if sort_by not in [\"id\", \"name\"]:\n        return {\"error\": f\"Cannot sort by {sort_by}. Valid options: 'id', 'name'.\"}\n    filtered_data = sorted(filtered_data, key=lambda x: x[sort_by], reverse=(order == \"desc\"))\n\n    # Pagination\n    paginated_data = filtered_data[offset: offset + limit]\n\n    return {\n        \"total\": len(filtered_data),\n        \"limit\": limit,\n        \"offset\": offset,\n        \"data\": paginated_data,\n    }\n</code></pre> <p>Contoh Permintaan: </p> <p><code>/items/advanced?limit=5&amp;offset=10&amp;name=item&amp;min_id=10&amp;sort_by=name&amp;order=asc</code></p> <p>Dari contoh permintaan diatas, maka:</p> <ol> <li>Filter: Nama mengandung \"item\" dan ID minimal 10.</li> <li>Sort: Berdasarkan nama secara ascending.</li> <li>Pagination: 5 item dimulai dari offset 10.</li> </ol>"},{"location":"api/pilar-pilar-api/","title":"BAB 7 PEDOMAN API","text":"<p>API (Application Programming Interface) adalah elemen kunci dalam pengembangan sistem informasi modern. API memungkinkan aplikasi berkomunikasi dan bertukar data secara terstandar, sehingga menjadi komponen penting untuk menciptakan sistem yang terintegrasi, aman, dan handal. Pada Universitas Gadjah Mada (UGM), API berperan sebagai sarana untuk mewujudkan tata kelola sistem informasi modern melalui penerapan arsitektur berbasis layer yang mendukung skalabilitas.</p> <p>UGM Framework menetapkan API sebagai penghubung antar layanan, beralih dari paradigma full-stack ke layered architecture. Pendekatan ini mendukung pemisahan tanggung jawab (decoupling) dan memudahkan perubahan sistem. Dengan disusunnya panduan ini, pengembang diharapkan dapat merancang API yang memenuhi standar kualitas perangkat lunak dan mendukung kebutuhan strategis UGM.</p>"},{"location":"api/pilar-pilar-api/#71-pilar-pilar-perancangan-api","title":"7.1 Pilar-Pilar Perancangan API","text":""},{"location":"api/pilar-pilar-api/#711-implementasi-rest-dan-json","title":"7.1.1 Implementasi REST dan JSON","text":"<p>REST (Representational State Transfer) adalah arsitektur API berbasis protokol HTTP. JSON (JavaScript Object Notation) adalah format data ringan yang digunakan secara luas pada API REST untuk pertukaran data. Kedua teknologi ini bersama-sama menyediakan solusi komunikasi yang sederhana, efisien, dan kompatibel lintas platform.</p> <p>Berikut masing-masing keuntungan dari kedua arsitektur diatas.</p>"},{"location":"api/pilar-pilar-api/#keuntungan-rest","title":"Keuntungan REST:","text":"<ol> <li>Sederhana: Menggunakan metode HTTP standar seperti GET, POST, PUT, DELETE.</li> <li>Stateless: Setiap permintaan berisi semua informasi yang dibutuhkan.</li> <li>Skalabel: Mendukung penskalaan horizontal dengan menambah atau mengurangi server.</li> </ol>"},{"location":"api/pilar-pilar-api/#keuntungan-json","title":"Keuntungan JSON:","text":"<ol> <li>Ringan: Format data lebih ringkas dibandingkan XML.</li> <li>Mudah Dibaca: Struktur data yang sederhana dan intuitif.</li> <li>Kompatibel: Didukung oleh berbagai bahasa pemrograman.</li> </ol>"},{"location":"api/pilar-pilar-api/#712-kewajiban-api-gateway-dan-manajemen-api","title":"7.1.2 Kewajiban API Gateway dan Manajemen API","text":"<p>API Gateway berfungsi sebagai pintu gerbang terpusat untuk semua permintaan API, yang bertanggung jawab mengelola lalu lintas, autentikasi, dan keamanan. Manajemen API mengatur seluruh siklus hidup API mulai dari tahap pembuatan hingga pemantauan.</p>"},{"location":"api/pilar-pilar-api/#fungsi-api-gateway","title":"Fungsi API Gateway:","text":"<ol> <li>Routing: Mengarahkan permintaan ke layanan yang tepat.</li> <li>Keamanan: Mengelola autentikasi dan otorisasi.</li> <li>Pengendalian Lalu Lintas: Menerapkan batasan permintaan untuk mencegah penyalahgunaan.</li> </ol>"},{"location":"api/pilar-pilar-api/#proses-manajemen-api","title":"Proses Manajemen API:","text":"<ol> <li>Pembuatan: Mendefinisikan endpoint dan metode API.</li> <li>Penerbitan: Menyediakan API untuk penggunaan pengembang lain.</li> <li>Pemantauan: Mengawasi kinerja API secara berkelanjutan.</li> <li>Pemeliharaan: Menerapkan pembaruan dan perbaikan yang diperlukan.</li> </ol>"},{"location":"api/pilar-pilar-api/#713-pemenuhan-kualitas-perangkat-lunak","title":"7.1.3 Pemenuhan Kualitas Perangkat Lunak","text":"<p>Dalam perancangan sistem informasi yang baik empat pilar utama yang diperhatikan adalah:</p>"},{"location":"api/pilar-pilar-api/#keamanan","title":"Keamanan","text":"<p>Keamanan merupakan aspek kritis dalam perancangan API. Beberapa praktik terbaik mencakup:</p> <ol> <li>Penggunaan protokol HTTPS untuk enkripsi data dalam transfer.</li> <li>Penerapan sistem autentikasi dan otorisasi yang kuat.</li> <li>Penggunaan token untuk mengamankan sesi pengguna seperti token JWT (JSON Web Token).</li> <li>Penggunaan Protokol OAuth 2.0 untuk memastikan endpoint yang memerlukan autentikasi hanya bisa diakses oleh pengguna yang telah terotentikasi.</li> </ol>"},{"location":"api/pilar-pilar-api/#skalabilitas","title":"Skalabilitas","text":"<p>API harus mampu menangani peningkatan jumlah pengguna dan permintaan. Beberapa pendekatan yang efektif adalah:</p> <ol> <li>Penerapan load balancing untuk distribusi lalu lintas yang efisien.</li> <li>Penskalaan horizontal melalui penambahan atau pengurangan server sesuai kebutuhan.</li> <li>Pemanfaatan sistem cache untuk mengurangi beban server.</li> </ol>"},{"location":"api/pilar-pilar-api/#ketersediaan","title":"Ketersediaan","text":"<p>Ketersediaan API menjadi kunci untuk menjamin layanan yang berkelanjutan. Beberapa strategi penting sebagai berikut:</p> <ol> <li>Replikasi data untuk menjamin ketersediaan saat terjadi kegagalan server.</li> <li>Implementasi sistem failover untuk pengalihan lalu lintas ke server cadangan.</li> <li>Penerapan sistem pemantauan untuk deteksi dan penanganan masalah secara dini.</li> </ol>"},{"location":"api/pilar-pilar-api/#kinerja","title":"Kinerja","text":"<p>Kinerja API harus dioptimalkan untuk response yang cepat dan efisien. Adapun beberapa langkah optimasinya adalah:</p> <ol> <li>Penerapan minifikasi dan kompresi data untuk transfer yang lebih cepat.</li> <li>Optimasi kueri database untuk mempercepat pemrosesan.</li> <li>Implementasi teknik caching untuk pengurangan beban server.</li> </ol>"},{"location":"api/pilar-pilar-api/#714-penyelarasan-dengan-microservices-soa-dan-layered-architecture","title":"7.1.4 Penyelarasan dengan Microservices, SOA, dan Layered Architecture","text":"<p>Untuk memastikan keselarasan API dengan pengembangan berbasis microservices, Service-Oriented Architecture (SOA), dan layered architecture agar dapat memperhatikan prinsip-prinsip berikut:</p>"},{"location":"api/pilar-pilar-api/#microservices","title":"Microservices","text":"<p>Microservices adalah pendekatan pengembangan perangkat lunak yang membangun aplikasi sebagai kumpulan layanan kecil yang dapat di-deploy secara independen. Untuk mendukung arsitektur ini, API harus:</p> <ol> <li>Modular: Setiap layanan memiliki API yang terpisah dan terdefinisi dengan jelas.</li> <li>Ringan: API harus efisien dalam waktu respons dan penggunaan sumber daya.</li> <li>Independen: Layanan dapat dikembangkan, diuji, dan di-deploy secara mandiri.</li> </ol>"},{"location":"api/pilar-pilar-api/#service-oriented-architecture-soa","title":"Service-Oriented Architecture (SOA)","text":"<p>SOA adalah kerangka kerja desain yang memungkinkan layanan dalam jaringan berkomunikasi dan berkolaborasi. Untuk mendukung SOA, API harus:</p> <ol> <li>Interoperable: API harus menggunakan standar umum seperti SOAP atau REST untuk menjamin kompatibilitas.</li> <li>Reusable: Layanan dapat digunakan kembali pada berbagai konteks dan aplikasi.</li> <li>Loose Coupling: Layanan harus dirancang dengan ketergantungan minimal satu sama lain.</li> </ol>"},{"location":"api/pilar-pilar-api/#layered-architecture","title":"Layered Architecture","text":"<p>Layered architecture membagi aplikasi menjadi beberapa lapisan dengan tanggung jawab yang jelas. Untuk mendukung layered architecture, API harus:</p> <ol> <li>Terstruktur: Setiap lapisan memiliki API yang jelas dan terdefinisi dengan baik.</li> <li>Abstraktif: API harus menyembunyikan kompleksitas lapisan bawah dari lapisan atas.</li> <li>Terisolasi: Perubahan pada satu lapisan tidak memengaruhi lapisan lain.</li> </ol>"},{"location":"api/pilar-pilar-api/#715-cloud-native-api","title":"7.1.5 Cloud-Native API","text":"<p>Cloud native adalah pendekatan dalam pembangunan dan pengoperasian aplikasi yang memanfaatkan sepenuhnya kelebihan model penyimpanan cloud. Dalam perancangan API cloud native, beberapa prinsip utama harus diperhatikan adalah:</p> <ol> <li>Scalability: API harus dapat menangani peningkatan jumlah permintaan secara dinamis tanpa mengorbankan kinerja. Implementasi Container dan Serverless dalam bentuk orkestrasi</li> <li>Resilience: API harus dirancang untuk tetap berfungsi meskipun terjadi kegagalan pada komponen tertentu. API harus memiliki kemampuan failover dan juga ketahanan terhadap beban kerja.</li> <li>Automation: Proses deployment dan pengelolaan API harus otomatis untuk mempermudah scaling dan updating.</li> <li>Observability: API harus menyediakan cara untuk memonitor kinerja dan mendeteksi masalah dengan cepat.</li> </ol> <p>Dengan mematuhi prinsip-prinsip ini, API dapat mendukung arsitektur microservices yang efisien dan tangguh, memungkinkan aplikasi untuk berkembang dan beradaptasi dengan cepat terhadap perubahan kebutuhan bisnis.</p>"},{"location":"api/scopes/","title":"7.9 SCOPES","text":"<p>Scopes adalah bagian integral dari pengaturan otorisasi di OAuth 2.0, yang digunakan untuk membatasi hak akses klien terhadap resource API tertentu. Scopes memberikan kontrol granular terhadap apa yang dapat diakses atau dilakukan oleh klien.</p>"},{"location":"api/scopes/#791-kosen-scopes-dalam-oauth-20","title":"7.9.1 Kosen Scopes dalam OAuth 2.0","text":"<p>Scopes didefinisikan untuk menentukan jenis akses yang diizinkan terhadap resource tertentu. Misalnya:</p> <ol> <li><code>user.read</code>: Mengizinkan akses baca terhadap data pengguna.</li> <li><code>user.write</code>: Mengizinkan akses tulis terhadap data pengguna.</li> </ol>"},{"location":"api/scopes/#792-langkah-membuat-scopes-yang-efektif","title":"7.9.2 Langkah Membuat Scopes yang Efektif","text":"<p>Berikut ini adalah langkah-langkah dalam pembuatan scopes yang efektif:</p> <ol> <li> <p>Identifikasi resource yang akan diakses</p> <p>Yaitu dengan menentukan resource dan operasi yang mungkin dilakukan. Misalnya, API untuk manajemen data pengguna dapat memiliki resource seperti:</p> <ul> <li>Profil: Scopes <code>profile.read</code>, <code>profile.update</code>.</li> <li>Postingan: Scopes <code>post.read</code>, <code>post.create</code>, <code>post.delete</code>.</li> <li>Granularitas akses</li> </ul> <p>Membuat scopes yang spesifik untuk meningkatkan keamanan. Misalnya: gunakan <code>post.create</code> daripada scope yang lebih umum seperti <code>write</code>.</p> </li> <li> <p>Penerapan Scopes di API:</p> <p>API harus memvalidasi scope yang dimiliki klien sebelum memberikan akses.</p> <p>Contoh validasi scopes di FastAPI:</p> </li> </ol> <pre><code>from fastapi import Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nfrom typing import List\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\ndef check_scopes(token: str, required_scopes: List[str]):\n    # Simulasi validasi token dan scopes\n    token_scopes = [\"user.read\", \"post.create\"]\n    for scope in required_scopes:\n        if scope not in token_scopes:\n            raise HTTPException(status_code=403, detail=\"Insufficient scope\")\n    return True\n\n@app.get(\"/profile\")\ndef get_profile(token: str = Depends(oauth2_scheme)):\n    check_scopes(token, [\"user.read\"])\n    return {\"message\": \"Profile data\"}\n</code></pre>"},{"location":"api/scopes/#793-dokumentasi-scope","title":"7.9.3 Dokumentasi Scope","text":"<p>Scopes harus terdokumentasi dengan baik, termasuk penjelasan singkat tentang fungsinya yang disertai contoh penggunaannya di API.</p> <p>Dokumentasi yang terintegrasi dengan Swagger atau Redoc dapat membantu pengembang memahami scopes yang tersedia.</p>"},{"location":"api/security-api/","title":"7.8 Keamanan","text":"<p>Keamanan adalah aspek kritis dalam pengembangan API. Memastikan keamanan API melibatkan perlindungan terhadap data pengguna dan mencegah akses tidak sah. Berikut adalah poin-poin penting yang mencakup autentikasi, otorisasi, enkripsi, dan kontrol akses.</p>"},{"location":"api/security-api/#781-autentikasi","title":"7.8.1 Autentikasi","text":"<p>Autentikasi adalah proses untuk memverifikasi identitas pengguna atau klien yang mencoba mengakses API. Metode autentikasi yang direkomendasikan:</p> <ol> <li> <p>JWT (JSON Web Token)</p> <p>Token berbasis JSON yang aman, ringan, dan mendukung autentikasi stateless. Token harus di-validasi pada setiap permintaan untuk memastikan keaslian dan masa berlaku.</p> </li> <li> <p>OAuth 2.0</p> <p>Sistem autentikasi yang lebih kompleks, mendukung third-party access dengan token akses (access token). Hal ini cocok untuk aplikasi yang membutuhkan kontrol akses granular melalui scopes.</p> </li> </ol> <p>Contoh penerapan di FastAPI menggunakan OAuth 2.0:</p> <pre><code>from fastapi import Depends, FastAPI\nfrom fastapi.security import OAuth2PasswordBearer\n\napp = FastAPI()\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n@app.get(\"/protected\")\ndef protected_endpoint(token: str = Depends(oauth2_scheme)):\n    return {\"message\": \"Access granted\", \"token\": token}\n</code></pre>"},{"location":"api/security-api/#782-otorisasi","title":"7.8.2 Otorisasi","text":"<p>Otorisasi berbeda dari autentikasi. Otorisasi memverifikasi apakah pengguna yang sudah terautentikasi memiliki hak akses untuk melakukan aksi tertentu pada resource.</p> <p>Hubungan Autentikasi dan Otorisasi adalah autentikasi dilakukan terlebih dahulu, kemudian diikuti dengan otorisasi untuk menentukan tingkat akses. **Kaitannya dengan Scope (lihat Sub Bab 7.9), o**torisasi diatur melalui scopes pada OAuth 2.0 yang memastikan klien hanya dapat mengakses data atau fitur yang diizinkan.</p> <p>Apabila otorisasi digunakan, maka harus ada kebijakan yang jelas tentang tingkat akses. Misalnya:</p> <ol> <li>Administrator dapat mengakses seluruh resource.</li> <li>Pengguna umum hanya dapat membaca data miliknya sendiri.</li> </ol>"},{"location":"api/security-api/#783-https","title":"7.8.3 HTTPS","text":"<p>HTTPS adalah protokol wajib yang digunakan untuk mengamankan komunikasi antara klien dan server. Data yang dikirimkan akan dienkripsi, sehingga tidak dapat dibaca pihak ketiga selama transmisi. Penggunaan sertifikat SSL/TLS yang valid dapat mencegah serangan man-in-the-middle (MITM).</p>"},{"location":"api/security-api/#784-cors-cross-origin-resource-sharing","title":"7.8.4 CORS (Cross-Origin Resource Sharing)","text":"<p>CORS digunakan untuk membatasi asal (origin) yang diizinkan mengakses API. Konfigurasi CORS yang tepat mencegah serangan seperti Cross-Site Request Forgery (CSRF).</p> <p>Contoh konfigurasi di FastAPI:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"https://trusted-domain.com\"],\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"POST\"],\n    allow_headers=[\"*\"],\n)\n</code></pre>"},{"location":"api/struktur-dasar-api/","title":"7.3 Struktur Dasar API","text":""},{"location":"api/struktur-dasar-api/#731-prefix-produk","title":"7.3.1 Prefix Produk","text":"<p>Apabila dalam satu domain terdapat lebih dari satu produk API, penggunaan prefix produk sangat dianjurkan. Hal ini bertujuan untuk menghindari kebingungan antara API yang berbeda. Prefix yang jelas memungkinkan pengembang dan pengguna API untuk membedakan endpoint-endpoint yang terkait dengan produk tertentu. Misalnya:</p> <ol> <li><code>/vnext/v1/staff</code></li> <li><code>/vnext/v1/student</code></li> <li><code>/datamart/v1/pegawai/</code></li> <li><code>/aksi/v1/kkn/</code></li> </ol> <p>Melainkan apabila hanya terdapat satu produk dalam domain tersebut, maka bisa menggunakan prefix standar seperti <code>/api/v1/</code>.</p>"},{"location":"api/struktur-dasar-api/#732-versioning","title":"7.3.2 Versioning","text":"<p>Penggunaan versioning dalam API adalah prinsip yang sangat penting dimana memungkinkan pengembang untuk merilis pembaruan tanpa mengganggu aplikasi yang telah menggunakan versi API lama. Versi API biasanya tertera pada awal endpoint, seperti <code>/api/v1/</code>. Hal ini memberikan fleksibilitas bagi pengembang untuk memperkenalkan fitur baru atau perbaikan tanpa memengaruhi pengguna yang telah menggunakan versi sebelumnya.</p>"},{"location":"api/struktur-dasar-api/#733-endpoint-naming","title":"7.3.3 Endpoint Naming","text":"<p>Penamaan endpoint API sebaiknya menggunakan kata benda (noun) dan dalam bentuk jamak (plural). Hal ini mengindikasikan bahwa endpoint tersebut mengelola koleksi data dan bukan tindakan. Penggunaan kata kerja pada endpoint sebaiknya dihindari, karena HTTP methods (GET, POST, PUT, DELETE) sudah mengandung aksi tersebut. Misalnya:</p> <ol> <li><code>/api/v1/products</code> untuk koleksi produk.</li> <li><code>/api/v1/orders</code> untuk koleksi pesanan.</li> </ol>"},{"location":"api/validasi-sanitasi/","title":"7.6 Data Validation dan Sanitization","text":"<p>Data Validation dan Sanitization merupakan dua langkah penting dalam pengolahan data yang diterima oleh API untuk menjaga integritas, keamanan, dan memastikan bahwa data yang diterima oleh sistem adalah hanya data yang valid. Keduanya sangat penting untuk melindungi sistem dari serangan dan kesalahan yang dapat terjadi akibat data yang tidak valid atau berbahaya.</p>"},{"location":"api/validasi-sanitasi/#761-validasi-input","title":"7.6.1 Validasi Input","text":"<p>Validasi input adalah proses pemeriksaan data yang diterima dari klien (seperti melalui parameter URL, body request, atau header) untuk memastikan bahwa data tersebut memenuhi kriteria yang diharapkan. Hal tersebut berfungsi untuk:</p> <ol> <li>Menjamin integritas data: Memastikan bahwa data yang diterima sesuai dengan format dan tipe yang diharapkan.</li> <li>Mencegah eksploitasi: Menghindari serangan seperti SQL Injection, Cross-Site Scripting (XSS), dan Buffer Overflow yang bisa terjadi akibat data yang tidak tervalidasi dengan benar.</li> </ol>"},{"location":"api/validasi-sanitasi/#teknik-validasi-umum","title":"Teknik Validasi Umum:","text":"<ol> <li> <p>Format Data</p> <p>Memeriksa apakah data yang diterima sesuai dengan format yang benar. Misalnya, memastikan bahwa email adalah email yang valid, atau tanggal berada dalam format yang benar.</p> <p>Contoh: Memastikan bahwa field email hanya berisi alamat email yang valid (<code>user@example.com</code>).</p> <p>Tools: Bisa menggunakan library seperti <code>email-validator</code> di Python atau <code>validator</code> di JavaScript.</p> </li> <li> <p>Tipe Data</p> <p>Memastikan bahwa tipe data yang diterima sesuai dengan yang diinginkan. Misalnya, apabila aplikasi mengharapkan sebuah angka (integer), maka harus dipastikan data tersebut adalah angka, bukan string atau karakter lain.</p> <p>Contoh: Memastikan bahwa nilai pada field \"age\" adalah tipe data integer.</p> <p>Tools: Misalnya, menggunakan <code>Pydantic</code> (di FastAPI) atau <code>Joi</code> (di Node.js).</p> </li> <li> <p>Nilai yang Diharapkan (Range)</p> <p>Memeriksa apakah nilai yang diterima berada dalam rentang yang dapat diterima. Contoh, umur pengguna tidak boleh kurang dari 0 atau lebih dari 120. Contoh: Memeriksa apakah nilai harga produk berada dalam rentang yang diizinkan (misalnya, 0 hingga 10,000).</p> </li> <li> <p>Kewajiban</p> <p>Memastikan bahwa data yang penting atau wajib ada (misalnya, nama atau email) benar-benar ada dalam permintaan dan tidak kosong. Contoh: Memastikan bahwa field <code>username</code> dan <code>password</code> tidak kosong pada saat melakukan registrasi.</p> </li> </ol>"},{"location":"api/validasi-sanitasi/#library-dan-tools-untuk-validasi","title":"Library dan Tools untuk Validasi:","text":"<ol> <li>FastAPI (Python): <code>Pydantic</code> menyediakan validasi otomatis untuk model data yang dikirimkan oleh klien.</li> <li>Express Validator (Node.js): Middleware untuk memvalidasi data input di aplikasi Express.</li> <li>Joi (Node.js): Validasi data berbasis skema yang kuat untuk menangani data yang diterima dari klien.</li> </ol> <p>Contoh penggunaan validasi input di FastAPI dengan Pydantic</p> <pre><code>from pydantic import BaseModel, EmailStr, condecimal\nfrom datetime import date\n\nclass UserRequest(BaseModel):\n    username: str\n    email: EmailStr\n    date_of_birth: date\n    salary: condecimal(gt=0)  # Memastikan salary lebih dari 0\n\n# Contoh endpoint FastAPI yang menggunakan validasi input\n@app.post(\"/register\")\nasync def register(user: UserRequest):\n    return {\"message\": \"User created successfully\", \"user\": user}\n</code></pre>"},{"location":"api/validasi-sanitasi/#762-sanitization-atau-pembersihan-data","title":"7.6.2 Sanitization atau Pembersihan Data","text":"<p>Sanitization adalah proses untuk membersihkan data yang diterima agar tidak mengandung karakter atau konten yang berbahaya yang bisa digunakan untuk melakukan eksploitasi atau serangan. Sanitization bertujuan untuk melindungi aplikasi dari ancaman yang dapat merusak integritas sistem atau data, seperti Cross-Site Scripting (XSS) atau SQL Injection.</p>"},{"location":"api/validasi-sanitasi/#tujuan-sanitization","title":"Tujuan Sanitization:","text":"<ol> <li> <p>Menghapus karakter berbahaya</p> <p>Menghindari karakter atau script yang dapat dieksekusi oleh browser atau server yang dapat dimanfaatkan oleh penyerang.</p> </li> <li> <p>Menjaga keamanan sistem</p> <p>Mencegah eksploitasi celah keamanan seperti SQL Injection dan Cross-Site Scripting (XSS).</p> </li> </ol>"},{"location":"api/validasi-sanitasi/#teknik-sanitization","title":"Teknik Sanitization:","text":"<ol> <li> <p>Escaping Input</p> <p>Menambahkan karakter escape pada data input, seperti menambahkan backslash pada tanda kutip (<code>'</code>) atau tanda petik ganda (<code>\"</code>), agar data tersebut tidak bisa dieksekusi.</p> <p>Contoh: Pada input HTML, tanda <code>&lt;</code> dan <code>&gt;</code> perlu diubah menjadi <code>&amp;lt;</code> dan <code>&amp;gt;</code> untuk mencegah eksekusi script HTML.</p> </li> <li> <p>HTML Sanitization</p> <p>Menghapus atau mengganti elemen HTML yang tidak diinginkan, seperti script atau event handler.</p> <p>Contoh: Menghapus tag <code>&lt;script&gt;</code> atau atribut <code>onload</code> yang dapat digunakan untuk XSS.</p> </li> <li> <p>SQL Sanitization</p> <p>Menghindari penggunaan data input langsung dalam query SQL yang dapat digunakan untuk SQL Injection. Salah satu teknik untuk ini adalah dengan menggunakan parameterized queries atau ORM (Object-Relational Mapping) yang aman.</p> <p>Contoh: Menggunakan query parameterized atau ORM untuk mencegah eksekusi SQL yang berbahaya.</p> </li> </ol>"},{"location":"api/validasi-sanitasi/#library-dan-tools-untuk-sanitization","title":"Library dan Tools untuk Sanitization:","text":"<ol> <li>HTMLPurifier (PHP): Menghapus atau memodifikasi elemen-elemen HTML yang tidak aman.</li> <li>Sanitizer (JavaScript): Library untuk membersihkan HTML dan mencegah XSS.</li> <li>OWASP Java HTML Sanitizer: Library Java untuk sanitasi HTML.</li> <li>FastAPI + Pydantic: Walaupun FastAPI sendiri tidak melakukan sanitasi secara otomatis, Sanitasi bisa memanfaatkan library lain untuk sanitasi input (misalnya, menggunakan <code>bleach</code> untuk sanitasi HTML). </li> </ol> <p>Berikut merupakan contoh sanitasi input dengan <code>bleach</code></p> <pre><code>from fastapi import FastAPI, Form\nimport bleach\n\napp = FastAPI()\n\n@app.post(\"/sanitize\")\nasync def sanitize_input(data: str = Form(...)):\n    sanitized_data = bleach.clean(data)\n    return {\"sanitized_data\": sanitized_data}\n</code></pre> <p>Pada framework FastAPI dengan Pydantic memastikan bahwa data yang diterima memiliki tipe yang benar. Ini membantu mencegah beberapa jenis eksploitasi.</p> <pre><code>from pydantic import BaseModel, EmailStr\n\nclass UserRequest(BaseModel):\n    username: str\n    email: EmailStr  # Validasi email\n    age: int  # Memastikan ini integer\n\n@app.post(\"/user\")\nasync def create_user(user: UserRequest):\n    return {\"username\": user.username, \"email\": user.email, \"age\": user.age}\n</code></pre> <p>Untuk sanitasi data yang akan dimasukan ke query database, dapat menggunakan query parameter untuk mencegah sql injection.</p> <pre><code>from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import text\n\napp = FastAPI()\n\n@app.post(\"/safe_query\")\nasync def safe_query(username: str, db: AsyncSession):\n    # Query dengan parameterized untuk mencegah SQL Injection\n    result = await db.execute(\n        text(\"SELECT * FROM users WHERE username = :username\"),\n        {\"username\": username}\n    )\n    user = result.fetchone()\n    return {\"user\": user}\n</code></pre>"},{"location":"api-gateway/fungsi_lain_krakend/","title":"8.4 Fungsi Lain dari Krakend","text":""},{"location":"api-gateway/fungsi_lain_krakend/#841-transformasi-data","title":"8.4.1 Transformasi Data","text":"<p>Transformasi data memungkinkan Krakend mengubah struktur data respons sebelum mengirimkannya ke klien. Contoh kasus termasuk menghapus field sensitif atau menambahkan informasi tambahan.</p> <p>Contoh Transformasi:</p> <p>Misalkan backend mengembalikan data berikut:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"John Doe\",\n  \"password\": \"hashedpassword\"\n}\n</code></pre> <p>Kemudian ingin menghapus field <code>password</code> dari respons, maka configurasi seperti ini:</p> <pre><code>{\n  \"endpoints\": [\n    {\n      \"endpoint\": \"/api/v1/user\",\n      \"method\": \"GET\",\n      \"backend\": [\n        {\n          \"host\": [\"http://user-service\"],\n          \"url_pattern\": \"/user-data\"\n        }\n      ],\n      \"extra_config\": {\n        \"github.com/devopsfaith/krakend-jsonschema\": {\n          \"properties\": {\n            \"id\": {},\n            \"name\": {}\n          }\n        }\n      }\n    }\n  ]\n}\n</code></pre> <p>Hasil transformasi:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"John Doe\"\n}\n</code></pre>"},{"location":"api-gateway/fungsi_lain_krakend/#842-load-balancing","title":"8.4.2 Load Balancing","text":"<p>Krakend mendukung load balancing untuk mendistribusikan permintaan secara merata ke beberapa instance backend.</p> <p>Contoh Load Balancing:</p> <pre><code>{\n  \"backend\": [\n    {\n      \"host\": [\"http://backend1-service\", \"http://backend2-service\"],\n      \"url_pattern\": \"/data\"\n    }\n  ]\n}\n</code></pre> <p>Fitur ini membantu meningkatkan ketersediaan layanan dan menangani lebih banyak permintaan.</p>"},{"location":"api-gateway/fungsi_lain_krakend/#843-monitoring","title":"8.4.3 Monitoring","text":"<p>Monitoring penting untuk memantau performa API Gateway, mengidentifikasi bottleneck, dan mendeteksi masalah sebelum memengaruhi layanan secara keseluruhan. Krakend mendukung integrasi dengan Prometheus, alat open-source yang populer untuk pengumpulan dan analisis metrik.</p>"},{"location":"api-gateway/fungsi_lain_krakend/#konfigurasi-monitoring-dengan-prometheus","title":"Konfigurasi Monitoring dengan Prometheus","text":"<ul> <li> <p>Mengaktifkan Monitoring di Krakend: Tambahkan konfigurasi berikut dalam file JSON Krakend untuk mengaktifkan metrik Prometheus: <pre><code>{\n  \"extra_config\": {\n    \"github_com/devopsfaith/krakend-metrics\": {\n      \"collection_time\": \"60s\",\n      \"proxy_disabled\": false,\n      \"router_disabled\": false,\n      \"endpoint\": \"/__metrics\"\n    }\n  }\n}\n</code></pre> Penjelasan konfigurasi:</p> </li> <li> <p><code>collection_time</code>: Interval pengumpulan metrik. Misalnya, \"60s\" berarti setiap 60 detik.</p> </li> <li><code>proxy_disabled</code>: Jika <code>false</code>, metrik dari lapisan proxy akan dikumpulkan.</li> <li><code>router_disabled</code>: Jika <code>false</code>, metrik dari lapisan routing akan dikumpulkan.</li> <li> <p><code>endpoint</code>: Endpoint tempat metrik Prometheus dapat diakses (default: <code>/__metrics</code>).</p> </li> <li> <p>Expose Endpoint Metrik: Endpoint <code>/__metrics</code> akan tersedia setelah konfigurasi diaktifkan. Prometheus dapat mengakses endpoint ini untuk menarik (scrape) metrik. Contoh respons dari endpoint <code>/__metrics</code>: <pre><code># HELP krakend_requests_total Total number of requests handled\n# TYPE krakend_requests_total counter\nkrakend_requests_total{endpoint=\"/api/v1/resource\",method=\"GET\"} 150\nkrakend_requests_total{endpoint=\"/api/v1/secure\",method=\"POST\"} 50\n</code></pre></p> </li> <li> <p>Menambahkan Krakend ke Konfigurasi Prometheus: Tambahkan Krakend sebagai target di file konfigurasi Prometheus (<code>prometheus.yml</code>): <pre><code>scrape_configs:\n  - job_name: \"krakend\"\n    static_configs:\n      - targets: [\"localhost:8080\"] # Ganti dengan host dan port Krakend\n</code></pre></p> </li> </ul>"},{"location":"api-gateway/fungsi_lain_krakend/#metrik-yang-didukung-krakend","title":"Metrik yang Didukung Krakend","text":"<p>Berikut adalah beberapa metrik utama yang dihasilkan oleh Krakend:</p> <ol> <li><code>krakend_requests_total</code>: Jumlah total permintaan yang diterima oleh endpoint tertentu.</li> <li><code>krakend_latency_ms</code>: Latensi permintaan dalam milidetik.</li> <li><code>krakend_backend_latency_ms</code>: Latensi antara Krakend dan backend untuk permintaan tertentu.</li> <li><code>krakend_response_size_bytes</code>: Ukuran respons yang dikirimkan oleh endpoint tertentu.</li> <li><code>krakend_errors_total</code>: Jumlah total kesalahan yang terjadi pada endpoint.</li> </ol>"},{"location":"api-gateway/fungsi_lain_krakend/#visualisasi-dengan-grafana","title":"Visualisasi dengan Grafana","text":"<p>Prometheus dapat diintegrasikan dengan Grafana untuk membuat dashboard visual.</p> <ol> <li>Tambahkan Prometheus sebagai Data Source di Grafana.</li> <li> <p>Buat panel baru di Grafana untuk memvisualisasikan metrik tertentu. Misalnya:</p> <ul> <li> <p>Query untuk jumlah permintaan per endpoint: <pre><code>sum(rate(krakend_requests_total[1m])) by (endpoint\n</code></pre></p> </li> <li> <p>Query untuk latensi rata-rata: <pre><code>avg(krakend_latency_ms) by (endpoint)\n</code></pre></p> </li> </ul> </li> </ol>"},{"location":"api-gateway/fungsi_lain_krakend/#844-logging","title":"8.4.4 Logging","text":""},{"location":"api-gateway/fungsi_lain_krakend/#format-logging","title":"Format Logging","text":"<p>Secara default, Krakend mencatat log di konsol dalam format JSON. Log ini mencakup informasi seperti permintaan, respons, waktu proses, dan kesalahan.</p> <p>Contoh log Krakend:</p> <pre><code>{\n  \"level\": \"INFO\",\n  \"time\": \"2024-12-12T10:00:00Z\",\n  \"message\": \"Request completed\",\n  \"method\": \"GET\",\n  \"endpoint\": \"/api/v1/resource\",\n  \"status\": 200,\n  \"duration\": 45\n}\n</code></pre>"},{"location":"api-gateway/fungsi_lain_krakend/#customizing-logging","title":"Customizing Logging","text":"<p>Logging Krakend dapat dikustomisasi dengan menambahkan plugin logging atau menggunakan log processor eksternal seperti ELK Stack (Elasticsearch, Logstash, Kibana).</p> <p>Tambahkan konfigurasi untuk log level:</p> <pre><code>{\n  \"logs\": {\n    \"level\": \"DEBUG\" // Level log: DEBUG, INFO, WARN, ERROR\n  }\n}\n</code></pre>"},{"location":"api-gateway/fungsi_lain_krakend/#845-caching","title":"8.4.5 Caching","text":"<p>Krakend mendukung caching untuk meningkatkan performa response API. Berikut contoh konfigurasi caching:</p> <p><pre><code>{\n  \"extra_config\": {\n    \"github.com/devopsfaith/krakend-httpcache\": {\n      \"cache_size\": 1000,\n      \"memory\": {\n        \"max\": 100\n      }\n    }\n  }\n}\n</code></pre> Keterangan:</p> <ul> <li><code>cache_size</code>: Ukuran cache maksimum.</li> <li><code>memory.max</code>: Kapasitas maksimum memori untuk cache.</li> </ul>"},{"location":"api-gateway/intro/","title":"BAB 8 API Gateway","text":"<p>API Gateway adalah komponen penting dalam arsitektur sistem modern yang bertindak sebagai pintu masuk utama untuk semua permintaan ke layanan backend. API Gateway mengelola routing, autentikasi, otorisasi, transformasi data, serta fitur tambahan seperti caching dan rate limiting. Dalam skenario microservices, API Gateway membantu menyederhanakan komunikasi antara klien dan layanan backend yang terdistribusi.</p>"},{"location":"api-gateway/intro/#81-mengapa-menggunakan-api-gateway","title":"8.1 Mengapa Menggunakan API Gateway?","text":"<p>Hal-hal yang mendasari penggunaan API Gateway adalah sebagai berikut:</p> <ol> <li>Sentralisasi Pengelolaan API: API Gateway menyediakan satu titik masuk untuk semua permintaan, sehingga memudahkan pengelolaan API.</li> <li>Keamanan: API Gateway mendukung autentikasi, otorisasi, dan pengaturan tingkat akses.</li> <li>Optimasi Kinerja: Dengan caching, rate limiting, dan transformasi data, API Gateway dapat meningkatkan performa API.</li> <li>Abstraksi Layanan Backend: Klien tidak perlu mengetahui detail layanan backend. API Gateway menyembunyikan kompleksitas ini.</li> <li>Pengaturan Trafik: API Gateway mendukung fitur seperti rate limiting untuk membatasi jumlah permintaan dari klien tertentu.</li> </ol>"},{"location":"api-gateway/karakend_api_gateway/","title":"Apa itu KrakenD?","text":""},{"location":"api-gateway/karakend_api_gateway/#82-krakend-sebagai-api-gateway","title":"8.2 Krakend sebagai API Gateway","text":""},{"location":"api-gateway/karakend_api_gateway/#821-apa-itu-krakend","title":"8.2.1 Apa itu Krakend?","text":"<p>Krakend adalah API Gateway open-source yang ringan dan dirancang untuk performa tinggi. Krakend menggunakan konfigurasi berbasis file JSON, sehingga mudah digunakan dan diintegrasikan ke dalam sistem yang ada.</p>"},{"location":"api-gateway/karakend_api_gateway/#822-mengapa-memilih-krakend","title":"8.2.2 Mengapa Memilih Krakend?","text":"<p>Berikut ini adalah beberapa pertimbangan dalam pemilihan Krakend:</p> <ol> <li>Ringan dan Cepat: Krakend dirancang untuk menangani beban berat dengan latensi rendah.</li> <li>Konfigurasi Sederhana: File konfigurasi JSON memungkinkan pengaturan cepat tanpa perlu menulis kode.</li> <li>Ekstensi dan Fleksibilitas: Dukungan plugin dan integrasi dengan berbagai komponen seperti sistem autentikasi OAuth 2.0.</li> <li>Fitur Lanjutan: Mendukung rate limiting, caching, transformasi data, dan load balancing.</li> <li>Open Source: Komunitas yang aktif dan bebas biaya.</li> </ol>"},{"location":"api-gateway/krakend_fastapi/","title":"Flexibel Configuration","text":""},{"location":"api-gateway/krakend_fastapi/#85-flexibel-configuration-krakend-dengan-fastapi","title":"8.5 Flexibel Configuration KrakenD dengan FastAPI","text":"<p>Flexible Configuration memungkinkan pembuatan konfigurasi API Gateway menggunakan KrakenD secara otomatis dengan memanfaatkan template Go. FastAPI menyediakan kemampuan untuk menghasilkan file <code>openapi.json</code> yang berisi informasi detail tentang API, seperti host, endpoint, dan parameter yang dibutuhkan. Dengan menggunakan file <code>openapi.json</code>, konfigurasi KrakenD dapat dihasilkan secara otomatis dan disesuaikan dengan kebutuhan lingkungan development atau production.</p> <p>Template Go pada KrakenD mempermudah pengelolaan konfigurasi dengan membagi file besar menjadi bagian-bagian kecil yang lebih mudah dikelola dan dimodifikasi. Konfigurasi ini memungkinkan pengelolaan API secara modular dan fleksibel.</p>"},{"location":"api-gateway/krakend_fastapi/#851-langkah-langkah-generate-konfigurasi-krakend-dengan-script","title":"8.5.1 Langkah-langkah Generate Konfigurasi KrakenD dengan Script","text":"<p>Berikut adalah langkah-langkah untuk menghasilkan konfigurasi KrakenD secara otomatis dengan menggunakan script PHP yang membaca file <code>openapi.json</code> dan menghasilkan file template KrakenD.</p> <ol> <li>Persiapkan File <code>openapi.json</code>: FastAPI secara otomatis menghasilkan file <code>openapi.json</code> yang berisi informasi endpoint, parameter, dan host API. Pastikan file <code>openapi.json</code> tersedia dan dapat diakses oleh script.</li> <li>Gunakan Script PHP untuk Menghasilkan Konfigurasi KrakenD: Berikut adalah script PHP yang digunakan untuk membaca <code>openapi.json</code> dan menghasilkan konfigurasi KrakenD secara otomatis.</li> </ol>"},{"location":"api-gateway/krakend_fastapi/#script-php-untuk-menghasilkan-konfigurasi-krakend","title":"Script PHP untuk Menghasilkan Konfigurasi KrakenD","text":"<pre><code>&lt;?php\nrequire 'helper.php';\n\n$list_openapi_json = __DIR__ . '/../config/list_openapi.json';\n$PATH_SETTING_HOST = __DIR__ . '/../config/krakend/settings';\n$INPUT_HEADERS_FILENAME = __DIR__ . '/../config/krakend/partials/input_headers.tmpl';\n$SETTING_HOST_FILENAME = 'host.json';\n$PATH_ENDPOINTS = __DIR__ . '/../config/krakend/endpoints';\n\n// Baca file JSON dan decode dengan error handling yang lebih baik\n$list_openapi_data = file_get_contents($list_openapi_json);\nif ($list_openapi_data === false) {\n    die(\"Gagal membaca file config OPENAPI.JSON\");\n}\n\ntry {\n    $list_openapi = json_decode($list_openapi_data, true, 512, JSON_THROW_ON_ERROR);\n} catch (JsonException $e) {\n    die(\"Gagal decode JSON: \" . $e-&gt;getMessage());\n}\n\n$SETTING_HOST_PROD = [];\n$SETTING_HOST_DEV = [];\n$input_headers = [\"Content-Type\", \"Authorization\", \"Accept\"];\n\n$SETTING_HOST_PROD['vnext_staff'] = \"host_prod_1\";\n$SETTING_HOST_DEV['vnext_staff'] = \"host_dev_1\";\n$SETTING_HOST_PROD['vnext_student'] = \"host_prod_2\";\n$SETTING_HOST_DEV['vnext_student'] = \"host_dev_2\";\n\n// Loop untuk mengisi konfigurasi host berdasarkan environment\nforeach ($list_openapi as $openapi) {\n    $endpoints = [];\n    $API_NAME_CLEAN = make_url_friendly($openapi['name']);\n    // buat object untuk host.json\n    foreach ($openapi['host'] as $host) {\n        if ($host['environment'] === 'production') {\n            $SETTING_HOST_PROD[$API_NAME_CLEAN] = $host['url'];\n        } elseif ($host['environment'] === 'development') {\n            $SETTING_HOST_DEV[$API_NAME_CLEAN] = $host['url'];\n        }\n    }\n\n    $openapi_json_content = file_get_contents($openapi['url']);\n\n    if ($openapi_json_content === false) {\n        die(\"Gagal membaca file config openapi.json : \".$openapi['name']);\n    }\n\n    try {\n        $openapi_content = json_decode($openapi_json_content, true);\n    } catch (JsonException $e) {\n        die(\"Gagal decode JSON: \" . $e-&gt;getMessage());\n    }\n\n    $version = make_url_friendly($openapi_content['info']['version']);\n\n    $paths = array_keys($openapi_content['paths']);\n    foreach( $paths as $path) {\n        if ($path == \"/\"){\n            continue;\n        }\n        $methods = array_keys($openapi_content['paths'][$path]);\n\n        foreach( $methods as $method) {\n            $query = array();\n\n            if (isset($openapi_content['paths'][$path][$method]['parameters'])){\n                $data = array_keys($openapi_content['paths'][$path][$method]['parameters']);\n                foreach($data as $row =&gt; $item){\n                    if (isset($openapi_content['paths'][$path][$method]['parameters'][$item])){\n                        $d1 = $openapi_content['paths'][$path][$method]['parameters'][$item];\n                        if ($d1['in'] == 'query'){\n                            $query[] = $d1[\"name\"];\n                        }\n                    }\n                }\n            }\n            $endpoints[] = array(\n                \"endpoint\" =&gt; $path,\n                \"method\" =&gt; strtoupper($method),\n                \"output_encoding\" =&gt; \"no-op\",\n                \"backend\" =&gt; array(\n                    array(\n                        \"url_pattern\" =&gt; $path,\n                        \"encoding\" =&gt; \"json\",\n                        \"sd\" =&gt; \"static\",\n                        \"method\" =&gt; strtoupper($method),\n                        \"host\" =&gt; [\n                            \"{{ .host.\".$API_NAME_CLEAN.\" }}\"\n                        ],\n                        \"disable_host_sanitize\" =&gt; false\n                    )\n                ),\n                \"input_query_strings\" =&gt; $query,\n                \"input_headers\" =&gt; '{{ include \"input_headers.tmpl\" }}'\n            );\n        }\n    }\n\n    try {\n        if (!empty($endpoints)) {\n            write_json_file(\n                $PATH_ENDPOINTS . DIRECTORY_SEPARATOR . $API_NAME_CLEAN.'.tmpl',\n                $endpoints,\n                true\n            );\n        }\n\n    } catch (JsonException $e) {\n        die(\"Gagal encode JSON untuk endpoints \".$openapi['name'].\" file: \" . $e-&gt;getMessage());\n    }\n\n}\n\n// buat input_headers.tmpl\ntry {\n    write_json_file($INPUT_HEADERS_FILENAME, $input_headers);\n}catch (JsonException $e) {\n    die(\"Gagal encode JSON: \" . $e-&gt;getMessage());\n}\n\ntry {\n    if (!empty($SETTING_HOST_PROD)) {\n        write_json_file(\n            $PATH_SETTING_HOST . DIRECTORY_SEPARATOR . 'prod' . DIRECTORY_SEPARATOR . $SETTING_HOST_FILENAME,\n            $SETTING_HOST_PROD\n        );\n    }\n\n    if (!empty($SETTING_HOST_DEV)) {\n        write_json_file(\n            $PATH_SETTING_HOST . DIRECTORY_SEPARATOR . 'dev' . DIRECTORY_SEPARATOR . $SETTING_HOST_FILENAME,\n            $SETTING_HOST_DEV\n        );\n    }\n} catch (JsonException $e) {\n    die(\"Gagal encode JSON untuk host file: \" . $e-&gt;getMessage());\n}\n</code></pre>"},{"location":"api-gateway/krakend_fastapi/#output-struktur-folder","title":"Output Struktur Folder","text":"<p>Setelah menjalankan script di atas, struktur folder untuk konfigurasi KrakenD yang dihasilkan adalah sebagai berikut:</p> <pre><code>krakend/\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 krakend/\n\u2502   \u2502   \u251c\u2500\u2500 endpoints/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 api_name.tmpl\n\u2502   \u2502   \u251c\u2500\u2500 partials/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 input_headers.tmpl\n\u2502   \u2502   \u251c\u2500\u2500 settings/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 dev/\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 host.json\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 prod/\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 host.json\n|   |   |__ krakend.tmpl\n\u2502   \u2514\u2500\u2500 list_openapi.json\n\u2514\u2500\u2500 helper.php\n</code></pre> <p>Keuntungan konfigurasi API Gateway menggunakan KrakenD adalah:</p> <ol> <li>Otomatisasi: Konfigurasi KrakenD dapat dihasilkan secara otomatis, mengurangi kesalahan dan mempercepat waktu pengembangan.</li> <li>Modular dan Organisatif: Konfigurasi API dibagi menjadi bagian-bagian kecil yang lebih mudah dikelola, seperti template endpoint dan file host terpisah untuk lingkungan yang berbeda.</li> <li>Fleksibilitas dan Skalabilitas: Memungkinkan pengelolaan API yang berbeda di lingkungan yang berbeda tanpa perlu perubahan manual pada setiap file konfigurasi.</li> </ol>"},{"location":"api-gateway/menggunakan_krakend/","title":"Menggunakan KrakenD","text":""},{"location":"api-gateway/menggunakan_krakend/#83-menggunakan-krakend","title":"8.3 Menggunakan Krakend","text":""},{"location":"api-gateway/menggunakan_krakend/#831-membuat-file-konfigurasi","title":"8.3.1 Membuat File Konfigurasi","text":"<p>Krakend menggunakan file konfigurasi JSON untuk mengatur semua fitur. Berikut adalah contoh struktur dasar file konfigurasi Krakend:</p> <p><pre><code>{\n  \"version\": 3,\n  \"name\": \"API Gateway\",\n  \"port\": 8080,\n  \"endpoints\": [\n    {\n      \"endpoint\": \"/api/v1/resource\",\n      \"method\": \"GET\",\n      \"backend\": [\n        {\n          \"url_pattern\": \"/resource\",\n          \"host\": [\n            \"http://backend-service\"\n          ]\n        }\n      ]\n    }\n  ]\n}\n</code></pre> Keterangan:</p> <ul> <li><code>version</code>: Versi konfigurasi.</li> <li><code>name</code>: Nama gateway.</li> <li><code>port</code>: Port yang digunakan oleh Krakend.</li> <li><code>endpoints</code>: Daftar endpoint API yang dikelola oleh gateway.</li> </ul>"},{"location":"api-gateway/menggunakan_krakend/#832-rate-limiting","title":"8.3.2 Rate Limiting","text":"<p>Rate limiting membatasi jumlah permintaan yang dapat dilakukan oleh klien dalam periode waktu tertentu. Contoh konfigurasi rate limiting di Krakend:</p> <p><pre><code>{\n  \"extra_config\": {\n    \"github_com/devopsfaith/krakend-ratelimit/juju\": {\n      \"maxRate\": 5,\n      \"clientMaxRate\": 2,\n      \"strategy\": \"ip\"\n    }\n  }\n}\n</code></pre> Keterangan:</p> <ul> <li><code>maxRate</code>: Jumlah maksimum permintaan per detik untuk semua klien.</li> <li><code>clientMaxRate</code>: Jumlah maksimum permintaan per detik per klien.</li> <li><code>strategy</code>: Strategi identifikasi klien (misalnya berdasarkan IP).</li> </ul>"},{"location":"api-gateway/menggunakan_krakend/#833-integrasi-dengan-server-oauth-20","title":"8.3.3 Integrasi dengan Server OAuth 2.0","text":"<p>Krakend mendukung validasi token JWT (JSON Web Token) dari server OAuth 2.0. Dengan konfigurasi ini, Krakend dapat memastikan bahwa hanya permintaan dengan token yang valid yang diteruskan ke backend.</p>"},{"location":"api-gateway/menggunakan_krakend/#memvalidasi-token-jwt","title":"Memvalidasi Token JWT","text":"<p>Krakend menggunakan plugin krakend-jose untuk memvalidasi token JWT. Berikut adalah langkah-langkah konfigurasinya:</p> <p><pre><code>{\n  \"endpoints\": [\n    {\n      \"endpoint\": \"/api/v1/secure\",\n      \"method\": \"GET\",\n      \"backend\": [\n        {\n          \"host\": [\"http://backend-service\"],\n          \"url_pattern\": \"/secure-data\"\n        }\n      ],\n      \"extra_config\": {\n        \"github.com/devopsfaith/krakend-jose/validator\": {\n          \"alg\": \"RS256\",\n          \"jwk-url\": \"https://auth-server.com/.well-known/jwks.json\",\n          \"issuer\": \"https://auth-server.com/\",\n          \"audience\": [\"api-client-id\"],\n          \"disable_jwk_security\": false\n        }\n      }\n    }\n  ]\n}\n</code></pre> Keterangan:</p> <ul> <li><code>alg</code>: Algoritma untuk memvalidasi token (misalnya RS256).</li> <li><code>jwk-url</code>: URL ke JSON Web Key Set (JWKS) yang berisi kunci publik untuk memverifikasi token.</li> <li><code>issuer</code>: Identitas server yang mengeluarkan token (harus sesuai dengan <code>iss</code> di token).</li> <li><code>audience</code>: Daftar klien yang diizinkan menggunakan token (harus sesuai dengan <code>aud</code> di token).</li> </ul>"},{"location":"api-gateway/menggunakan_krakend/#834-menentukan-scope-di-endpoint","title":"8.3.4 Menentukan Scope di Endpoint","text":"<p>Scope digunakan untuk membatasi hak akses klien terhadap endpoint tertentu. </p> <p>Contoh implementasi: Krakend dapat memastikan bahwa token memiliki scope tertentu sebelum mengizinkan akses ke endpoint. </p> <p>Scope memungkinkan pembatasan granular terhadap tindakan yang dapat dilakukan oleh klien.</p> <p>Contoh konfigurasi:</p> <p><pre><code>{\n  \"endpoints\": [\n    {\n      \"endpoint\": \"/api/v1/user-profile\",\n      \"method\": \"GET\",\n      \"backend\": [\n        {\n          \"host\": [\"http://user-service\"],\n          \"url_pattern\": \"/profile\"\n        }\n      ],\n      \"extra_config\": {\n        \"github.com/devopsfaith/krakend-jose/validator\": {\n          \"jwk-url\": \"https://auth-server.com/.well-known/jwks.json\",\n          \"roles_key\": \"scope\",\n          \"roles\": [\"profile.read\"]\n        }\n      }\n    },\n    {\n      \"endpoint\": \"/api/v1/admin\",\n      \"method\": \"GET\",\n      \"backend\": [\n        {\n          \"host\": [\"http://admin-service\"],\n          \"url_pattern\": \"/admin-data\"\n        }\n      ],\n      \"extra_config\": {\n        \"github.com/devopsfaith/krakend-jose/validator\": {\n          \"jwk-url\": \"https://auth-server.com/.well-known/jwks.json\",\n          \"roles_key\": \"scope\",\n          \"roles\": [\"admin.read\"]\n        }\n      }\n    }\n  ]\n}\n</code></pre> Keterangan:</p> <ul> <li><code>roles_key</code>: Field di dalam token yang menyimpan daftar scope.</li> <li><code>roles</code>: Daftar scope yang diperlukan untuk mengakses endpoint.</li> </ul>"},{"location":"arsitektur-prinsip/arsitektur-sistem/","title":"BAB 2 Arsitektur Sistem","text":"<p>Arsitektur sistem adalah kerangka kerja yang mendefinisikan bagaimana sebuah komponen atau modul dalam sebuah sistem akan berinteraksi satu sama lain. Bagaimana data mengalir antar bagian, dan bagaimana aplikasi dikelola secara keseluruhan. Pemilihan arsitektur yang tepat sangat penting karena akan mempengaruhi cara sistem dibangun, dipelihara, dan dikembangkan di masa depan. Beberapa konsep arsitektur sistem yang dapat dipilih sebagai dasar struktur sistem sebelum pengembangan dimulai, masing-masing dengan kelebihan dan kekurangan yang perlu dipertimbangkan.</p>"},{"location":"arsitektur-prinsip/arsitektur-sistem/#21-pertimbangan-memilih-arsitektur","title":"2.1. Pertimbangan Memilih Arsitektur","text":"<p>Dalam memilih arsitektur sistem, biasanya mempertimbangkan beberapa faktor seperti berikut:</p> <ol> <li>Kompleksitas aplikasi<ol> <li>Apakah aplikasi ini relatif sederhana atau kompleks ?</li> <li>Apakah sistem akan terus berkembang ?</li> </ol> </li> <li>Kebutuhan kinerja dan skalabilitas<ol> <li>Seberapa penting aplikasi dapat berkembang secara horizontal atau menangani lonjakan permintaan pengguna ?</li> <li>Apakah aplikasi akan besar dengan ribuan pengguna atau cukup untuk pengguna internal ?</li> </ol> </li> <li>Kemudahan pemeliharaaan<ol> <li>Apakah aplikasi akan dikembangkan dan dikelola oleh tim yang kecil atau besar ?</li> <li>Seberapa terampil tim pengembangan ?</li> </ol> </li> <li>Waktu dan biaya pengembangan<ol> <li>Seberapa cepat aplikasi perlu diluncurkan ?</li> <li>Bagaimana anggaran untuk pengembangan ?</li> </ol> </li> <li>Kebutuhan fleksibilitas<ol> <li>Apakah aplikasi mungkin akan berkembang atau diubah fungsinya di masa depan ?</li> <li>Jika akan diubah, seberapa sering aplikasi perlu diperbaruhi ?</li> </ol> </li> <li>Integrasi dengan sistem lain<ol> <li>Apakah aplikasi memerlukan integrasi dengan sistem lain ?</li> <li>Fitur apa saja yang akan diintegrasikan ?</li> </ol> </li> </ol>"},{"location":"arsitektur-prinsip/arsitektur-sistem/#22-pilihan-arsitektur-sistem","title":"2.2 Pilihan Arsitektur Sistem","text":"<p>Berikut beberapa arsitektur sistem yang populer saat ini:</p>"},{"location":"arsitektur-prinsip/arsitektur-sistem/#221-monolitik","title":"2.2.1. Monolitik","text":"<p>Arsitektur monolitik merupakan arsitektur klasik dalam pengembangan aplikasi, dimana seluruh aplikasi dikembangkan dalam satu unit kode dasar yang mencakup seluruh fungsionalitas aplikasi. Antarmuka pengguna, logika bisnis, dan lapisan data digabung dalam satu kesatuan aplikasi yang dijalankan. Setiap perubahan atau pembaruan akan mempengaruhi seluruh aplikasi.</p> <p>Kelebihan dari arsitektur monolitik ini adalah :</p> <ol> <li>Mudah dikembangkan dan dideploy sehingga ideal untuk aplikasi kecil atau sederhana dan tim kecil.</li> <li>Biaya lebih rendah karena membutuhkan lebih sedikit sumber daya dan mudah dikelola.</li> <li>Peforma terpusat karena semua bagian jadi satu kesatuan.</li> </ol> <p>Sedangkan untuk kekurangannya:</p> <ol> <li>Kurang fleksibel, dalam hal ini kaitannya saat melakukan perubahan atau peningkatan pada sebagian aplikasi akan berpengaruh pada seluruh aplikasi.</li> <li>Tidak cocok untuk skalabilitas horizontal, skalabilitas terbatas karena biasanya hanya dapat meningkatan kapasitas vertikal dengan meningkatkan spesifikasi server. Bisa horizontal apabila menggunakan load-balancing.</li> <li>Pemeliharaan semakin kompleks seiring pertumbuhan aplikasi. Misalnya untuk menambah atau memperbaiki fitur akan semakin sulit ketika kode menjadi semakin besar dan rumit.</li> </ol> <p>Arsitektur monolitik cocok digunakan pada:</p> <ol> <li>Aplikasi sederhana atau Minimum Viable Product (MVP).</li> <li>Tim kecil dan belum memiliki banyak kebutuhan integrasi eksternal.</li> <li>Aplikasi yang tidak memerlukan skalabilitas tinggi.</li> </ol>"},{"location":"arsitektur-prinsip/arsitektur-sistem/#222-modular-monolitik","title":"2.2.2. Modular Monolitik","text":"<p>Modular monolitik merupakan variasi dari arsitektur monolitik yang mengedepankan pembagian aplikasi menjadi modul-modul terpisah. Setiap modul memiliki tanggung jawab tertentu, namun tetap berada dalam satu kesatuan aplikasi yang besar. Pendekatan ini menggabungkan kelebihan dari modularisasi (memudahkan pemeliharaan dan pengembangan) dengan kesederhanaan implementasi dalam satu aplikasi monolitik.</p> <p>Modular monolitik memiliki kelebihan, diantaranya:</p> <ol> <li>Lebih fleksibel dibandingkan monolitik biasa, karena modul-modul yang berbeda dapat dikembangkan, diuji, dan dikelola secara terpisah.</li> <li>Mudah dideploy dan lebih mudah dikelola dalam hal koordinasi antara tim.</li> <li>Kinerja tetap terpusat dalam satu kesatuan aplikasi.</li> </ol> <p>Adapun untuk kekurangannya:</p> <ol> <li>Meskipun lebih modular, tetap saja aplikasi akan lebih sulit untuk berkembang seiring waktu jika tidak direncanakan dengan baik.</li> <li>Skalabilitas horizontal masih terbatas, karena seluruh aplikasi berjalan dalam satu unit besar.</li> </ol> <p>Modular monolitik digunakan pada:</p> <ol> <li>Aplikasi yang membutuhkan struktur modular namun tidak terlalu kompleks.</li> <li>Tim pengembangan yang relatif kecil namun memiliki pembagian tugas yang jelas.</li> <li>Sistem yang membutuhkan fleksibilitas tanpa kehilangan kesederhanaan dalam pengelolaan.</li> </ol>"},{"location":"arsitektur-prinsip/arsitektur-sistem/#223-microservices","title":"2.2.3. Microservices","text":"<p>Microservice merupakan suatu layanan kecil dan independen, yang dapat dideploy dan diubah tanpa tergantung dengan aplikasi lain. Setiap microservice memiliki tanggung jawab serta fokus pekerjaan tersendiri, dan dapat saling berkomunikasi dengan microservice lain melalui network-call. Kumpulan dari microservices yang saling terhubung ini disebut dengan Microservices Architectures (MSA).</p> <p>Kelebihan dari microservice adalah:</p> <ol> <li>Skalabilitas yang baik</li> <li>Fault Tolerance yang tinggi</li> <li>Pengembangan dan penerapan yang mudah</li> <li>Fleksibilitas</li> <li>Kemudahan pemeliharaan</li> </ol> <p>Adapun untuk kekurangannya adalah sebagai berikut:</p> <ol> <li>Kompleksitas yang tinggi karena banyak komponen yang dikoordinasikan</li> <li>Overhead komunikasi antar microservice dapat mempengaruhi kinerja aplikasi</li> <li>Tantangan debugging</li> <li>membutuhkan keahlian yang lebih tinggi untuk membangun dan mengelila aplikasi microservices</li> </ol>"},{"location":"arsitektur-prinsip/arsitektur-sistem/#224-api-first-atau-headless","title":"2.2.4. API-First atau Headless","text":"<p>API-First adalah sebuah pendekatan dalam pengembangan perangkat lunak yang memprioritaskan pengembangan API (Application Programming Interface) sebelum mengembangkan aplikasi atau antarmuka pengguna. Dalam pendekatan ini, API dianggap sebagai produk utama yang harus dikembangkan terlebih dahulu, kemudian aplikasi atau antarmuka pengguna dibangun di atasnya.</p> <p>Ilustrasi sederhana untuk memahami API-First adalah dengan membandingkannya dengan pembangunan sebuah rumah. Dalam pendekatan tradisional, kita membangun rumah terlebih dahulu, kemudian memasang sistem listrik, air, dan lain-lain. Namun, dalam pendekatan API-First kita membangun sistem listrik, air, dan lain-lain terlebih dahulu baru kemudian membangun rumah di atasnya. Dengan demikian, kita dapat memastikan bahwa sistem yang kita bangun dapat berfungsi dengan baik dan dapat diintegrasikan dengan aplikasi atau antarmuka pengguna yang akan dibangun di atasnya.</p> <p>Keuntungan utama dari pendekatan API-first adalah mempermudah integrasi antar sistem yang berbeda, baik untuk pengembangan aplikasi front-end maupun back-end. Dengan API yang sudah ada sejak awal, pengembang dapat lebih fokus pada fungsionalitas dan keamanan API serta memastikan bahwa berbagai layanan dapat berkomunikasi secara efektif tanpa adanya ketergantungan pada bagian lain dari sistem.</p> <p>Selain itu, API-first juga mendukung pengembangan yang lebih cepat dan lebih efisien. Tim pengembang dapat bekerja secara paralel, tim front-end dapat mengembangkan UI sambil menggunakan API yang sudah didefinisikan sementara tim back-end dapat fokus pada implementasi dan pengelolaan server dan database. Dengan demikian, pendekatan ini meningkatkan kolaborasi antar tim dan mempercepat waktu pengembangan secara keseluruhan.</p>"},{"location":"arsitektur-prinsip/arsitektur-sistem/#225-serverless","title":"2.2.5. Serverless","text":"<p>Arsitektur serverless adalah pendekatan desain software yang memungkinkan developer membangun dan mengelola aplikasi tanpa perlu mengelola arsitektur dasarnya. Aplikasi serverless tetap berjalan di server, tetapi penyedia layanan cloud bertanggung jawab menyediakan, mengelola, dan menskalakan semua infrastruktur cloud tersebut.</p> <p>Bagaimana cara kerja arsitektur serverless?</p> <p>Arsitektur serverless dirancang untuk mengabstraksi server dan pengelola server dari tim pengembangan. \u201cServerless\u201d tidak berarti tanpa server; istilah ini mengacu pada pengalaman pengembangan secara keseluruhan.</p> <p>Developer hanya perlu menulis kode dan menjalankannya tanpa perlu memikirkan apa pun lainnya. Seluruh tugas penyediaan, pemeliharaan hardware, update software dan keamanan server, serta tugas pengelolaan server lainnya ditangani oleh penyedia cloud. Selain itu, arsitektur serverless secara otomatis meningkatkan atau memperkecil skala sesuai dengan traffic.</p> <p>Berikut ini beberapa kasus penggunaan arsitektur serverless yang umum:</p> <ol> <li>Tindakan berbasis pemicu atau menjalankan tugas terjadwal (misalnya laporan harian, pencadangan, logika bisnis, dll.)</li> <li>Membangun API RESTful untuk aplikasi web dan seluler</li> <li>Pemrosesan asinkron (misalnya transcoding video)</li> <li>Otomatisasi proses IT, seperti menghapus akses secara otomatis, memulai pemeriksaan keamanan kepatuhan, atau mengirim persetujuan</li> <li>Mengotomatiskan pipeline continuous integration dan continuous delivery (CI/CD) (misalnya commit kode yang memicu build, permintaan pull yang memicu pengujian otomatis)</li> <li>Berintegrasi dengan API dan layanan pihak ketiga</li> <li>Menjalankan tugas terjadwal (misalnya laporan harian, pencadangan, logika bisnis, dll.)</li> <li>Pemrosesan data real-time untuk data terstruktur dan tidak terstruktur</li> </ol>"},{"location":"arsitektur-prinsip/arsitektur-sistem/#23-modular-monolitik-dengan-api-first-desain","title":"2.3 Modular Monolitik dengan API-first Desain","text":"<p>Di UGM, pendekatan modular monolitik dengan API-first desain dipilih untuk membangun arsitektur sistem yang lebih fleksibel namun tetap sederhana untuk pengelolaan dan pengembangan aplikasi. Pendekatan ini memungkinkan aplikasi dibangun dengan struktur modular yang terpisah namun tetap dalam satu kesatuan monolitik. Setiap modul dapat berinteraksi melalui API, memungkinkan pengembangan dan pemeliharaan yang lebih efisien, serta meningkatkan kemampuan untuk mengintegrasikan sistem eksternal di masa depan.</p> <p>Keunggulan pendekatan ini adalah:</p> <ol> <li>Memungkinkan pengembangan yang lebih terstruktur dan terpisah antar modul.</li> <li>Dapat dengan mudah diintegrasikan dengan sistem lain melalui API, memudahkan kolaborasi antar tim pengembang.</li> <li>Skalabilitas lebih baik karena modul-modul dapat berkembang secara terpisah tanpa merusak seluruh sistem.</li> </ol> <p>Untuk implementasi vNext di UGM, kami telah mengembangkan sistem modular dengan desain API-First yang memanfaatkan API untuk komunikasi antar modul dan layanan. Ini juga mendukung berbagai perangkat dan platform, memastikan pengembangan yang lebih cepat dan kolaborasi yang lebih lancar antara tim front-end dan back-end. Kami juga telah mengimplementasikan sistem API untuk mendukung integrasi yang lebih mudah dengan layanan eksternal dan membangun infrastruktur yang siap untuk pengembangan berkelanjutan.</p>"},{"location":"arsitektur-prinsip/clean-code/","title":"BAB 5 Clean Code","text":"<p>Berikut ini adalah panduan praktik terbaik menulis kode yang bersih dalam membangun sistem informasi di lingkungan UGM.</p>"},{"location":"arsitektur-prinsip/clean-code/#51-menulis-code-yang-bersih","title":"5.1 Menulis code yang bersih","text":"<p>Mengapa harus menulis kode yang bersih?</p> <p>Bayangkan jika mencari sesuatu di ruangan yang berantakan. Pasti akan kesulitan mencari dan tentunya membuang waktu untuk mencarinya. Hal tersebut berlaku demikian dalam pengembangan sistem informasi. Menulis barisan kode secara berantakan akan menyulitkan dalam penelusuran masalah atau memahami logika dari kode tersebut. Dengan kode yang bersih, maka kesulitan tersebut dapat dihindari. Dengan menulis kode yang bersih, programmer juga menghemat waktu programmer lainnya. Berikut adalah tips menulis kode yang bersih.</p>"},{"location":"arsitektur-prinsip/clean-code/#511-gunakan-nama-yang-bermakna","title":"5.1.1 Gunakan Nama yang Bermakna","text":"<p>Saat membuat variable atau fungsi, beri nama yang jelas dan menjelaskan apa yang dilakukan variable atau fungsi tersebut. Ini seperti memberi nama folder di komputer. Misal ketika akan membuat variable jumlah produk. Dari pada memberi nama hanya sebuah huruf a atau b saja, gunakan nama yang lebih jelas misal numberOfProducts.</p> <pre><code>&lt;?php\nvar numberOfUsers = 5;\n</code></pre>"},{"location":"arsitektur-prinsip/clean-code/#512-ikuti-prinsip-tanggung-jawab-tunggal-single-responsibility-principle-srp","title":"5.1.2 Ikuti Prinsip Tanggung Jawab Tunggal (Single Responsibility Principle - SRP)","text":"<p>Sebuah fungsi sebaiknya melakukan satu tugas saja dan dapat melakukannya dengan baik. Ini membuat fungsi lebih mudah dipahami dan diperbaiki jika diperlukan. Seperti memiliki satu alat untuk satu tugas. Misalnya pensil untuk menulis dan gunting untuk memotong.</p> <pre><code>&lt;?php\nfunction addNumbers(int a, int b){\n        return a+b;\n}\n</code></pre> <p>Fungsi <code>addNumbers</code> hanya menjumlahkan dua angka saja, tidak melakukan hal lainnya.</p>"},{"location":"arsitektur-prinsip/clean-code/#513-hindari-komentar-yang-tidak-diperlukan","title":"5.1.3 Hindari komentar yang Tidak Diperlukan","text":"<p>Daripada menambahkan komentar di mana-mana, sebaiknya mencoba untuk menyusun kode yang dapat menjelaskan kode itu sendiri dengan nama yang baik. Gunakan komentar hanya ketika sesuatu yang rumit atau membutuhkan catatan khusus. Terlalu banyak komentar akan membingungkan.</p> <pre><code>&lt;?php\n//Baik: Nama variable sudah jelas, tidak perlu komentar tambahan\nvar userAge = 30;\n\n//Buruk: Nama variable tidak jelas, membutuhkan komentar\nvar a_ = 0;\n</code></pre>"},{"location":"arsitektur-prinsip/clean-code/#514-buat-kode-mudah-dibaca","title":"5.1.4 Buat Kode Mudah Dibaca","text":"<p>Gunakan spasi, indentasi, dan pemisah baris untuk menjaga kode tetap rapi. Seperti menulis paragraf, kode harus dipecah menjadi potongan-potongan kecil agar tidak semuanya berada di satu baris. Kecuali kode yang memang dikecilkan untuk optimasi (minify) misal css dan javascript.</p> <pre><code>&lt;?php\n// Kode Baik\nif (isLoggedIn) {\n    console.log(\"Selamat datang!\");\n} else {\n    console.log(\"Silakan masuk.\");\n}\n\n// Kode Buruk\nif(isLoggedIn){console.log(\"Selamat datang!\");}else{console.log(\"Silakan masuk.\");}\n</code></pre>"},{"location":"arsitektur-prinsip/clean-code/#515-tulis-unit-test","title":"5.1.5 Tulis Unit Test","text":"<p>Unit test adalah pemeriksaan untuk memastikan kode bekerja seperti seharusnya. Ketika kode dirubah, unit test akan memberitahu jika ada kode yang tidak berjalan semestinya.</p> <pre><code>&lt;?php\n//class calculator\n\nclass Calculator\n{\n    public function add(int $a, int $b): int\n    {\n        return $a + $b;\n    }\n\n    public function subtract(int $a, int $b): int\n    {\n        return $a - $b;\n    }\n}\n</code></pre> <pre><code>&lt;?php\n//class unit test untuk class calculator\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass CalculatorTest extends TestCase\n{\n    private Calculator $calculator;\n\n    protected function setUp(): void\n    {\n        $this-&gt;calculator = new Calculator();\n    }\n\n    public function testAdd(): void\n    {\n        $this-&gt;assertEquals(5, $this-&gt;calculator-&gt;add(2, 3));\n        $this-&gt;assertEquals(0, $this-&gt;calculator-&gt;add(-2, 2));\n        $this-&gt;assertEquals(-5, $this-&gt;calculator-&gt;add(-2, -3));\n    }\n\n    public function testSubtract(): void\n    {\n        $this-&gt;assertEquals(1, $this-&gt;calculator-&gt;subtract(3, 2));\n        $this-&gt;assertEquals(-4, $this-&gt;calculator-&gt;subtract(-2, 2));\n        $this-&gt;assertEquals(1, $this-&gt;calculator-&gt;subtract(-2, -3));\n    }\n}\n</code></pre>"},{"location":"arsitektur-prinsip/clean-code/#516-hati-hati-dengan-dependency","title":"5.1.6 Hati-hati dengan Dependency","text":"<p>Saat mengembangkan sistem informasi, usahakan agar setiap bagian tidak terlalu bergantung satu sama lain. Sebagai contoh, mesin cuci piring bisa digunakan di dapur mana saja, bukan hanya dapur tertentu. Jika menggunakan pendekatan ini maka sistem informasi akan mudah dikelola.</p>"},{"location":"arsitektur-prinsip/clean-code/#517-organisasi-proyek-yang-baik","title":"5.1.7 Organisasi Proyek yang Baik","text":"<p>Menjaga file dan folder proyek tetap terorganisir. Seperti menjaga meja tetap rapi. Ini akan mempermudah pencarian ketika proyek semakin besar.</p> <p>Contoh:</p> <ol> <li>Gunakan folder seperti components, services, controller, dan model dalam proyek.</li> <li>Kelompokkan file yang serupa agar mudah dalam pencariannya.</li> </ol>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/","title":"BAB 4 Konsistensi Teknologi","text":"<p>Dalam pengembangan sistem informasi di lingkungan UGM harus menggunakan teknologi yang konsisten untuk menghindari perbedaan teknologi yang digunakan. Ini akan mempermudah proses pengembangan dan perawatan sistem informasi. Berikut adalah teknologi yang direkomendasikan oleh DTI.</p>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/#41-framework-dan-bahasa-pemrograman","title":"4.1 Framework dan Bahasa Pemrograman","text":""},{"location":"arsitektur-prinsip/konsistensi-teknologi/#411-hypertext-preprocessor-php-8","title":"4.1.1 Hypertext Preprocessor (PHP) 8","text":"<p>Saat ini pengembangan sistem informasi di lingkungan UGM menggunakan bahasa Hypertext Preprocessor atau PHP. Pengembangan sistem informasi wajib menggunakan PHP versi 8 atau versi stabil yang terbaru. Berikut beberapa framework yang bisa digunakan dan sudah support PHP 8.</p> <ol> <li>CodeIgniter 3 versi ^3.13    CodeIgniter 3 adalah framework yang paling banyak digunakan. Framework ini sangat direkomendasikan karena sudah banyak sistem informasi yang dikembangkan menggunakan framework ini di lingkungan UGM. Namun wajib diperhatikan harus menggunakan versi 3.13 yang sudah support PHP 8.</li> <li>CodeIgniter 4 versi ^4.5    CodeIgniter 4 masih sangat jarang digunakan di lingkungan UGM. Namun ini adalah pilihan terbaik ke dua karena masih mendekati CodeIgniter 3 dan sudah support PHP 8.</li> <li>Laravel ^11    Laravel 11 juga masih sangat jarang digunakan di lingkungan UGM. Untuk menggunakan framework ini silakan berkonsultasi lebih dulu ke DTI.</li> </ol>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/#412-python-3","title":"4.1.2 Python 3","text":"<p>DTI mulai menggunakan python dalam pengembangan sistem informasi. Python yang digunakan adalah Python versi 3. Bahasa python ini digunakan khusus untuk membuat API dan pengolahan data. Terdapat satu framework yang sangat direkomendasikan untuk mengembangkan API secara cepat dan efisien. Framework tersebut adalah FastAPI. FastAPI memiliki beberapa fitur unggulan dibanding framework lain, diantaranya:</p> <ol> <li>Cepat performa sangat tinggi, setara dengan NodeJS dan Go.</li> <li>Cepat dalam pengembangan.</li> <li>Lebih sedikit bug.</li> <li>Intuitif dengan dukungan editor yang baik, otomatisasi kode dimana-mana dan lebih sedikit waktu untuk debugging.</li> <li>Mudah karena python adalah high-level language yang mendekati bahasa manusia.</li> <li>Ringkas meminimalkan pengulangan kode.</li> <li>Tangguh dengan menghasilkan kode siap produksi.</li> <li>Berbasis standar pengembangan API misal OpenAPI</li> <li>Otomatis bisa menggenerate dokumentasi API dalam bentuk swagger dan redoc.</li> </ol>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/#413-dart","title":"4.1.3 Dart","text":"<p>DTI mulai menggunakan dart untuk membuat aplikasi yang berjalan di berbagai platform (multiplatform). Dart dipilih karena selain multiplatform, dart juga memiliki performa tinggi. Sintaks dart juga mirip dengan C-style (java atau javascript). Dengan menggunakan dart, dapat sekaligus mengembangkan aplikasi yang berjalan di mobile android, ios, website bahkan desktop. Terdapat satu framework yang sangat direkomendasikan DTI yaitu Flutter. Flutter adalah framework yang dirancang untuk membuat antarmuka pengguna yang indah dan cepat di berbagai platform dalam satu basis kode. Flutter memiliki beberapa kelebihan, diantaranya:</p> <ol> <li>Pengembangan multiplatform dalam satu basis kode</li> <li>Kinerja tinggi karena menggunakan mesin rendering sendiri dan dikompilasi ke kode asli.</li> <li>Desain UI yang menarik dan konsisten.</li> <li>Hot reload mempercepat pengembangan.</li> <li>Ekosistem yang berkembang sehingga banyak pustaka dan support dari komunitas.</li> </ol>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/#42-database","title":"4.2 Database","text":"<p>Berikut beberapa database yang direkomendasikan DTI untuk pengembangan sistem informasi di lingkungan UGM.</p>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/#421-mysql-8","title":"4.2.1 MySQL 8","text":"<p>Database mysql adalah open-source sistem manajemen basisdata relasional (RDBMS) yang sangat direkomendasikan DTI. Saat ini pengembangan sistem di lingkungan UGM rata-rata masih menggunakan mysql. Karena itu database ini sangat mudah dipelajari dan sangat cepat untuk pembuatan database. Memang database mysql masih dibawah RDBMS lainnya seperti PostgreSQL. Namun dengan tunning yang baik, kemampuan mysql tidak bisa diragukan dan cukup untuk melayani kebutuhan sistem informasi di UGM. Oleh karena itu database mysql masih sangat direkomendasikan. Selain itu juga wajib menggunakan versi terbaru dari mysql.</p>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/#422-mariadb-11","title":"4.2.2 MariaDB 11","text":"<p>Database mariadb adalah cabang sistem manajemen basis data relasional (RDBMS) MySQL yang dikembangkan oleh komunitas dan dipimpin oleh beberapa pengembang asli MySQL. Mariadb masih mirip seperti mysql karena mempertahankan kompatibilitas tinggi dengan MySQL. Karena mariadb masih mirip dengan mysql, maka dari itu mariadb juga database yang direkomendasikan untuk pengembangan sistem informasi di lingkungan UGM. Apabila akan menggunakannya, maka gunakan mariadb versi terbaru untuk mengembangkan sistem informasi di lingkungan UGM.</p>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/#423-elasticsearch-8","title":"4.2.3 Elasticsearch 8","text":"<p>Elasticsearch adalah database untuk mesin pencarian dan analitik terdistribusi, penyimpanan data yang dapat diskalakan, serta basis data vektor yang dioptimalkan untuk kecepatan dan relevansi pada beban kerja skala produksi. Database ini biasanya digunakan untuk menyimpan kumpulan data besar dan kemudian digunakan untuk melakukan pencarian di data tersebut. Misal dalam sistem informasi yang dikembangkan memiliki jumlah data yang sangat besar dan terdapat fitur pencarian di dalamnya. Maka DTI merekomendasikan penggunaan elasticsearch yang mendampingi RDBMS sebelumnya. Penggunakan elasticsearch ini akan meningkatkan pengalaman pengguna dalam menggunakan sistem informasi. Karena kecepatan dalam melakukan pencarian, pengguna tidak akan menunggu lama ketika melakukan sebuah pencarian. Selain pencarian, elasticsearch juga direkomendasikan untuk penyimpanan log dari sistem informasi. Misal log error dan log akses disimpan di elasticsearch, ini akan memudahkan pengembang dan monitoring sistem dalam pencarian kesalahan sistem. Pastikan untuk menggunakan elasticsearch versi terbaru untuk pengembangan sistem informasi di lingkungan UGM.</p>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/#424-redis","title":"4.2.4 Redis","text":"<p>Redis adalah basis data dalam memori yang tersimpan di dalam disk. Model datanya adalah kunci dan nilai. Redis memiliki banyak jenis nilai yang didukung seperti String, Lists, Sets, Sorted Sets, Hashes, Streams, Hyperlog Logs, Bitmaps. Redis sering difungsikan sebagai database penyimpanan sesi dan penyimpanan cache. Dengan menggunakan redis, maka sesi pengguna akan mudah disimpan dan diambil. Selain itu redis juga bisa difungsikan sebagai database cache. Jika sistem informasi menerapkan mekanisme cache data, maka ini akan mempengaruhi pengalaman pengguna dan mengurangi beban database. Data yang jarang berubah dan diakses oleh banyak user jika disimpan di redis sebagai cache akan sangat cepat diakses oleh pengguna. Hal ini akan meringankan database karena tidak perlu query berkali-kali ke database untuk data yang sama dan tentu akan meningkatkan pengalaman pengguna. Gunakan redis versi terbaru untuk pengembangan sistem informasi di lingkungan UGM.</p>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/#43-git-repository","title":"4.3 Git Repository","text":"<p>Git repository adalah tempat untuk menyimpan dan mengelola kode sumber dalam pengembangan perangkat lunak. Di lingkungan UGM, sistem pengelolaan kode sumber dilakukan menggunakan GitLab Community Editio**n** yang dibedakan menjadi dua repository berdasarkan peruntukannya:</p> <ol> <li>git.dev.ugm.ac.id</li> </ol> <p>Repository ini digunakan pada sistem yang dikembangkan oleh tim internal DTI. Semua proyek yang dikembangkan oleh tim internal, termasuk aplikasi dan sistem informasi yang berkaitan dengan kebutuhan UGM wajib menggunakan repository ini.</p> <ol> <li>put.dev.ugm.ac.id</li> </ol> <p>Repository ini digunakan pada sistem yang dikembangkan oleh pihak luar atau vendor yang bekerja sama dengan DTI. Semua sistem yang melibatkan kolaborasi dengan pihak luar UGM wajib menggunakan repository ini.</p> <p>Penggunaan GitLab Community Edition di lingkungan UGM bertujuan untuk memberikan kontrol yang lebih baik terhadap pengelolaan kode, serta memudahkan kolaborasi antar pengembang dan tim di UGM. Semua sistem yang dikembangkan di lingkungan UGM wajib menggunakan salah satu dari dua repository ini, untuk memastikan konsistensi, keamanan, dan integrasi yang baik antar proyek yang ada.</p>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/#44-docker-container","title":"4.4 Docker Container","text":"<p>Docker adalah platform yang memungkinkan pengembang untuk membuat, mengirim, dan menjalankan aplikasi dalam container. Container adalah wadah yang mengisolasi aplikasi dari sistem operasi, memungkinkan aplikasi berjalan dengan konsisten di berbagai lingkungan. UGM saat ini beralih ke arsitektur berbasis container, yang memungkinkan pengelolaan aplikasi yang lebih efisien dan skalabel. Sistem baru yang dikembangkan di UGM sudah menggunakan pendekatan container-based.</p>"},{"location":"arsitektur-prinsip/konsistensi-teknologi/#45-api-gateway","title":"4.5 API Gateway","text":"<p>API Gateway adalah lapisan yang bertindak sebagai titik masuk untuk semua permintaan API yang diterima oleh sistem. API Gateway mengelola dan mendistribusikan permintaan ke layanan-layanan yang sesuai di belakangnya. Di UGM, kami menggunakan Krakend sebagai API Gateway. Krakend adalah solusi API Gateway yang dirancang untuk menyediakan kecepatan tinggi dan pengelolaan API yang efisien. Dengan Krakend, UGM dapat mengelola banyak API dan layanan dengan mudah, serta meningkatkan performa dan keamanan aplikasi.</p> <p>Krakend memiliki beberapa fitur utama:</p> <ol> <li>Integrasi yang mudah dengan berbagai backend.</li> <li>Skalabilitas tinggi yaitu mampu menangani beban lalu lintas yang besar.</li> <li>Pengelolaan API dengan fitur seperti rate limiting, caching, dan monitoring.</li> </ol>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/","title":"BAB 3 Prinsip Dasar Pengembangan","text":"<p>Dalam pengembangan sistem informasi di lingkungan UGM harus mencangkup beberapa aspek yang memastikan sistem dapat berfungsi dengan baik, efektif, dan mudah dipelihara. Berikut beberapa prinsip dasar yang harus diikuti.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#31-keterlibatan-pengguna-user-involvement","title":"3.1 Keterlibatan Pengguna (User Involvement)","text":"<p>Dalam pengembangan sistem informasi di UGM pengguna akhir harus dilibatkan sejak awal dalam pengembangan. Hal tersebut untuk memastikan sistem memenuhi kebutuhan pengguna dan relevan dengan cara kerja sehari-hari. Keterlibatan pengguna dapat berupa konsultasi, survei atau masukan selama proses pengembangan. Pengguna juga dapat dilibatkan untuk melakukan internal testing terbatas.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#32-kebutuhan-yang-jelas-clear-requirements","title":"3.2 Kebutuhan yang jelas (Clear Requirements)","text":"<p>Kebutuhan sistem harus ditentukan secara spesifik dan jelas sejak awal sebelum pengembangan meliputi fungsi utama, keamanan, performa, serta tampilan dan pengalaman pengguna. Kebutuhan yang jelas membantu mencegah perubahan besar di tengah proses pengembangan. Untuk itu semua pengembangan sistem informasi di lingkungan UGM wajib mengikuti UGM Lean. Terdapat aturan dan langkah-langkah yang wajib diikuti pada UGM Lean sebelum melakukan pengembangan sistem informasi di lingkungan UGM.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#33-keamanan-security","title":"3.3 Keamanan (Security)","text":"<p>Keamanan sangat penting untuk melindungi data pengguna dan sistem dari ancaman kejahatan siber. Sistem informasi yang akan dikembangkan di lingkungan UGM harus menggunakan metode perlindungan data seperti enkripsi, autentikasi, otorisasi, serta pemantauan ancaman untuk mencegah akses tidak sah dan serangan siber.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#34-kinerja-performance","title":"3.4 Kinerja (Performance)","text":"<p>Sistem informasi yang akan di kembangkan di lingkungan UGM harus dirancang agar cepat, responsif, dan tetap stabil, meskipun jumlah pengguna atau data bertambah. Pengujian kinerja seperti load testing dan stress testing wajib dilakukan sebelum sistem diluncurkan. Penting untuk memastikan sistem tidak mudah melambat atau gagal ketika data dan pengguna bertambah banyak.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#35-keandalan-reliability","title":"3.5 Keandalan (Reliability)","text":"<p>Sistem informasi yang akan di kembangkan di lingkungan UGM harus dapat diandalkan dan tetap berfungsi meskipun sedang terjadi masalah. Hal ini bisa dicapai jika melakukan backup, disaster recovery, dan mekanisme failover. Selama pengembangan wajib memastikan keandalan sistem supaya tetap tersedia saat dibutuhkan.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#36-optimisasi-biaya-cost-optimization","title":"3.6 Optimisasi Biaya (Cost Optimization)","text":"<p>Dalam pengembangan dan pemeliharaan sistem informasi di lingkungan UGM harus memperhatikan biaya. Penggunaan sumber daya seperti server, bandwidth, dan penyimpanan harus dioptimalkan agar tidak boros. Mengelola biaya memungkinkan sistem tetap berjalan tanpa menguras anggaran unit kerja secara berlebihan.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#37-keberlanjutan-sustainability","title":"3.7 Keberlanjutan (Sustainability)","text":"<p>Sistem informasi yang akan dikembangkan di lingkungan UGM harus dirancang agar efisien dalam penggunaan sumber daya, hemat biaya, mudah diadaptasi, dan dapat berkembang mengikuti teknologi baru tanpa perlu dibangun ulang. Ini memungkinkan sistem tetap relevan dalam jangka panjang, mendukung pengembangan yang cepat, responsif, dan mengurangi risiko downtime akibat beban berlebih. Dengan pendekatan ini, sistem informasi akan tetap dapat melayani dalam jangka panjang.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#38-keunggulan-operasional-operational-excellence","title":"3.8 Keunggulan Operasional (Operational Excellence)","text":"<p>Proses operasional harus terstruktur dan efisien supaya sistem informasi yang dikembangkan mudah dikelola. Sistem informasi harus mendukung otomatisasi tugas rutin yang tidak perlu dijalankan manual, pemantauan performa secara real-time, dan pengelolaan log yang baik. Dengan keunggulan operasional, sistem informasi yang dikembangkan di lingkungan UGM menjadi lebih mudah diperbaruhi, diperbaiki, dipantau dan memudahkan pengguna.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#39-modularitas-modularity","title":"3.9 Modularitas (Modularity)","text":"<p>Sistem informasi yang dikembangkan di lingkungan UGM sebaiknya dirancang dalam modul-modul yang dapat berdiri sendiri tetapi saling terintegrasi. Modularitas memudahkan pemeliharaan, pembaruan, dan pengembangan lebih lanjut karena setipa bagian dapat diubah tanpa mengganggu bagian lainnya.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#310-dokumentasi-documentation","title":"3.10 Dokumentasi (Documentation)","text":"<p>Dokumentasi sangat penting pada pengembangan sistem informasi di lingkungan UGM. Dokumentasi membantu pengguna dan pengembang lain memahami cara kerja dan pemeliharaan sistem. Dokumentasi pengguna berupa panduan tahapan yang diperuntukkan bagi pengguna, termasuk didalamnya mencakup cara mengoperasikan dan memanfaatkan fitur-fitur yang disediakan sistem secara efektif. Sementara itu, dokumentasi kode dapat menjelaskan struktur dan logika kode untuk memudahkan pengembang lain dalam membaca, memperbaiki, atau menambahkan fitur baru tanpa mengubah sistem secara berlebihan. Dokumentasi yang baik wajib disusun, hal tersebut bisa digunakan untuk membantu dan memastikan sistem informasi yang dikembangkan di lingkungan UGM lebih mudah dioperasikan, diperbaruhi, dan diperbaiki dalam jangka panjang.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#311-pengujian-testing","title":"3.11 Pengujian (Testing)","text":"<p>Dalam pengembangan sistem informasi di lingkungan UGM, sistem harus diuji secara menyeluruh untuk memastikan fungsi berjalan sesuai spesifikasi dan tidak ditemukan bug atau error yang mengganggu pengalaman pengguna. Pengujian mencakup uji fungsi, uji keamanan, dan uji ketahanan. Pengujian tersebut digunakan untuk memastikan sistem siap digunakan.</p>"},{"location":"arsitektur-prinsip/prinsip-dasar-pengembangan/#312-iterasi-dan-adaptasi-iteration-and-adaptation","title":"3.12 Iterasi dan Adaptasi (Iteration and Adaptation)","text":"<p>Pengembangan sistem informasi di lingkungan UGM perlu bersifat adaptif dan iteratif. Terutama untuk menanggapi kebutuhan yang berubah sangat cepat di lingkungan UGM. Pendekatan ini memungkinkan tim pengembang memperbaruhi atau menambahkan fitur secara berkala, sesuai kebutuhan pengguna dan perubahan teknologi.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"database/aturan-data-transaksi-referensi/","title":"Transaksi & Referensi","text":""},{"location":"database/aturan-data-transaksi-referensi/#96-aturan-data-transaksional-dan-referensi","title":"9.6 Aturan Data Transaksional dan Referensi","text":"<ol> <li>Data Transaksional: Diawali subjek sesuai fungsi.<ul> <li>Contoh: <code>staff_pelatihan</code>, <code>student_riwayat</code></li> </ul> </li> <li>Data Referensi Khusus Satu Fungsi: Subjek + Penjelas + Sufiks <code>_ref</code>.<ul> <li>Contoh: <code>pelatihan_jenis_ref</code>, <code>kegiatan_tipe_ref</code></li> </ul> </li> <li>Data Referensi Khusus Banyak Fungsi: Format serupa.<ul> <li>Contoh: <code>agama_ref</code>, <code>pendidikan_ref</code></li> </ul> </li> </ol>"},{"location":"database/aturan-data-transaksi-referensi/#97-penamaan-model-parent-child","title":"9.7 Penamaan Model Parent-Child","text":"<p>Untuk data dengan relasi parent dan child, gunakan format:</p> <ul> <li>Parent: <code>[nama_tabel]_id</code></li> <li>Child: <code>[nama_tabel]_parent_id</code>Contoh:</li> <li><code>riwayat_id</code> (parent)</li> <li><code>riwayat_parent_id</code> (child)</li> </ul>"},{"location":"database/aturan-data-transaksi-referensi/#98-konvensi-penamaan-dataset","title":"9.8 Konvensi Penamaan Dataset","text":"<ol> <li>Nama Tabel: Diawali dengan prefiks klaster (<code>stud_</code>, <code>staff_</code>, <code>fin_</code>).</li> <li>Nama Dataset:<ul> <li>Awalan <code>dataset_</code></li> <li>Diikuti klaster</li> <li>Contoh: <code>dataset_student_registrasi</code></li> </ul> </li> <li>Nama Field: Menyesuaikan data asal.<ul> <li>Contoh: <code>stud_niu</code>, <code>stud_nama</code></li> </ul> </li> <li>Field Baru untuk Pengelompokan: Tambahkan prefix dari field referensi.<ul> <li>Contoh: Jika ada <code>provinsi_nama</code> \u2192 tambahkan <code>provinsi_regional</code>.</li> </ul> </li> <li>Aliran Data di Dataset: Searah.</li> <li>Label Field: Menggunakan huruf kapital maksimal 30 karakter.</li> <li>Konten Data: Tidak diizinkan <code>NULL</code>; jika kosong diganti dengan <code>N/A</code>.</li> <li>Tipe Data: Untuk field bertipe tanggal yang isinya bisa kosong \u2192 gunakan <code>VARCHAR</code>.<ul> <li>Contoh: <code>tanggal_lulus</code></li> </ul> </li> </ol>"},{"location":"database/aturan-data-transaksi-referensi/#99-konvensi-dataset","title":"9.9 Konvensi Dataset","text":"<ol> <li>Nama tabel diawali dengan prefix klaster (e.g., <code>stud_</code>, <code>staff_</code>, <code>fin_</code>).</li> <li>Nama dataset:<ul> <li>Awalan <code>dataset_</code>.</li> <li>Diikuti nama klaster.</li> <li>Contoh: <code>dataset_student_registrasi</code>.</li> </ul> </li> <li>Nama field mengikuti data asal.<ul> <li>Contoh: <code>stud_niu</code>, <code>stud_nama</code>.</li> </ul> </li> <li>Hindari nilai <code>NULL</code> di dataset. Jika kosong, gunakan <code>N/A</code>.</li> <li>Jika tipe data memungkinkan null, gunakan tipe <code>varchar</code>.</li> </ol>"},{"location":"database/aturan-data-transaksi-referensi/#contoh-penulisan-data-transaksional","title":"Contoh Penulisan Data Transaksional","text":"<ul> <li><code>staff_kegiatan_no_sk</code></li> <li><code>stud_tgl_lahir</code></li> </ul>"},{"location":"database/aturan-data-transaksi-referensi/#910-data-referensi","title":"9.10 Data Referensi","text":"<ol> <li>Awali dengan subjek diikuti penjelas dan suffix <code>_ref</code>.<ul> <li>Contoh: <code>agama_ref</code>, <code>pendidikan_ref</code>.</li> </ul> </li> <li>Untuk model parent-child, tambahkan <code>parent_id</code>.<ul> <li>Contoh: <code>riwayat_id</code> (parent), <code>riwayat_parent_id</code> (child).</li> </ul> </li> </ol>"},{"location":"database/database-staff-student/","title":"9.4 Tambahan Database Staff","text":"<ol> <li>Data Transaksional: Menggunakan tabel dengan prefiks <code>staff_</code>.<ul> <li>Contoh: <code>staff_kegiatan</code></li> </ul> </li> <li>Data Referensi: Menggunakan format <code>[nama_tabel]_ref</code>.<ul> <li>Contoh: <code>staff_golongan_ref</code></li> </ul> </li> </ol> <p>Catatan: Tabel yang sudah ada bertahap diubah sesuai konvensi dengan koordinasi terlebih dahulu.</p>"},{"location":"database/database-staff-student/#95-tambahan-database-student","title":"9.5 Tambahan Database Student","text":"<ol> <li>Nama Tabel dan Database: Menggunakan awalan <code>student_</code>.</li> <li>Kolom:<ul> <li>Jika disingkat:<ul> <li><code>Student</code> \u2192 <code>stud</code></li> <li><code>Nomor</code> \u2192 <code>no</code></li> <li><code>Tanggal</code> \u2192 <code>tgl</code></li> <li><code>Program Studi</code> \u2192 <code>prodi</code></li> </ul> </li> </ul> </li> <li>Contoh Penulisan:<ul> <li><code>staff_kegiatan_no_sk</code></li> <li><code>stud_tgl_lahir</code></li> <li><code>staff_pasangan_no_sk</code></li> <li><code>staff_pasangan_no_telepon_tetangga</code></li> <li><code>staff_pasangan_tgl_cerai</code></li> </ul> </li> </ol> <p>Catatan: Kata umum seperti Indonesia tidak perlu disingkat.</p> <ul> <li>Contoh:<ul> <li>Nama Fakultas \u2192 <code>fakultas_cetak</code> (versi Indonesia)</li> <li>Nama Fakultas \u2192 <code>fakultas_cetak_english</code> (versi Inggris)</li> </ul> </li> </ul>"},{"location":"database/intro/","title":"BAB 9 DATABASE","text":"<p>Berikut ini adalah pedoman pembuatan dan penamaan database beserta field di dalamnya. Pedoman ini adalah pedoman lama yang dibuat sejak tahun 2020 oleh Tim Data DTI UGM. Dikarenakan sudah banyak perubahan, panduan ini bersifat sementara dan akan tidak berlaku dalam waktu dekat. Saat ini sedang dibahas konvensi database yang baru. Namun karena masih berprogress, untuk sementara konvensi lama ini masih bisa digunakan.</p>"},{"location":"database/penamaan-db/","title":"9.1 Penamaan Basis Data","text":""},{"location":"database/penamaan-db/#911-klaster","title":"9.1.1 Klaster","text":"<p>Penamaan basis data berdasarkan klaster:</p> <ul> <li>Student: <code>student_[nama basis data]</code></li> <li>Finance: <code>fin_[nama basis data]</code></li> <li>Staff: <code>staff_[nama basis data]</code></li> </ul> <p>Contoh:</p> <ul> <li><code>staff_rekrutmen</code></li> <li><code>student_sia</code></li> <li><code>fin_pajak</code></li> </ul>"},{"location":"database/penamaan-db/#912-aplikasi-simaster","title":"9.1.2 Aplikasi SIMASTER","text":"<p>Penulisan dengan awalan <code>simaster</code> diikuti nama basis data:</p> <ul> <li>Format: <code>simaster_[nama basis data]</code></li> <li>Contoh: <code>simaster_surat</code></li> </ul>"},{"location":"database/penamaan-db/#913-master-deprecated","title":"9.1.3 Master (Deprecated)","text":"<p>Penulisan dengan awalan <code>master</code> diikuti nama klaster:</p> <ul> <li>Format: <code>master_[nama klaster]</code></li> <li>Contoh: <code>master_staff</code></li> </ul>"},{"location":"database/penamaan-db/#914-aplikasi-non-simaster-deprecated","title":"9.1.4 Aplikasi Non-SIMASTER (Deprecated)","text":"<p>Penulisan dengan awalan <code>ugm</code> diikuti nama basis data:</p> <ul> <li>Format: <code>ugm_[nama basis data]</code></li> <li>Contoh: <code>ugm_email</code></li> </ul>"},{"location":"database/penamaan-db/#915-aplikasi-dengan-pihak-luar","title":"9.1.5 Aplikasi dengan Pihak Luar","text":"<p>Penulisan dengan awalan <code>mitra</code> diikuti nama basis data:</p> <ul> <li>Format: <code>mitra_[nama basis data]</code></li> <li>Contoh: <code>mitra_portal</code></li> </ul>"},{"location":"database/penamaan-db/#catatan","title":"Catatan:","text":"<ol> <li>Dilarang menggunakan nama unit kerja setelah awalan.</li> <li>Gunakan Bahasa Indonesia sesuai EYD.</li> </ol>"},{"location":"database/penamaan-field/","title":"9.3 Penamaan Field","text":""},{"location":"database/penamaan-field/#931-aturan-penamaan","title":"9.3.1 Aturan Penamaan","text":"<ol> <li>Nama field diawali dengan nama tabel tanpa akhiran.<ul> <li>Contoh:<ul> <li>Nama tabel: <code>mahasiswa</code></li> <li>Nama field: <code>mahasiswa_id</code>, <code>mahasiswa_nama</code></li> </ul> </li> </ul> </li> <li>Menggunakan huruf kecil (lower case).</li> <li>Jika ada lebih dari satu referensi dalam satu tabel, gunakan label (ekstensi) tambahan.<ul> <li>Contoh: <code>kab_id_lahir</code>, <code>kab_id_alamat</code></li> </ul> </li> <li>Jika lebih dari dua kata, gunakan underscore (<code>_</code>) atau snake case.<ul> <li>Contoh: <code>jadwal_kuliah</code>, <code>dosen_nama</code></li> </ul> </li> <li>Panjang maksimal nama field adalah 30 karakter (koordinasi dengan Tim Analisis Data jika melebihi).</li> <li>Gunakan Bahasa Indonesia sesuai EYD.</li> <li>Tipe data boolean menggunakan <code>tinyint(1)</code> dengan nilai <code>0</code> (tidak) dan <code>1</code> (ya).<ul> <li>Contoh:<ul> <li><code>is_admin</code></li> <li><code>is_aktif</code></li> </ul> </li> </ul> </li> </ol> No Nama Field No Nama Field No Nama Field 1 <code>is_admin</code> 11 <code>is_kirim</code> 21 <code>is_refresh</code> 2 <code>is_agenda</code> 12 <code>is_lock</code> 22 <code>is_sync</code> 3 <code>is_aktif</code> 13 <code>is_notif</code> 23 <code>is_tampil</code> 4 <code>is_approve</code> 14 <code>is_paraf</code> 24 <code>is_tim</code> 5 <code>is_default</code> 15 <code>is_pdf</code> 25 <code>is_ttd</code> 6 <code>is_delete</code> 16 <code>is_private</code> 26 <code>is_ugm</code> 7 <code>is_disposisi</code> 17 <code>is_proses</code> 27 <code>is_update</code> 8 <code>is_favorit</code> 18 <code>is_public</code> 28 <code>is_use</code> 9 <code>is_finish</code> 19 <code>is_publish</code> 29 <code>is_valid</code> 10 <code>is_image</code> 20 <code>is_post</code> 30 <code>is_verified</code> <ol> <li>Wajib menyertakan komentar (comment) untuk field.</li> <li>Isian default tergantung kebutuhan.</li> </ol>"},{"location":"database/penamaan-field/#932-field-wajib-pada-tabel","title":"9.3.2 Field Wajib pada Tabel","text":"<ol> <li><code>created_by</code> (varchar(50))</li> <li><code>created_time</code> (datetime)</li> <li><code>updated_by</code> (varchar(50))</li> <li><code>updated_time</code> (datetime)</li> <li><code>timestamp_server</code> (timestamp) dengan default <code>current_timestamp</code></li> </ol> <p>Contoh penulisan nama field umum digunakan:</p> No Nama Panjang Singkatan 1 mahasiswa mhs (deprecated) 2 program studi prodi 3 mata kuliah mk 4 staff staff 5 dosen dosen 6 tenaga kependidikan tendik 7 indonesia ind 8 inggris eng 9 fakultas fak 10 biodata biodata 11 akademik akd 12 universitas univ 13 registrasi reg 14 kabupaten kab 15 kecamatan kec 16 kelurahan kel 17 provinsi prov 18 tanggal ... tgl_ 19 evaluasi dosen eval_dosen 20 deskripsi deskripsi 21 keterangan keterangan 22 semester semester 23 periode periode 24 sesi sesi 25 jenjang jenjang 26 status status 27 jenis jenis 28 jenis kelamin jenis_kelamin 29 tanggal lahir tgl_lahir 30 kategori kategori 31 kategori kategori 32 tipe tipe 33 kelompok kelompok 34 grup grup 35 jadwal kuliah jadwal_kuliah 36 jadwal ujian jadwal_ujian 37 unit kerja unit_kerja 38 satuan kerja satker 39 nomor telepon no_telp 40 nomor handphone no_hp 41 nomor rumah no_rumah 42 nomor kantor no_kantor 43 nomor rekening no_rekening 44 informasi info 45 tanda tangan ttd 46 nomor peserta no_peserta 47 tes ujian 48 exam ujian 49 orang tua ortu 50 ujian terbuka ujian_terbuka 51 tugas akhir tugas_akhir 52 tahun anggaran thn_anggaran 53 bulan ... bln_... (default tidak disingkat) 54 tahun ... thn_... (default tidak disingkat) 55 angkatan angkatan 56 jumlah jml 57 laporan ... lap_... 58 pembayaran pembayaran 59 tagihan tagihan 60 pembayaran tagihan pembayaran_tagihan"},{"location":"database/penamaan-field/#933-penamaan-field-berkas","title":"9.3.3 Penamaan Field Berkas","text":"<ol> <li>Nama field untuk menyimpan berkas mengikuti pola berikut:<ul> <li><code>[nama tabel]_file_fullpath</code></li> <li><code>[nama tabel]_file_filename</code></li> <li><code>[nama tabel]_file_path</code></li> </ul> </li> <li>Contoh:<ul> <li><code>staff_kp_sk_fullpath</code></li> <li><code>staff_rekening_file_filename</code></li> <li><code>staff_kgb_sk_file_fullpath</code></li> </ul> </li> </ol>"},{"location":"database/penamaan-field/#934-field-mapping-dari-database-lain","title":"9.3.4 Field Mapping dari Database Lain","text":"<ol> <li>Gunakan nama database asal sebagai prefix.<ul> <li>Format: <code>[nama_database_asal]_[nama_field_asal]</code></li> <li>Contoh: <code>ugm_hris_pkrjnId</code></li> </ul> </li> <li>Tambahkan komentar berisi referensi asal field.<ul> <li>Contoh: \"ugm_hris.pub_ref_pekerjaan\"</li> </ul> </li> </ol>"},{"location":"database/penamaan-field/#catatan-tambahan","title":"Catatan Tambahan","text":"<ol> <li>Nama kolom untuk akun UGM cukup dengan <code>username</code>.</li> <li>Untuk akun lain, tambahkan penjelas pada nama field.<ul> <li>Contoh: <code>mitra_instagram_username</code></li> </ul> </li> </ol>"},{"location":"database/penamaan-field/#penamaan-index-dan-foreign-key","title":"Penamaan Index dan Foreign Key","text":"<ul> <li>Sesuaikan dengan standar penamaan pada aplikasi SQLyog atau kebutuhan lain.</li> </ul>"},{"location":"database/penamaan-field/#935-tabel-referensi-utama","title":"9.3.5 Tabel Referensi Utama","text":"<ul> <li> <p><code>master.student_master</code>:</p> <p>Tabel ini digunakan sebagai data pokok bersama dengan tim lain (aplikasi lain).</p> <ul> <li>Contoh penggunaan:<ul> <li>Forlap: <code>id_reg_pd</code>, <code>nipd</code></li> <li>Sister: <code>ankt_mhs</code></li> <li>Tracer: <code>tracer_mhs_id</code></li> </ul> </li> <li>Jika ada penambahan/pengurangan field, harus didiskusikan terlebih dahulu dengan tim terkait.</li> <li><code>master_student.student_detail</code>:</li> </ul> <p>Digunakan untuk kebutuhan klaster student seperti STATUS mhs (keluar) dan tanggal keluar.</p> </li> </ul>"},{"location":"database/penamaan-field/#936-field-dari-aplikasi-lain","title":"9.3.6 Field dari Aplikasi Lain","text":"<p>Field yang berasal dari aplikasi eksternal diberikan prefiks nama aplikasi asal.</p> <p>Contoh:</p> <ul> <li>Forlap/PDDIKTI: <code>forlap_</code><ul> <li>Contoh: <code>forlap_nipd</code>, <code>forlap_id_sms</code></li> </ul> </li> <li>SISTER: <code>sister_</code><ul> <li>Contoh: <code>sister_sdm</code></li> </ul> </li> </ul>"},{"location":"database/penamaan-field/#937penggunaan-field-is_","title":"9.3.7Penggunaan Field <code>is_</code>","text":"<p>Field dengan awalan <code>is_</code> menggunakan tipe data <code>TINYINT(1)</code> dengan tanda/flag <code>unsigned</code>.</p> <ul> <li>Contoh: <code>is_aktif</code> (<code>0: tidak aktif</code>, <code>1: aktif</code>).</li> </ul>"},{"location":"database/penamaan-field/#938-pengambilanmigrasi-data-dari-aplikasi-lain","title":"9.3.8 Pengambilan/Migrasi Data dari Aplikasi Lain","text":"<ol> <li>Jika data diambil secara penuh (terdapat relasi di dalamnya):<ul> <li>Nama database mengikuti database asal ditambah suffix <code>_public</code>.</li> <li>Contoh: <code>sister_public_pdrd</code></li> </ul> </li> <li>Jika data diambil tanpa relasi:<ul> <li>Nama database ditambah suffix <code>_public_data</code>.</li> <li>Contoh: <code>sister_public_pdrd_data</code></li> </ul> </li> </ol>"},{"location":"database/penamaan-field/#939-prefiks-penamaan-database","title":"9.3.9 Prefiks Penamaan Database","text":"<ol> <li><code>simaster_</code>: Digunakan untuk database yang digunakan di semua klaster.<ul> <li>Contoh: <code>simaster_survey</code>, <code>simaster_presensi</code></li> </ul> </li> <li><code>master_</code>: Digunakan hanya untuk referensi di klaster tertentu.<ul> <li>Contoh: <code>master_staff</code>, <code>master_student</code>, <code>master_finance</code></li> </ul> </li> </ol>"},{"location":"database/penamaan-field/#catatan-khusus","title":"Catatan Khusus","text":"<ol> <li>Database <code>event</code> \u2192 seharusnya: <code>simaster_event</code></li> <li>Database <code>grafik_dashboard</code> \u2192 seharusnya: <code>simaster_statistik_grafik</code></li> <li>Database yang sudah ada diubah secara bertahap sesuai konvensi dengan koordinasi terlebih dahulu.</li> </ol>"},{"location":"database/penamaan-table-view-dll/","title":"9.2 Penamaan Tabel, View, Procedure, Function, Trigger, dan Event","text":""},{"location":"database/penamaan-table-view-dll/#921-tabel","title":"9.2.1 Tabel","text":"<ol> <li>Penyesuaian nama tabel:<ul> <li>Tabel referensi diakhiri dengan <code>_ref</code>. Contoh: <code>agama_ref</code>.</li> <li>Tidak boleh ada tabel dan referensi dengan nama yang sama dalam satu basis data. Contoh: tidak diizinkan ada table <code>pembayaran</code> dan <code>pembayaran_ref</code> dalam satu database.</li> <li>Jika lebih dari satu kata, gunakan underscore (<code>_</code>) snake case dan huruf kecil. Contoh: <code>tipe_user_ref</code>.</li> <li>Panjang maksimal nama tabel adalah 30 karakter (koordinasi dengan Tim Analisis Data jika melebihi).</li> </ul> </li> <li>Penulisan tabel backup/cadangan:<ul> <li>Format: <code>zz_[nama tabel]_[waktu]</code></li> <li>Contoh: <code>zz_dosen_20200312</code></li> </ul> </li> <li>Penulisan tabel sementara (temporary):<ul> <li>Format: <code>_[nama tabel]</code></li> <li>Contoh: <code>_mahasiswa</code></li> </ul> </li> <li>Penulisan tabel log:<ul> <li>Format: <code>[nama tabel]_log</code></li> <li>Contoh: <code>krs_log</code></li> </ul> </li> </ol>"},{"location":"database/penamaan-table-view-dll/#catatan","title":"Catatan:","text":"<ul> <li>Audit dilakukan setiap tahun. Tabel tidak diperlukan akan dihapus.</li> <li>Retensi data tabel log selama 3 bulan, setelah itu dipindahkan ke basis data tampungan.</li> </ul>"},{"location":"database/penamaan-table-view-dll/#922-view","title":"9.2.2 View","text":"<p>Penulisan dengan awalan <code>v_</code>:</p> <ul> <li>Format: <code>v_[nama view]</code></li> <li>Contoh: <code>v_mahasiswa</code></li> </ul>"},{"location":"database/penamaan-table-view-dll/#923-procedure","title":"9.2.3 Procedure","text":"<p>Penulisan dengan awalan <code>p_</code>:</p> <ul> <li>Format: <code>p_[nama procedure]</code></li> <li>Contoh: <code>p_pembayaran</code></li> </ul>"},{"location":"database/penamaan-table-view-dll/#924-function","title":"9.2.4 Function","text":"<p>Penulisan dengan awalan <code>f_</code>:</p> <ul> <li>Format: <code>f_[nama function]</code></li> <li>Contoh: <code>f_krs</code></li> </ul>"},{"location":"database/penamaan-table-view-dll/#924-event","title":"9.2.4 Event","text":"<p>Penulisan dengan awalan <code>e_</code>:</p> <ul> <li>Format: <code>e_[nama event]</code></li> <li>Contoh: <code>e_krs</code></li> </ul>"},{"location":"database/penamaan-table-view-dll/#925-trigger","title":"9.2.5 Trigger","text":"<p>Penulisan dengan awalan <code>t_</code>:</p> <ul> <li>Format: <code>t_before|after_insert|update|delete_[nama tabel]</code></li> <li>Contoh:<ul> <li><code>t_before_kelas</code></li> <li><code>t_after_insert_kelas</code></li> <li><code>t_update_kelas</code></li> </ul> </li> </ul>"},{"location":"devops/devops/","title":"DevOps","text":"<p>DevOps adalah seperangkat praktik, budaya, dan filosofi yang mengotomatiskan dan mengintegrasikan proses antara tim pengembangan perangkat lunak (Development) dan tim operasi TI (Operations).</p> <p>Tujuannya adalah untuk mempersingkat siklus pengembangan perangkat lunak dan menyediakan continuous delivery dengan kualitas tinggi, sambil meningkatkan kolaborasi dan komunikasi antar tim. </p> <p>DevOps bukan hanya tentang penggunaan alat, tetapi juga tentang perubahan budaya dan pola pikir. Implementasi DevOps yang sukses membutuhkan komitmen dari semua tim yang terlibat dan adaptasi terhadap praktik-praktik baru.</p>"},{"location":"devops/devops/#111-prinsip-prinsip-utama-devops","title":"11.1 Prinsip-Prinsip Utama DevOps","text":"<ul> <li>Kolaborasi dan Komunikasi: DevOps menekankan pada kolaborasi yang erat antara tim pengembangan, operasi, keamanan, dan tim lainnya yang terlibat dalam siklus hidup perangkat lunak. Komunikasi yang efektif dan transparan sangat penting untuk menghindari silo dan miskomunikasi.</li> <li>Otomatisasi: Otomatisasi adalah inti dari DevOps. Ini mencakup otomatisasi build, pengujian, deployment, dan monitoring. Otomatisasi mengurangi kesalahan manusia, mempercepat proses, dan memungkinkan feedback yang lebih cepat.</li> <li>Continuous Integration (CI): CI adalah praktik pengintegrasian kode secara teratur ke dalam repositori bersama. Setiap integrasi diverifikasi dengan automated build dan pengujian.</li> <li>Continuous Delivery (CD): CD memperluas CI dengan mengotomatiskan proses release dan deployment sehingga perangkat lunak dapat dirilis ke lingkungan produksi kapan saja.</li> <li>Monitoring dan Logging: Pemantauan dan pencatatan yang komprehensif sangat penting untuk memahami kinerja aplikasi dan infrastruktur, mendeteksi masalah dengan cepat, dan memberikan feedback untuk perbaikan.</li> <li>Feedback Loop (Umpan Balik): DevOps mendorong feedback loop yang cepat antara tim pengembangan dan operasi, serta dengan pengguna. Ini memungkinkan perbaikan dan peningkatan berkelanjutan.</li> </ul>"},{"location":"devops/devops/#112-praktik-praktik-utama-devops","title":"11.2 Praktik-Praktik Utama DevOps","text":"<ul> <li>Continuous Integration (CI)<ul> <li>Pengembang melakukan commit kode secara teratur.</li> <li>Sistem CI otomatis membangun aplikasi dan menjalankan pengujian, baik itu uji fungsi maupun uji keamanan.</li> <li>Feedback cepat diberikan kepada pengembang jika ada kesalahan.</li> </ul> </li> <li>Continuous Delivery (CD)<ul> <li>Otomatisasi deployment ke berbagai lingkungan (pengembangan, pengujian, staging, produksi).</li> <li>Penggunaan pipeline CD untuk mengelola alur release.</li> <li>Strategi deployment seperti blue/green deployment atau canary releases.</li> </ul> </li> <li>Monitoring dan Logging<ul> <li>Penggunaan alat monitoring seperti Prometheus, Grafana, atau Kibana untuk memantau kinerja aplikasi dan infrastruktur.</li> <li>Penggunaan logging terpusat untuk menganalisis log dan mendeteksi masalah.</li> </ul> </li> <li>Collaboration and Communication Tools<ul> <li>Penggunaan tools seperti Slack atau Microsoft Teams untuk memfasilitasi kolaborasi dan komunikasi antar tim.</li> </ul> </li> </ul>"},{"location":"devops/devops/#113-alur-kerja-cicd","title":"11.3 Alur Kerja CI/CD","text":"<ol> <li>Pengembang Melakukan Commit Kode ke GitLab<ul> <li>Pengembang melakukan perubahan kode dan melakukan commit serta push ke branch yang relevan di GitLab (misalnya, branch develop untuk development atau branch main/master untuk production).</li> </ul> </li> <li>GitLab CI Menjalankan Pipeline CI<ul> <li>Setiap push ke GitLab akan memicu pipeline CI yang didefinisikan dalam berkas <code>.gitlab-ci.yml</code> di root repositori.</li> <li> <p>Contoh <code>.gitlab-ci.yml</code> sederhana:</p> <pre><code>stages:\n  - build\n  - test\n  - call_portainer\n\nbuild_image_develop:\n  stage: build\n  image:\n    name: gcr.io/kaniko-project/executor:v1.23.2-debug\n    entrypoint: [\"\"]\n  tags:\n    - gitdev-runner\n  before_script:\n    - echo \"{\\\"auths\\\":{\\\"${HARBOR_HOST}\\\":{\\\"auth\\\":\\\"$(printf \"%s:%s\" \"${HARBOR_USERNAME}\" \"${HARBOR_PASSWORD}\" | base64 | tr -d '\\n')\\\"}}}\" &gt; /kaniko/.docker/config.json\n  script:\n    - /kaniko/executor\n      --context \"${CI_PROJECT_DIR}\"\n      --dockerfile \"${CI_PROJECT_DIR}/Dockerfile\"\n      --destination \"${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_NAME}:${CI_COMMIT_TAG}\"\n  rules:\n     - if : '$CI_COMMIT_BRANCH == \"develop\"'\n       changes:\n         - Dockerfile\n         - CHANGELOG.md\n\ntest-job:\n  stage: test\n  image: $HARBOR_HOST}/$HARBOR_PROJECT/$CI_PROJECT_NAME:$CI_COMMIT_TAG\n  script:\n    - # perintah pengujian, contoh: pytest\n\ncall_portainer_develop:\n  image: hub.ugm.id/proxy/alpine:latest\n  stage: call_portainer\n  tags:\n    - gitdev-runner\n  rules:\n     - if : '$CI_COMMIT_BRANCH == \"develop\"'\n       changes: \n         - docker-compose.*\n         - Dockerfile\n         - CHANGELOG.md\n  script:\n    - apk add --no-cache curl\n    - curl -X POST $PORTAINER_WEBHOOK_DEVELOP\n</code></pre> <p>Penjelasan konfigurasi:</p> <ul> <li><code>stages</code> : Mendefinisikan tahap-tahap pipeline (build, test, deploy).</li> <li><code>image</code> : Mendefinisikan image Docker yang akan digunakan untuk job.</li> <li><code>tags</code> :  Dalam contoh ini, digunakan untuk memilih gitlab runner</li> <li><code>before_script</code>: Perintah yang dijalankan sebelum setiap job. Contoh di atas melakukan login ke registry Docker.</li> <li><code>rules</code> : Memberikan kondisi yang harus terpenuhi untuk job dijalankan</li> <li><code>script</code> : Perintah yang akan dijalankan dalam job.</li> <li>Membangun Aplikasi dan Membuat Image Docker<ul> <li>Job build menggunakan image <code>gcr.io/kaniko-project/executor</code> dan menjalankan perintah build untuk membangun image Docker berdasarkan <code>Dockerfile</code> di repositori.</li> <li>Image yang dibangun diberi tag dengan <code>${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_NAME}:${CI_COMMIT_TAG}</code> agar mudah diidentifikasi dan di kelola, dan di push ke Harbor Registry.</li> </ul> </li> <li>Menjalankan Pengujian<ul> <li>Job test menggunakan image yang baru dibangun dan menjalankan pengujian yang sesuai (misalnya, unit test, integration test).</li> </ul> </li> <li>Upload Image ke Harbor Registry<ul> <li>Job build melakukan push image Docker yang berhasil dibangun ke Harbor Registry. Kredensial registri disimpan sebagai variabel CI/CD di GitLab atau dengan Harbor integration.</li> </ul> </li> <li>GitLab CI Mengirim Webhook ke Portainer<ul> <li>Job deploy akan mengirim webhook ke Portainer setelah tahap build dan test selesai.</li> </ul> </li> <li>Portainer Melakukan Deployment Image Docker Baru ke Environment yang Dituju<ul> <li>Portainer dikonfigurasi untuk menerima webhook dan menjalankan deployment.</li> <li>Perlu dibuatkan stack atau container terlebih dahulu di Portainer. Konfigurasi webhook di Portainer akan merujuk ke stack atau container ini dan memperbarui image yang digunakan.</li> <li>Pastikan konfigurasi network dan mapping port sudah sesuai agar aplikasi dapat diakses.</li> </ul> </li> <li>Memantau Aplikasi dan Infrastruktur<ul> <li>Menggunakan Grafana + Loki ataupun ELK Stack untuk menampilkan data metric penggunaan resouce infrastruktur, juga untuk menampilkan log aplikasi yang telah ter-deploy</li> </ul> </li> <li>Umpan Balik dari Monitoring dan Logging Digunakan untuk Perbaikan dan Peningkatan:<ul> <li>Tim pengembangan dan operasi menggunakan data dari monitoring dan logging untuk mengidentifikasi masalah, melakukan perbaikan, dan meningkatkan kinerja aplikasi.</li> </ul> </li> </ul> </li> </ul> </li> </ol>"},{"location":"dokumentasi/changelog/","title":"16.1 Pengertian Changelog","text":"<p>Changelog adalah sebuah catatan atau dokumentasi yang mencatat semua perubahan, pembaruan, perbaikan bug, atau perubahan lainnya yang terjadi pada suatu perangkat lunak, sistem, atau produk selama pengembangannya. Changelog berfungsi sebagai referensi bagi pengembang dan pengguna untuk mengetahui fitur baru, pembaruan, dan perbaikan yang telah dilakukan pada suatu versi atau rilisan.</p> <p>Changelog sering digunakan dalam proyek perangkat lunak untuk memudahkan pengguna dan pengembang dalam melacak perubahan apa saja yang telah dilakukan sejak versi sebelumnya. Ini membantu pengguna dalam mengetahui perbedaan antara versi yang mereka gunakan dengan versi yang baru dirilis.</p>"},{"location":"dokumentasi/changelog/#162-tujuan-changelog","title":"16.2 Tujuan Changelog","text":"<p>Changelog memiliki beberapa tujuan penting, antara lain:</p> <ol> <li>Menyediakan riwayat perubahan: Dengan adanya changelog, pengguna dan pengembang bisa mengetahui perubahan apa saja yang sudah dilakukan dari versi ke versi.</li> <li>Meningkatkan transparansi: Changelog memberikan transparansi terhadap perkembangan suatu proyek perangkat lunak atau aplikasi, sehingga pengguna bisa memantau kemajuan dan perbaikan yang dilakukan.</li> <li>Membantu pengembang dalam melacak perubahan: Pengembang bisa menggunakan changelog untuk mencatat dan melacak perbaikan atau penambahan fitur yang telah dilakukan dalam berbagai rilis.</li> <li>Membantu dalam perencanaan rilis selanjutnya: Dengan mencatat perubahan yang telah dilakukan, pengembang bisa merencanakan perbaikan atau pembaruan di masa depan lebih terstruktur.</li> </ol>"},{"location":"dokumentasi/changelog/#163-struktur-umum-changelog","title":"16.3 Struktur Umum Changelog","text":"<p>Umumnya, changelog disusun dengan format yang terstruktur agar mudah dipahami. Berikut adalah struktur dasar dalam sebuah changelog:</p> <ol> <li>Versi dan Tanggal Rilis: Setiap entri changelog dimulai dengan nomor versi dan tanggal rilisnya. Ini penting untuk mengidentifikasi kapan suatu perubahan diterapkan.</li> <li>Kategori Perubahan: Changelog biasanya mengelompokkan perubahan berdasarkan kategori tertentu, misalnya:<ul> <li>Added: Fitur baru yang ditambahkan.</li> <li>Changed: Fitur yang diubah atau diperbarui.</li> <li>Fixed: Bug yang diperbaiki.</li> <li>Deprecated: Fitur yang tidak lagi didukung atau akan dihapus di versi mendatang.</li> <li>Removed: Fitur yang dihapus.</li> <li>Security: Pembaruan terkait dengan keamanan.</li> </ul> </li> <li>Deskripsi Singkat tentang Perubahan: Deskripsi singkat yang jelas dan ringkas mengenai setiap perubahan atau perbaikan yang dilakukan, agar pengguna bisa memahami manfaat dari pembaruan tersebut.</li> <li>Referensi atau Tautan (Opsional): Beberapa changelog menyertakan tautan atau referensi ke tiket, isu, atau permintaan penggabungan (pull request) di sistem pengelolaan kode sumber untuk memberi informasi lebih rinci tentang perubahan.</li> </ol>"},{"location":"dokumentasi/changelog/#164-contoh-penulisan-changelog","title":"16.4 Contoh Penulisan Changelog","text":"<p>Berikut adalah contoh changelog yang disusun dengan mengikuti struktur di atas:</p> <pre><code>## [2.1.0] - 2024-12-01\n\n### Added\n- Menambahkan fitur sinkronisasi antar perangkat untuk memudahkan akses data.\n- Menambahkan dukungan untuk bahasa Spanyol pada aplikasi.\n\n### Changed\n- Memperbarui desain antarmuka pengaturan agar lebih responsif di perangkat mobile.\n- Menyempurnakan algoritma pencarian untuk meningkatkan kecepatan.\n\n### Fixed\n- Memperbaiki bug pada login yang gagal pada perangkat iOS 14.\n\n### Removed\n- Menghapus dukungan untuk Android versi 8 ke bawah, karena tidak lagi kompatibel dengan teknologi baru.\n</code></pre>"},{"location":"dokumentasi/commit/","title":"16.7 Commit Message","text":"<p>Commit message adalah pesan yang ditulis saat melakukan commit dalam sistem kontrol versi seperti Git. Tujuannya adalah untuk menjelaskan perubahan yang dilakukan dalam kode agar mudah dipahami.</p>"},{"location":"dokumentasi/commit/#1671-struktur-commit-message","title":"16.7.1 Struktur Commit Message","text":"<ol> <li>Tipe:<ul> <li><code>feat</code>: Menambahkan fitur baru.</li> <li><code>fix</code>: Memperbaiki bug.</li> <li><code>docs</code>: Memperbarui dokumentasi.</li> <li><code>style</code>: Perubahan format atau gaya kode.</li> <li><code>refactor</code>: Perbaikan struktur kode tanpa mengubah fungsionalitas.</li> <li><code>perf</code>: Meningkatkan kinerja aplikasi.</li> <li><code>test</code>: Menambah atau memperbaiki pengujian.</li> <li><code>chore</code>: Tugas pemeliharaan rutin.</li> <li><code>ci</code>: Perubahan pada CI/CD.</li> <li><code>build</code>: Perubahan sistem build atau dependensi.</li> <li><code>revert</code>: Mengembalikan commit sebelumnya.</li> </ul> </li> <li>Scope (Opsional): Area spesifik dalam proyek.</li> <li>Ringkasan: Deskripsi singkat dengan kalimat perintah (imperatif).</li> </ol>"},{"location":"dokumentasi/commit/#1672-contoh-commit-message-yang-baik","title":"16.7.2 Contoh Commit Message yang Baik","text":"<pre><code>feat(auth): Tambahkan sistem login dengan Google\nfix(ui): Perbaiki bug pada tombol checkout di iOS\ndocs(readme): Perbarui instruksi instalasi di README\n</code></pre>"},{"location":"dokumentasi/dokumentasi-content/","title":"BAB 15 DOKUMENTASI","text":"<p>Dokumentasi sistem perangkat lunak adalah bagian yang sangat penting dalam pengembangan sistem karena dapat membantu pengembang, pengguna, dan tim pemeliharaan untuk memahami cara kerja, penggunaan, dan pengelolaan sistem. Dokumentasi yang baik memfasilitasi pemahaman yang jelas tentang bagaimana aplikasi, API, database, dan komponen lainnya bekerja, serta bagaimana cara mengelola dan mengembangkannya di masa depan.</p> <p>Dalam bab ini, akan dibahas mengenai aspek-aspek yang perlu didokumentasikan untuk berbagai jenis sistem, seperti aplikasi, API, database, dan sistem lainnya, beserta alat yang dapat digunakan untuk membuat dokumentasi tersebut.</p>"},{"location":"dokumentasi/dokumentasi-content/#151-dokumentasi-aplikasi-mobile-web","title":"15.1 Dokumentasi Aplikasi (Mobile &amp; Web)","text":"<p>Dokumentasi aplikasi penting untuk memandu pengguna dalam menggunakan aplikasi dan untuk pengembang dalam memelihara dan mengembangkan aplikasi tersebut. Berikut adalah elemen-elemen yang perlu didokumentasikan untuk aplikasi:</p>"},{"location":"dokumentasi/dokumentasi-content/#1511-panduan-pengguna","title":"15.1.1 Panduan Pengguna","text":"<ul> <li>Deskripsi Aplikasi: Penjelasan singkat tentang aplikasi, tujuan, dan pengguna yang disasar.</li> <li>Instalasi: Petunjuk tentang bagaimana menginstal aplikasi di perangkat pengguna, termasuk pengaturan yang dibutuhkan.</li> <li>Petunjuk Penggunaan: Langkah-langkah untuk menggunakan aplikasi, mulai dari cara login hingga cara memanfaatkan fitur utama aplikasi.</li> <li>Pemecahan Masalah: Solusi untuk masalah umum yang dapat ditemui oleh pengguna selama menggunakan aplikasi.</li> </ul>"},{"location":"dokumentasi/dokumentasi-content/#1512-dokumentasi-kode-aplikasi","title":"15.1.2 Dokumentasi Kode Aplikasi","text":"<ul> <li>Struktur Kode: Penjelasan tentang struktur direktori dan file dalam kode aplikasi.</li> <li>Fungsi dan Kelas Utama: Deskripsi tentang fungsi atau kelas penting yang ada dalam aplikasi, beserta penjelasan parameter dan hasil yang diharapkan.</li> <li>Dependensi: Penjelasan mengenai library atau framework yang digunakan dalam pengembangan aplikasi.</li> </ul>"},{"location":"dokumentasi/dokumentasi-content/#1513-panduan-pengembangan-dan-kontribusi","title":"15.1.3 Panduan Pengembangan dan Kontribusi","text":"<ul> <li>Lingkungan Pengembangan: Instruksi untuk mempersiapkan lingkungan pengembangan lokal.</li> <li>Panduan Kontribusi: Petunjuk mengenai cara berkontribusi pada proyek aplikasi, seperti cara membuat pull request.</li> <li>Proses Build dan Deployment: Langkah-langkah untuk membangun aplikasi dan melakukan deployment ke server atau toko aplikasi.</li> </ul>"},{"location":"dokumentasi/dokumentasi-content/#1514-tools-untuk-dokumentasi-aplikasi","title":"15.1.4 Tools untuk Dokumentasi Aplikasi:","text":"<ul> <li>Markdown: Format ringan yang digunakan untuk membuat dokumentasi berbentuk teks.</li> <li>Doxygen: Alat untuk menghasilkan dokumentasi kode secara otomatis dari komentar dalam kode sumber.</li> <li>Sphinx: Alat untuk membuat dokumentasi, terutama untuk proyek Python.</li> <li>Jekyll: Framework untuk membuat situs dokumentasi berbasis Markdown.</li> </ul>"},{"location":"dokumentasi/dokumentasi-content/#152-dokumentasi-api","title":"15.2 Dokumentasi API","text":"<p>API adalah bagian inti dari aplikasi modern yang memungkinkan komunikasi antara berbagai sistem. Dokumentasi API sangat penting untuk memandu pengembang dalam menggunakan dan mengintegrasikan API dengan sistem lain. Berikut adalah elemen-elemen yang perlu didokumentasikan untuk API:</p>"},{"location":"dokumentasi/dokumentasi-content/#1521-deskripsi-api","title":"15.2.1 Deskripsi API","text":"<ul> <li>Pengenalan API: Penjelasan mengenai tujuan dan fungsionalitas API, termasuk data apa yang dapat diakses dan bagaimana API digunakan.</li> <li>Autentikasi: Penjelasan tentang mekanisme autentikasi yang digunakan oleh API (misalnya, API key, token, OAuth).</li> <li>Endpoint API: Daftar lengkap dari endpoint yang tersedia, beserta deskripsi singkat tentang fungsinya.</li> </ul>"},{"location":"dokumentasi/dokumentasi-content/#1522-dokumentasi-parameter-dan-respons","title":"15.2.2 Dokumentasi Parameter dan Respons","text":"<ul> <li>Parameter: Penjelasan tentang parameter yang diterima oleh API, termasuk tipe data dan apakah parameter tersebut wajib atau opsional.</li> <li>Format Respons: Penjelasan mengenai format respons yang akan diterima oleh pengguna API, seperti struktur data JSON atau XML.</li> </ul>"},{"location":"dokumentasi/dokumentasi-content/#1523-contoh-penggunaan","title":"15.2.3 Contoh Penggunaan","text":"<ul> <li>Contoh Request dan Response: Penyertaan contoh request dan response untuk setiap endpoint API yang didokumentasikan.</li> </ul>"},{"location":"dokumentasi/dokumentasi-content/#1524-dokumentasi-api-di-fastapi","title":"15.2.4 Dokumentasi API di FastAPI","text":"<p>FastAPI secara otomatis menghasilkan dokumentasi API yang sangat mudah diakses melalui antarmuka berbasis web. Dokumentasi ini dapat dilihat menggunakan dua format yang populer: Swagger UI dan Redoc. Setiap aplikasi FastAPI secara otomatis menghasilkan dua dokumentasi interaktif yang mencakup semua endpoint, parameter, dan respons API, yang sangat membantu pengembang dan pengguna API.</p> <ul> <li>Swagger UI: Menyediakan antarmuka interaktif untuk menjelajahi endpoint API, melihat parameter yang diperlukan, serta mencoba API langsung dari browser.</li> <li>Redoc: Alternatif dokumentasi yang lebih minimalis, tetapi tetap menyajikan informasi secara rinci mengenai API.</li> </ul> <p>Kedua dokumentasi ini dihasilkan secara otomatis oleh FastAPI dengan hanya menyediakan deskripsi yang tepat dalam kode Python. Dokumentasi API dapat diakses melalui URL default seperti <code>/docs</code> untuk Swagger UI dan <code>/redoc</code> untuk Redoc.</p> <p>Contoh Implementasi di FastAPI:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: str = None):\n    \"\"\"\n    Endpoint untuk membaca item berdasarkan item_id.\n    Parameter 'item_id' wajib, sementara 'q' opsional.\n    \"\"\"\n    return {\"item_id\": item_id, \"q\": q}\n</code></pre> <p>Dengan kode di atas, FastAPI secara otomatis akan menghasilkan dokumentasi interaktif yang dapat diakses melalui URL <code>/docs</code> (Swagger UI) dan <code>/redoc</code> (Redoc). Dokumentasi ini akan menyertakan penjelasan tentang endpoint <code>/items/{item_id}</code>, parameter <code>item_id</code> dan <code>q</code>, serta contoh request dan response.</p> <p>Tools untuk Dokumentasi API:</p> <ul> <li>Swagger/OpenAPI: Standar terbuka untuk mendokumentasikan API, yang juga memungkinkan pembuatan antarmuka pengguna untuk menguji API secara langsung.</li> <li>Postman: Alat untuk menguji API yang juga mendukung dokumentasi API interaktif.</li> <li>Redoc: Alat yang digunakan untuk menampilkan dokumentasi API yang dihasilkan dari file OpenAPI.</li> <li>Apiary: Platform untuk mendokumentasikan, menguji, dan berbagi API.</li> </ul> <p>Dengan menggunakan FastAPI, dokumentasi API menjadi lebih cepat dan mudah dibuat karena dokumentasi akan dihasilkan secara otomatis berdasarkan definisi endpoint dan parameter yang sudah disediakan dalam kode aplikasi.</p>"},{"location":"dokumentasi/dokumentasi-content/#153-dokumentasi-database","title":"15.3 Dokumentasi Database","text":"<p>Dokumentasi database membantu pengembang dan administrator database untuk memahami struktur database, tabel, kolom, dan hubungan antar data. Berikut adalah elemen-elemen yang perlu didokumentasikan untuk database:</p>"},{"location":"dokumentasi/dokumentasi-content/#1531-struktur-database","title":"15.3.1 Struktur Database","text":"<ul> <li>Diagram Entity-Relationship (ERD): Diagram yang menggambarkan relasi antara entitas dalam database.</li> <li>Deskripsi Tabel dan Kolom: Penjelasan tentang setiap tabel dalam database, termasuk kolom-kolom yang ada, tipe data, dan apakah kolom tersebut wajib diisi atau tidak.</li> </ul>"},{"location":"dokumentasi/dokumentasi-content/#1532-panduan-pengelolaan-database","title":"15.3.2 Panduan Pengelolaan Database","text":"<ul> <li>Migrasi Database: Instruksi untuk memigrasi skema database apabila ada perubahan.</li> <li>Backup dan Restore: Penjelasan cara melakukan backup dan restore database.</li> </ul>"},{"location":"dokumentasi/dokumentasi-content/#1533-query-yang-sering-digunakan","title":"15.3.3 Query yang Sering Digunakan","text":"<ul> <li>Query Dasar: Penjelasan tentang query-query dasar yang sering digunakan, seperti SELECT, INSERT, UPDATE, dan DELETE.</li> <li>Optimasi Query: Penjelasan tentang cara mengoptimalkan query agar lebih efisien dalam pengolahan data.</li> </ul> <p>Tools untuk Dokumentasi Database:</p> <ul> <li>dbdocs: Alat untuk menghasilkan dokumentasi database dari struktur skema yang ada.</li> <li>SchemaSpy: Alat untuk menghasilkan diagram ERD dan dokumentasi dari database relasional.</li> <li>Doxygen: Alat yang dapat digunakan untuk menghasilkan dokumentasi database jika digunakan bersamaan dengan komentar di dalam kode SQL.</li> <li>MySQL Workbench: Alat yang dapat digunakan untuk mendokumentasikan struktur database dan menghasilkan ERD.</li> </ul>"},{"location":"dokumentasi/dokumentasi-content/#154-kesimpulan","title":"15.4 Kesimpulan","text":"<p>Dokumentasi yang lengkap dan terstruktur dengan baik sangat penting untuk pengelolaan dan pengembangan perangkat lunak jangka panjang. Dengan dokumentasi yang jelas, pengembang dapat bekerja lebih efisien, pengguna dapat memanfaatkan sistem dengan lebih optimal, dan tim pemeliharaan dapat lebih mudah melakukan perbaikan atau pengembangan lanjutan. Dokumentasi harus mencakup aspek teknis sistem (seperti API, database, dan kode aplikasi) serta informasi praktis yang diperlukan oleh pengguna dan pengembang. Alat-alat yang disebutkan sebelumnya di atas dapat digunakan untuk mempermudah pembuatan dan pemeliharaan dokumentasi ini.</p>"},{"location":"dokumentasi/kesimpulan/","title":"16.7.2 Kesimpulan","text":"<p>Changelog, Semantic Versioning, dan Commit Message membantu menjaga transparansi, komunikasi, dan pemeliharaan kode yang baik dalam pengembangan perangkat lunak. Dengan mengikuti pedoman ini, proyek perangkat lunak dapat berkembang lebih terstruktur dan mudah dipahami oleh semua pihak yang terlibat.</p>"},{"location":"dokumentasi/pre-release/","title":"16.5 Pre-release","text":"<p>Pre-release merujuk pada versi perangkat lunak yang belum sepenuhnya siap untuk rilis final atau publik. Pre-release ini biasanya berfungsi sebagai versi percobaan atau uji coba yang dirilis kepada pengguna atau pengembang tertentu untuk mendapatkan umpan balik dan mendeteksi bug sebelum rilis resmi.</p>"},{"location":"dokumentasi/pre-release/#1651-jenis-pre-release","title":"16.5.1 Jenis Pre-release","text":"<ol> <li>Alpha: Versi awal yang sering kali tidak stabil dan masih banyak bug. Biasanya hanya dirilis untuk pengujian internal.</li> <li>Beta: Versi yang lebih stabil dibandingkan alpha, namun masih memiliki beberapa masalah. Beta sering kali dirilis untuk pengujian publik atau untuk sekelompok pengguna tertentu yang memberikan umpan balik.</li> <li>Release Candidate (RC): Versi yang sudah sangat mendekati versi final, dengan sebagian besar bug sudah diperbaiki. Meskipun demikian, beberapa masalah kecil mungkin masih ada.</li> </ol>"},{"location":"dokumentasi/pre-release/#1652-contoh-penulisan-changelog-untuk-pre-release","title":"16.5.2 Contoh Penulisan Changelog untuk Pre-release","text":"<p>Pre-release dapat ditandai dengan menambahkan label seperti \"beta\", \"alpha\", atau \"RC\" (Release Candidate) pada nomor versi, sehingga pengguna tahu bahwa versi tersebut belum sepenuhnya stabil. Berikut adalah contoh changelog yang mencakup pre-release:</p> <pre><code>## [2.1.0-beta1] - 2024-12-01\n\n### Added\n- Menambahkan fitur sinkronisasi antar perangkat (percakapan awal dengan pengujian terbatas).\n- Menambahkan dukungan awal untuk bahasa Spanyol pada aplikasi.\n\n### Fixed\n- Memperbaiki bug crash pada aplikasi saat membuka file besar.\n\n### Known Issues\n- Beberapa pengguna melaporkan aplikasi crash saat login di perangkat dengan Android 12.\n</code></pre>"},{"location":"dokumentasi/semantic-versioning/","title":"16.6 Semantic Versioning","text":"<p>Semantic Versioning (SemVer) adalah sistem penomoran versi yang digunakan untuk memberi informasi tentang perubahan yang terjadi pada perangkat lunak, sehingga pengembang dan pengguna dapat memahami apa yang telah berubah hanya dengan melihat nomor versinya.</p>"},{"location":"dokumentasi/semantic-versioning/#1661-format-semantic-versioning","title":"16.6.1 Format Semantic Versioning","text":"<p>Semantic Versioning menggunakan format MAJOR.MINOR.PATCH, yang memiliki arti sebagai berikut:</p> <ol> <li>MAJOR: Perubahan besar yang tidak kompatibel dengan versi sebelumnya.<ul> <li>Contoh: Merombak API sehingga aplikasi menjadi tidak kompatibel dengan versi sebelumnya, maka versi menjadi <code>2.0.0</code>.</li> </ul> </li> <li>MINOR: Penambahan fitur baru yang kompatibel dengan versi sebelumnya.<ul> <li>Contoh: Menambahkan fitur pencarian baru, maka versi menjadi <code>1.2.0</code>.</li> </ul> </li> <li>PATCH: Perbaikan bug atau perubahan kecil yang tidak mengubah kompatibilitas.<ul> <li>Contoh: Memperbaiki bug kecil, maka versi menjadi <code>1.1.1</code>.</li> </ul> </li> </ol>"},{"location":"dokumentasi/semantic-versioning/#1662-contoh-versi","title":"16.6.2 Contoh Versi:","text":"<pre><code>1.2.3\nMAJOR (1): Perubahan besar\nMINOR (2): Penambahan fitur\nPATCH (3): Perbaikan bug\n</code></pre>"},{"location":"dokumentasi/semantic-versioning/#1663-pre-release-dan-build-metadata","title":"16.6.3 Pre-release dan Build Metadata","text":"<p>Selain MAJOR.MINOR.PATCH, SemVer juga mendukung:</p> <ul> <li>Pre-release Versions: Ditambahkan dengan tanda minus (-), misalnya:<ul> <li><code>1.0.0-alpha</code></li> <li><code>1.0.0-beta</code></li> <li><code>1.0.0-rc.1</code></li> </ul> </li> <li>Build Metadata: Ditambahkan dengan tanda plus (+), misalnya:<ul> <li><code>1.0.0+20130313144700</code></li> </ul> </li> </ul>"},{"location":"psr/intro/","title":"BAB 6 Menulis Kode PHP","text":"<p>Pengembangan sistem informasi di lingkungan UGM yang menggunakan PHP wajib mengikuti panduan standart dari PHP Standarts Recomendations (PSR). PSR adalah sekumpulan standar penulisan kode PHP yang dibuat oleh developer PHP, praktisi, pengembang framework atau aplikasi dan semua pihak atau perusahaan uang memiliki kepentingan dengan PHP. Dengan adanya standar yang disepakati bersama ini maka kode PHP akan lebih jelas dan efisien.</p>"},{"location":"psr/psr-1/","title":"6.1 PSR 1 Basic Coding Standart","text":"<p>PSR-1 adalah standar yang memberikan pedoman dasar untuk menulis kode PHP agar lebih konsisten, mudah dipahami, dan kompatibel saat digunakan bersama oleh banyak programmer. PSR-1 adalah aturan tata krama menulis kode PHP yang bisa dipahami semua orang dalam tim besar. </p>"},{"location":"psr/psr-1/#611-file-php-harus-dimulai-dengan-tag-php","title":"6.1.1 File PHP Harus Dimulai dengan Tag <code>&lt;?php</code>","text":"<p>Tidak diperbolehkan terdapat kode di luar tag <code>&lt;?php.</code> Misalnya tidak diperbolahkan untuk menambahkan spasi atau teks di awal file. Contoh yang baik:</p> <pre><code>&lt;?php\necho \"hello world!\"; //ok\n</code></pre>"},{"location":"psr/psr-1/#612-gunakan-utf-8-tanpa-bom","title":"6.1.2 Gunakan UTF-8 Tanpa BOM","text":"<p>File PHP harus disimpan dalam format teks <code>UTF-8</code> tanpa BOM (Byte Order Mark). Ini akan memastikan kode dapat bekerja dengan baik tanpa karakter aneh muncul. Contoh yang baik seperti point 6.1.1. Berikut contoh tidak baik dengan BOM</p> <pre><code>[karakter BOM tak terlihat di sini]&lt;?php\necho \"Hello, world!\";\n</code></pre> <p>Output akan seperti ini</p> <pre><code>\u00ef\u00bb\u00bfHello, world!\n</code></pre> <p>Ini karena server PHP akan membaca BOM sebagai bagian dari output.</p>"},{"location":"psr/psr-1/#613-berikan-nama-kelas-dan-fungsi-yang-jelas","title":"6.1.3 Berikan Nama Kelas dan Fungsi yang jelas","text":"<p>Nama kelas harus mengikuti aturan StudlyCaps (huruf besar di awal setiap kata). StudlyCaps adalah gaya penamaan dalam pemrograman di mana setiap kata dimulai dengan huruf besar, tanpa menggunakan spasi atau karakter pemisahan lainnya. Seperti PascalCase namun umumnya pascal case digunakan diluar PHP dan untuk PHP adalah StudlyCaps. Nama kelas dan namescape harus mengikuti standar di PSR-4.</p> <pre><code>&lt;?php\nclass MyFirstClass {} // Benar\nclass myfirstclass {} // Salah\n</code></pre>"},{"location":"psr/psr-1/#614-fungsi-harus-menggunakan-camelcase","title":"6.1.4 Fungsi Harus Menggunakan camelCase","text":"<p>Fungsi atau metode harus menggunakan huruf kecil di awal, lalu huruf besar untuk kata berikutnya.</p> <pre><code>&lt;?php\nfunction getUserName() {} // Benar\nfunction GetUserName() {} // Salah\n</code></pre>"},{"location":"psr/psr-1/#615-konstanta","title":"6.1.5 Konstanta","text":"<p>Konstanta wajib dideklarasikan dalam huruf besar semua dengan pemisah garis bawah. Contoh:</p> <pre><code>&lt;?php\nnamespace Vendor\\Model;\n\nclass Foo\n{\n    const VERSION = '1.0';\n    const DATE_APPROVED = '2012-06-01';\n}\n</code></pre>"},{"location":"psr/psr-11/","title":"6.9 PSR-11 Container Interface","text":"<p>PSR-11 atau Container Interface adalah antarmuka yang mengatur cara pengelolaan dan pemanggilan dependensi di dalam aplikasi PHP. Sebuah container dependensi berfungsi untuk menyimpan objek-objek dan menangani pembuatan instansinya. PSR-11 menetapkan aturan bagi container agar objek dapat diambil melalui nama atau alias dan juga menangani lifecycle objek, seperti apakah objek harus selalu dibuat baru atau berbagi instansi yang sama.</p> <p>PSR-11 menyediakan dua metode utama:</p> <ol> <li>get(): untuk mendapatkan objek dari container.</li> <li>has(): untuk memeriksa apakah objek tersedia dalam container.</li> </ol>"},{"location":"psr/psr-11/#691-cara-implementasi","title":"6.9.1 Cara Implementasi","text":"<p>Untuk menggunakan PSR-11, diperlukan implementasi container yang mendukung standar ini. Salah satu container yang umum digunakan adalah PHP-DI.  Instal library PHP-DI menggunakan Composer:</p> <pre><code>composer require php-di/php-di\n</code></pre> <p>Berikut adalah langkah-langkah penggunaan PSR-11 pada aplikasi PHP:</p> <ol> <li> <p>Membuat kelas yang akan dikelola oleh Container</p> <p>Misalnya: terdapat dua kelas yaitu <code>DatabaseConnection</code> dan <code>UserService</code>. Kelas <code>UserService</code> membutuhkan objek <code>DatabaseConnection</code> sebagai dependensinya. Berikut sebagai contohnya:</p> <p>Kelas DatabaseConnection</p> <pre><code>&lt;?php\n\nclass DatabaseConnection {\n    public function connect() {\n        return \"Terhubung ke database!\";\n    }\n}\n</code></pre> <p>Kelas UserService</p> <pre><code>&lt;?php\n\nclass UserService {\n    private $databaseConnection;\n\n    // Menyuntikkan dependensi DatabaseConnection melalui konstruktor\n    public function __construct(DatabaseConnection $databaseConnection) {\n        $this-&gt;databaseConnection = $databaseConnection;\n    }\n\n    public function getUser() {\n        return \"Pengguna data, \" . $this-&gt;databaseConnection-&gt;connect();\n    }\n}\n</code></pre> </li> <li> <p>Mengkonfigurasi Container</p> <p>Dalam hal ini, <code>ContainerBuilder</code> digunakan untuk membuat container yang akan menyimpan objek-objek dan dependensinya.</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse DI\\ContainerBuilder;\n\n// Membuat dan mengonfigurasi container\n$containerBuilder = new ContainerBuilder();\n$container = $containerBuilder-&gt;build();\n\n// Menambahkan objek DatabaseConnection ke dalam container\n$container-&gt;set(DatabaseConnection::class, DI\\create(DatabaseConnection::class));\n\n// Menambahkan objek UserService dengan dependency injection\n$container-&gt;set(UserService::class, DI\\create(UserService::class)-&gt;constructor(DI\\get(DatabaseConnection::class)));\n</code></pre> </li> <li> <p>Mengambil dan menggunakan objek dari Container</p> <p>Saat ini, objek <code>UserService</code> dapat diambil dari container. Container akan secara otomatis menangani injeksi dependensi (dalam hal ini <code>DatabaseConnection</code>).</p> <pre><code>&lt;?php\n\n// Mengambil objek UserService dari container\n$userService = $container-&gt;get(UserService::class);\n\n// Menggunakan objek UserService\necho $userService-&gt;getUser();  // Output: Pengguna data, Terhubung ke database!\n</code></pre> </li> </ol> <p>Penjelasan Kode</p> <ol> <li>ContainerBuilder: digunakan untuk membuat container. Container ini menyimpan semua dependensi yang dibutuhkan oleh aplikasi.</li> <li>set(): menambahkan objek ke dalam container. Dalam contoh ini, objek <code>DatabaseConnection</code> dan <code>UserService</code> ditambahkan.</li> <li>get(): mengambil objek dari container. Saat mengambil objek <code>UserService</code>, container juga secara otomatis menyuntikkan objek <code>DatabaseConnection</code> ke dalamnya.</li> <li>constructor(): digunakan untuk menyuntikkan dependensi ke dalam konstruktor objek <code>UserService</code>.</li> </ol> <p>Berikut adalah hasil yang diperoleh setelah menjalankan kode di atas:</p> <pre><code>Pengguna data, Terhubung ke database!\n</code></pre>"},{"location":"psr/psr-11/#692-keuntungan","title":"6.9.2 Keuntungan","text":"<ol> <li> <p>Modularitas</p> <p>PSR-11 memungkinkan mengelola dan memisahkan dependensi dalam aplikasi, sehingga aplikasi lebih modular.</p> </li> <li> <p>Interoperabilitas</p> <p>Aplikasi dapat dengan mudah berintegrasi dengan berbagai library dan framework yang mendukung PSR-11.</p> </li> <li> <p>Dependency Injection</p> <p>PSR-11 mendukung pola dependency injection, yang memungkinkan pengelolaan objek lebih fleksibel dan mudah diuji.</p> </li> </ol>"},{"location":"psr/psr-12/","title":"6.2 PSR 12 Extended Coding Style Guide","text":"<p>PSR 12 merupakan pengembangan dari PSR 2 mengenai coding style dan mengikuti standar PSR 1 untuk pengkodean dasar dengan tujuan untuk mencakup lebih banyak aspek dan memberikan panduan yang lebih rinci. PSR 12 dirancang untuk meningkatkan konsistensi dan keterbacaan kode dalam pengembangan PHP. Dengan standar ini maka akan memudahkan kolaborasi antar programmer dalam suatu proyek. PSR 12 memberikan panduan detail tentang penyesuaian format atau gaya penulisan kode mulai dari indentasi, spasi, panjang baris, hingga cara mendeklarasikan kelas dan fungsi. Bayangkan PSR 12 ini seperti \u201caturan tata bahasa\u201d saat menulis artikel. Jika semua mengikuti aturan maka artikel akan mudah dibaca. Di dalam dunia PHP, kode yang mengikuti PSR 12 akan lebih mudah dipahami dan dirawat oleh semua programmer. Beberapa poin utama yang harus diperhatikan dalam pengembangan PHP menurut PSR 12:</p>"},{"location":"psr/psr-12/#621-gunakan-tag-php-dalam-file-php","title":"6.2.1 Gunakan Tag PHP Dalam File PHP","text":"<p>Semua file PHP harus menggunakan tag <code>&lt;?php</code> dan harus menggunakan Unix LF atau baris baru. File harus diakhiri dengan satu baris kosong. Apabila file PHP hanya berisi kode PHP, tidak boleh menutup file dengan tag <code>?&gt;</code>.</p>"},{"location":"psr/psr-12/#622-baris","title":"6.2.2 Baris","text":"<p>Tidak terdapat batasan panjang maksimum untuk baris. Namun disarankan panjang baris tidak melebihi 120 karakter. Idealnya, baris tidak lebih dari 80 karakter. Apabila lebih, maka dengan memotong menjadi beberapa baris. Kemudian tidak boleh terdapat spasi berlebihan di akhir baris. Selanjutnya gunakan baris kosong untuk memisahkan blok kode yang berhubungan, agar lebih mudah dibaca.</p> <p>Contoh: <pre><code>&lt;?php\n\n// Panjang baris tidak lebih dari 80 karakter (direkomendasikan)\nif ($user-&gt;isLoggedIn() &amp;&amp; $user-&gt;hasPermission('edit')) {\n    echo \"You have access to edit.\";\n}\n\n// Jika lebih panjang dari 80 karakter, pisahkan ke beberapa baris\nif (\n    $user-&gt;isLoggedIn()\n    &amp;&amp; $user-&gt;hasPermission('edit')\n    &amp;&amp; $user-&gt;isVerified()\n) {\n    echo \"Access granted.\";\n}\n\n// Tidak ada trailing whitespace\necho \"This is correct.\"; // \u2190 (Tidak ada spasi setelah titik koma)\n\n// Tambahkan baris kosong untuk keterbacaan\nfunction example()\n{\n    $data = \"Contoh data\";\n\n    // Operasi yang lebih kompleks di sini\n    return $data;\n}\n\n// Satu pernyataan per baris\n$var1 = 'value1';\n$var2 = 'value2'; // Boleh seperti ini\n// $var1 = 'value1'; $var2 = 'value2'; \u2190 Ini tidak boleh\n</code></pre></p>"},{"location":"psr/psr-12/#623-indentasi","title":"6.2.3 Indentasi","text":"<p>Agar kode terlihat lebih rapi, maka gunakan 4 spasi untuk setiap tingkat indentasi. Jangan gunakan Tab karena terdapat perbedaan interprestasi Tab disetiap editor atau IDE. Ada editor satu tab setara dengan 4 spasi namun ada editor lain satu tab bisa setara dengan 8 spasi. Akibatnya identasi kode dapat terlihat tidak seragam ketika dibuka di lingkungan berbeda. Sedangkan spasi lebih terprediksi di lintas platform. Spasi memiliki panjang tetap, sehingga memastikan bahwa indentasi terlihat sama di berbagai perangkat dan platform.</p>"},{"location":"psr/psr-12/#624-kata-kunci-dan-tipe","title":"6.2.4 Kata Kunci dan Tipe","text":"<p>Semua kata kunci PHP seperti <code>if</code>, <code>else</code>, <code>public</code>, dan lain-lain serta tipe seperti <code>int</code>, <code>string</code> harus ditulis dengan huruf kecil. Gunakan tipe pendek seperti <code>bool</code> untuk boolean (bukan <code>boolean</code>) dan <code>int</code> untuk integer (bukan <code>integer</code>).</p>"},{"location":"psr/psr-12/#625-deklarasi-namespace-dan-impor","title":"6.2.5 Deklarasi, Namespace, dan Impor","text":"<p>Bagian awal file PHP dapat memiliki blok berikut dalam urutan tertentu:</p> <ol> <li>Tag pembuka <code>&lt;?php</code>.</li> <li>Komentar untuk file atau <code>docblock</code>.</li> <li>Deklarasi seperti <code>declare(strict_types=</code>);` .</li> <li>Namespace.</li> <li>Setelah deklarasi namespace harus ada satu baris kosong</li> <li>Pernyataan <code>use</code> untuk kelas, fungsi atau konstanta harus dibagian atas setelah deklarasi namespace.</li> <li>Deklarasi <code>use</code> harus diurutkan secara alfabetis.</li> </ol> <p>Jika terdapat HTML dan PHP dalam satu file, bagian-bagian di atas tetap ada di atas file. Import tidak boleh menggunakan backslash <code>\\</code> di depan. Contoh yang benar untuk import: <pre><code>use Vendor\\Package\\ClassName;\n</code></pre> Contoh file dengan semua blok: <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Vendor\\Package;\n\nuse Vendor\\Package\\{ClassA as A, ClassB, ClassC as C};\nuse Vendor\\Package\\SomeNamespace\\ClassD as D;\nuse Vendor\\Package\\AnotherNamespace\\ClassE as E;\n\nuse function Vendor\\Package\\{functionA, functionB, functionC};\nuse function Another\\Vendor\\functionD;\n\nuse const Vendor\\Package\\{CONSTANT_A, CONSTANT_B, CONSTANT_C};\nuse const Another\\Vendor\\CONSTANT_D;\n\n/**\n * FooBar is an example class.\n */\nclass FooBar\n{\n    // ... additional PHP code ...\n}\n</code></pre> Namespace dengan kedalaman lebih dari dua tidak diperbolehkan untuk digunakan. Oleh karena itu, berikut ini adalah kedalaman gabungan maksimum yang diizinkan: <pre><code>&lt;?php\n\nuse Vendor\\Package\\SomeNamespace\\{\n    SubnamespaceOne\\ClassA,\n    SubnamespaceOne\\ClassB,\n    SubnamespaceTwo\\ClassY,\n    ClassZ,\n};\n</code></pre> Dan hal-hal berikut ini tidak diperbolehkan: <pre><code>&lt;?php\n\nuse Vendor\\Package\\SomeNamespace\\{\n    SubnamespaceOne\\AnotherNamespace\\ClassA,\n    SubnamespaceOne\\ClassB,\n    ClassZ,\n};\n</code></pre></p>"},{"location":"psr/psr-12/#626-ekstensi-dan-implementasi","title":"6.2.6 Ekstensi dan Implementasi","text":"<p>Kata kunci <code>extends</code> dan <code>implements</code> harus berada di baris yang sama dengan nama kelas. Kemudian simbol kurung kurawal <code>{</code> untuk membuka kelas harus pada baris baru, dan kurawal tutup <code>}</code> harus di baris berikutnya setelah isi kelas. Contoh:</p> <p><pre><code>&lt;?php\n\nnamespace Vendor\\Package;\n\nuse FooClass;\nuse BarClass as Bar;\nuse OtherVendor\\OtherPackage\\BazClass;\n\nclass ClassName extends ParentClass implements \\ArrayAccess, \\Countable\n{\n    // constants, properties, methods\n}\n</code></pre> Daftar implementasi dan dalam kasus interfaces, ekstensi boleh dibagi menjadi beberapa baris. Dimana setiap baris berikutnya diberi indentasi satu kali. Saat melakukannya, item pertama dalam daftar harus berada di baris berikutnya, dan harus hanya ada satu interface per baris.</p> <p>Contoh: <pre><code>&lt;?php\n\nnamespace Vendor\\Package;\n\nuse FooClass;\nuse BarClass as Bar;\nuse OtherVendor\\OtherPackage\\BazClass;\n\nclass ClassName extends ParentClass implements\n    \\ArrayAccess,\n    \\Countable,\n    \\Serializable\n{\n    // constants, properties, methods\n}\n</code></pre></p>"},{"location":"psr/psr-12/#627-menggunakan-traits","title":"6.2.7 Menggunakan Traits","text":"<p>Kata kunci <code>use</code> yang digunakan di dalam kelas untuk mengimplementasikan traits harus dideklarasikan pada baris berikutnya setelah kurung kurawal buka, contoh:</p> <pre><code>&lt;?php\n\nnamespace Vendor\\Package;\n\nuse Vendor\\Package\\FirstTrait;\n\nclass ClassName\n{\n    use FirstTrait;\n}\n</code></pre> <p>Setiap individu trait yang diimpor ke dalam kelas harus disertakan satu per baris dan setiap penyertaan harus mempunyai pernyataan penggunaan impornya sendiri, contoh:</p> <pre><code>&lt;?php\n\nnamespace Vendor\\Package;\n\nuse Vendor\\Package\\FirstTrait;\nuse Vendor\\Package\\SecondTrait;\nuse Vendor\\Package\\ThirdTrait;\n\nclass ClassName\n{\n    use FirstTrait;\n    use SecondTrait;\n    use ThirdTrait;\n}\n</code></pre> <p>Jika kelas tidak memiliki apapun setelah pernyataan <code>use</code> import, tanda kurung tutup kelas harus berada pada baris berikutnya setelah pernyataan <code>use</code> import.</p> <pre><code>&lt;?php\n\nnamespace Vendor\\Package;\n\nuse Vendor\\Package\\FirstTrait;\n\nclass ClassName\n{\n    use FirstTrait;\n}\n</code></pre> <p>Jika tidak, maka harus memiliki baris kosong setelah pernyataan penggunaan impor.</p> <pre><code>&lt;?php\n\nnamespace Vendor\\Package;\n\nuse Vendor\\Package\\FirstTrait;\n\nclass ClassName\n{\n    use FirstTrait;\n\n    private $property;\n}\n</code></pre> <p>Jika menggunakan operator <code>insteadof</code> dan <code>as</code>, keduanya harus digunakan sebagai berikut dengan memperhatikan indentasi, spasi, dan baris baru:</p> <pre><code>&lt;?php\n\nclass Talker\n{\n    use A;\n    use B {\n        A::smallTalk insteadof B;\n    }\n    use C {\n        B::bigTalk insteadof C;\n        C::mediumTalk as FooBar;\n    }\n}\n</code></pre>"},{"location":"psr/psr-12/#628-properti-dan-konstanta","title":"6.2.8 Properti dan Konstanta","text":"<p>Visibility harus ditentukan. Semua properti dalam sebuah kelas wajib memiliki visibilitas yang ditentukan misal <code>public</code>, <code>protected</code> atau <code>private</code>.</p> <p>Konstanta jika menggunakan PHP 7.1 atau versi yang lebih baru, visibilitas konstanta (<code>public</code>, <code>protected</code>, <code>private</code>) juga harus ditentukan. Contoh:</p> <pre><code>class Example\n{\n    public $foo;\n    protected int $bar = 10;\n    private static string $baz = \"Hello\";\n\n    protected const MY_CONSTANT = 100;\n}\n</code></pre> <p>Kata kunci <code>var</code> (yang masih didukung untuk deklarasi properti) tidak boleh digunakan, karena tidak merepresentasikan visibilitas secara eksplisit.</p> <pre><code>var $foo = null; // Dilarang\npublic $foo = null; // Diperbolehkan\n</code></pre> <p>Setiap properti harus dideklarasikan pada barisnya masing-masing, tanpa digabung dengna properti lain dalam satu pernyataan.</p> <pre><code>public $foo, $bar; // Dilarang\npublic $foo; // Boleh\npublic $bar; //Boleh\n</code></pre> <p>Nama properti tidak boleh diawali dengan underscore (_) untuk menunjukan visibilitas (<code>protected</code> atau <code>private</code>). Sebagai gantinya gunakan visibilitas eksplisit.</p> <pre><code>private $_foo; // Dilarang\nprivate $foo; // Boleh\n</code></pre> <p>Jika menggunakan type hinting, harus ada satu spasi antara tipe properti dan nama properti.</p> <pre><code>public int$bar; // Dilarang\npublic int $bar; //Boleh\n</code></pre>"},{"location":"psr/psr-12/#629-metode-dan-fungsi","title":"6.2.9 Metode dan Fungsi","text":"<p>Visibilitas harus ditentukan. Semua metode dalam sebuah kelas wajib memiliki visibilitas yang ditentukan misal <code>public</code>, <code>protected</code> atau <code>private</code>.</p> <pre><code>class Example\n{\n    public function foo() {}\n    protected function bar() {}\n    private function baz() {}\n}\n</code></pre> <p>Tidak menggunakan awalan undescore (_) pada nama metode. Nama metode tidak boleh diawali underscore untuk menujukan visibilitas. Sebagai gantinya gunakan visibilitas eksplisit.</p> <pre><code>protected function _myMethod() {} // Dilarang\nprotected function myMethod() {} //Boleh\n</code></pre> <p>Penempatan braces kurung kurawal buka <code>{</code> harus berada di baris baru setelah nama metode atau fungsi. Kemudian braces <code>}</code> harus berada di barus baru setelah metode atau fungsi.</p> <pre><code>public function fooBarBaz($arg1, &amp;$arg2, $arg3 = [])\n{\n    // Isi metode\n}\n</code></pre> <p>Tidak boleh ada spasi setelah nama metode atau fungsi dan sebelum tanpda kurung buka <code>(</code>. Dan tidak boleh ada spasi sebelum tanda kurung tutup <code>)</code>. Tapi untuk parameter yang jika lebih dari satu wajib menggunakan spasi setelah tanda koma.</p> <pre><code>namespace Vendor\\Package;\n\nclass ClassName\n{\n    public function fooBarBaz($arg1, &amp;$arg2, $arg3 = [])\n    {\n        // Isi metode\n    }\n}\n\nfunction fooBarBaz($arg1, &amp;$arg2, $arg3 = [])\n{\n    // Isi fungsi\n}\n\npublic function foo($arg1 ,$arg2 , $arg3 = []) {} // Dilarang\npublic function foo($arg1, $arg2, $arg3 = []) {} // Boleh\n</code></pre> <p>Default value harus di akhir argumen. Argumen yang memiliki nilai default harus ditempatkan di akhir daftar argumen.</p> <pre><code>public function foo($arg1 = 10, $arg2) {} // Dilarang\npublic function foo($arg1, $arg2 = 10) {} // Boleh\n</code></pre> <p>Jika argumen terlalu panjang, maka</p> <ol> <li>Setiap baris baru harus diindentasi sekali.</li> <li>Argumen pertama dalam daftar dimulai pada baris baru.</li> <li>Satu argumen per baris.</li> <li>Tanda kurung tutup <code>)</code> dan tanda kurung kurawal <code>{</code> harus bereda di baris yang sama dengan satu spasi diantaranya.</li> </ol> <pre><code>public function aVeryLongMethodName(\n    ClassTypeHint $arg1,\n    &amp;$arg2,\n    array $arg3 = []\n) {\n    // method body\n}\n</code></pre> <p>Jika metode atau fungsi memiliki deklarasi tipe pengembalian (return type) maka</p> <ol> <li>Ada satu spasi setelah titik dua <code>:</code> sebelum tipe pengembalian.</li> <li>Tanda : harus bereda di baris yang sama dengan tanpda kurung tutup <code>)</code>.</li> </ol> <pre><code>public function functionName(int $arg1, $arg2): string\n{\n    return 'foo';\n}\n</code></pre> <p>Jika daftar argumen dipisah dalam beberpa baris maka tanda <code>:</code> dan tipe pengembalian tetap di baris yang sama dengan tanda kurung tutup <code>)</code>.</p> <pre><code>public function anotherFunction(\n    string $foo,\n    string $bar,\n    int $baz\n): string {\n    return 'foo';\n}\n</code></pre> <p>Dalam deklarasi tipe yang nullable, tidak boleh ada spasi antara tanda tanya ? dan tipe.</p> <pre><code>public function functionName(? string $arg1): ? string {} // Dilarang\npublic function functionName(?string $arg1): ?string {} // Boleh\n</code></pre> <p>Tidak boleh ada spasi setelah tanda referensi <code>&amp;</code>.</p> <pre><code>public function foo(&amp;$ arg) {} // Dilarang\npublic function foo(&amp;$arg) {} // Boleh\n</code></pre> <p>Tidak boleh ada spasi antara variadic operator <code>\u2026</code> dan nama argumen.</p> <pre><code>public function process(string $algorithm, ... $parts) {} // Dilarang\npublic function process(string $algorithm, ...$parts) {} // Boleh\n</code></pre> <p>Jika menggunakan kombinasi reference operator &amp; dan variadic operator \u2026 tidak boleh ada spasi di antara keduanya.</p> <pre><code>public function process(string $algorithm, &amp; ...$parts) {} // Dilarang\npublic function process(string $algorithm, &amp;...$parts) {} // Boleh\n</code></pre>"},{"location":"psr/psr-12/#6210-control-structures","title":"6.2.10 Control Structures","text":"<p>Terdapat beberapa aturan yang harus diterapkan pada control structures.</p> <p>Berikut adalah aturan penulisan <code>if</code>, <code>elseif</code>, <code>else</code></p> <ol> <li>Harus ada satu spasi setelah kata kunci (<code>if</code>, <code>elseif</code>, <code>else</code>).</li> <li>Tidak terdapat spasi setelah tanda kurung buka <code>(</code> dan sebelum tanda kurung tutup <code>)</code>.</li> <li>Badan struktur:<ol> <li>Dibungkus dengan kurung kurawal <code>{}</code> meskipun hanya satu baris.</li> <li>Dimulai pada baris baru setelah kurung buka <code>{</code>.</li> <li>Diakhiri dengan kurung tutup <code>}</code> pada baris baru setelah badan.</li> </ol> </li> <li>Gunakan <code>elseif</code> atau <code>else if</code> untuk konsistensi.</li> <li>Apabila ekpresi panjang:<ol> <li>Setiap kondisi ditulis pada baris baru dengan indentasi.</li> <li>Operator boolean harus konsisten, berada di awal atau akhir baris.</li> </ol> </li> </ol> <pre><code>if ($expr1) {\n    // if body\n} elseif ($expr2) {\n    // elseif body\n} else {\n    // else body\n}\n\nif (\n    $expr1\n    &amp;&amp; $expr2\n) {\n    // if body\n}\n</code></pre> <p>Aturan penulisan <code>switch</code>, <code>case</code></p> <ol> <li>Kata kunci <code>switch</code> diikuti dengan ekspresi dalam tanda kurung <code>()</code>.</li> <li>Blok <code>case</code> dan <code>default</code> :<ol> <li>Diindentasi satu tingkat dari <code>switch</code>.</li> <li>Setiap <code>case</code> atau <code>default</code> diakhiri dengan perintah <code>break</code>, <code>return</code>, atau komentar <code>// no break</code> apabila tidak menggunakan break.</li> </ol> </li> <li>Ekspresi panjang pada switch mengikuti aturan yang sama seperti <code>if</code>.</li> </ol> <pre><code>switch ($expr) {\n    case 0:\n        echo 'First case, with a break';\n        break;\n    case 1:\n        echo 'Second case, which falls through';\n        // no break\n    case 2:\n        echo 'Third case, return instead of break';\n        return;\n    default:\n        echo 'Default case';\n        break;\n}\n</code></pre> <p>Aturan penulisan <code>while</code></p> <ol> <li>Ekspresi dalam tanda kurung <code>()</code> mengikuti aturan spasi yang sama dengan <code>if</code>.</li> <li>Badan struktur di dalam <code>{}</code>.</li> <li>Apabila ekspresi panjang, maka gunakan indentasi per baris dengan boolean operator yang konsisten</li> </ol> <pre><code>while ($expr) {\n    // body\n}\n\nwhile (\n    $expr1\n    &amp;&amp; $expr2\n) {\n    // body\n}\n</code></pre> <p>Aturan penulisan <code>do while</code></p> <ol> <li>Kurung buka <code>{</code> setelah kata kunci <code>do</code> di baris yang sama.</li> <li><code>while</code> diakhiri dengan tanda titik koma <code>;</code>.</li> </ol> <pre><code>do {\n    // body\n} while ($expr);\n\ndo {\n    // body\n} while (\n    $expr1\n    &amp;&amp; $expr2\n);\n</code></pre> <p>Aturan penulisan <code>for</code></p> <ol> <li>Ekspresi dalam tanda kurung <code>()</code><ol> <li>Tidak terdapat spasi sebelum atau setelah tanda koma.</li> <li>Setiap ekspresi dalam tanda kurung diakhiri dengan tanda titik koma <code>;</code>.</li> </ol> </li> <li>Apabila ekpsresi panjang, gunakan indentasi per baris.</li> </ol> <pre><code>for ($i = 0; $i &lt; 10; $i++) {\n    // for body\n}\n\nfor (\n    $i = 0;\n    $i &lt; 10;\n    $i++\n) {\n    // for body\n}\n</code></pre> <p>Aturan penulisan <code>foreach</code></p> <ol> <li>Gunakan tanda kurung <code>()</code> untuk menampung ekspresi.</li> <li>Badan struktur di dalam <code>{}</code>.</li> </ol> <pre><code>foreach ($iterable as $key =&gt; $value) {\n    // foreach body\n}\n</code></pre> <p>Aturan penulisan <code>try</code>, <code>catch</code>, <code>finally</code></p> <ol> <li>Kurung buka <code>{</code> setelah kunci <code>try</code>, <code>catch</code>, atau <code>finally</code> pada baris yang sama.</li> <li>Ekspresi dalam <code>catch</code> mendukung operator union <code>|</code> untuk tipe exception.</li> </ol> <pre><code>try {\n    // try body\n} catch (FirstThrowableType $e) {\n    // catch body\n} catch (OtherThrowableType | AnotherThrowableType $e) {\n    // catch body\n} finally {\n    // finally body\n}\n</code></pre>"},{"location":"psr/psr-12/#6211-operator","title":"6.2.11 Operator","text":"<p>Penulisan operator harus mengikuti aturan agar konsisten dalam pengelolaan spasi di sekitar operator untuk meningkatkan keterbacaan kode.</p> <p>Unari operator hanya memiliki satu operan, dan tidak diperbolehkan terdapat spasi antara operator dan operannya.</p> <pre><code>//Contoh Salah\n$i ++;\n++ $j;\n\n//Contoh Benar\n$i++;\n++$j;\n</code></pre> <p>Type casting (<code>int)</code>, <code>(string)</code>, dll.) tidak diperbolehkan terdapat spasi di dalam tanda kurung tipe casting.</p> <pre><code>$intValue = ( int ) $input; //contoh salah\n\n$intValue = (int) $input; //contoh benar\n</code></pre> <p>Operator binary melibatkan dua operan. Aturan operator ini mencakup operator aritmatika, perbandingan, penugasan, bitwise, logika, string dan tipe harus diapit oleh setidaknya satu spasi sebelum dan sesudahya.</p> <pre><code>//Contoh Salah\nif ($a===$b) {\n    $foo=$bar??$a??$b;\n} elseif ($a&gt;$b) {\n    $foo=$a+$b*$c;\n}\n//Contoh Benar\nif ($a === $b) {\n    $foo = $bar ?? $a ?? $b;\n} elseif ($a &gt; $b) {\n    $foo = $a + $b * $c;\n}\n</code></pre> <p>Ternary operator digunakan untuk pernyataan kondisional singkat. Spasi di sekitar <code>?</code> dan <code>:</code> harus ada setidaknya satu spasi sebelum dan sesudah <code>?</code> dan <code>:</code>.</p> <pre><code>$variable = $foo?'foo':'bar'; //Contoh salah\n$variable = $foo ? 'foo' : 'bar'; //Contoh benar\n</code></pre> <p>Ternary operator tanpa operand tengah mengikuti aturan yang sama seperti operator binary lainnya, yaitu terdapat spasi sebelum dan sesudah operator.</p> <pre><code>$variable = $foo?:'bar'; //Contoh salah\n$variable = $foo ?: 'bar'; //Contoh benar\n</code></pre>"},{"location":"psr/psr-12/#6212-closures","title":"6.2.12 Closures","text":"<p>Closures adalah fungsi anonim yang sering digunakan sebagai parameter atau fungsi tanpa nama. Untuk menjaga konsistensi dan keterbacaan, berikut beberapa aturan gaya penulisan untuk colsures.</p> <p>Spasi setelah function dan use. Harus terdapat satu spasi setelah kata kunci function dan sebelum serta sesudah kata kunci use.</p> <pre><code>//Contoh salah\n$closure = function($arg)use($var) {\n    // body\n};\n//Contoh benar\n$closure = function ($arg) use ($var) {\n    // body\n};\n</code></pre> <p>Letak kurung kurawal pembuka <code>{</code> harus berada di baris yang sama dengan deklarasi closure. Sedangkan kurung kurawal penutup <code>}</code> harus berada di baris berikutnya setelah isi closure.</p> <pre><code>//Contoh salah\n$closure = function ($arg)\n{\n    // body\n};\n//Contoh benar\n$closure = function ($arg) {\n    // body\n};\n</code></pre> <p>Spasi pada daftar argumen dan variabel. Tidak diperbolehkan terdapat spasi setelah kurung buka atau sebelum kurung tutup. Kemudian tidak diperbolehkan terdapat spasi sebelum koma. Terakhir harus terdapat satu spasi setelah koma.</p> <pre><code>//Contoh salah\n$closure = function( $arg1 ,$arg2 )use( $var1,$var2){\n    // body\n};\n//Contoh benar\n$closure = function ($arg1, $arg2) use ($var1, $var2) {\n    // body\n};\n</code></pre> <p>Argumen dengan nilai default harus berada di akhir daftar argumen.</p> <pre><code>//Contoh salah\n$closure = function ($arg1 = 'default', $arg2) {\n    // body\n};\n//Contoh benar\n$closure = function ($arg1, $arg2 = 'default') {\n    // body\n};\n</code></pre> <p>Tanda kolon (<code>:</code>) dan tipe return harus langsung mengikuti kurung tutup daftar argumen atau daftar variable <code>use</code> tanpa spasi. Kemudian harus terdapat satu spasi sebelum deklarasi tipe return.</p> <pre><code>//Contoh salah\n$closure = function ($arg) :string {\n    return 'result';\n};\n//Contoh benar\n$closure = function ($arg): string {\n    return 'result';\n};\n</code></pre> <p>Pemisahan argumen atau variable harus berada pada barisnya sendiri. Kemudian untuk kurung tutup dan kurung kurawal pembuka harus berada pada baris yang sama dengan satu spasi diantaranya.</p> <pre><code>//Contoh salah\n$closure = function ($arg1,\n    $arg2, $arg3) use ($var1,\n    $var2, $var3) \n{\n    // body\n};\n//Contoh benar\n$closure = function (\n    $arg1,\n    $arg2,\n    $arg3\n) use (\n    $var1,\n    $var2,\n    $var3\n) {\n    // body\n};\n</code></pre> <p>Kombinasi panjang dan pendek pada pendekatan variabel atau argumen yang pendek diperbolehkan digabungkan dalam satu baris.</p> <pre><code>//Contoh salah\n$closure = function ($arg) use (\n    $var1\n) {\n    // body\n};\n//Contoh benar\n$closure = function ($arg) use ($var1) {\n    // body\n};\n</code></pre> <p>Apabila closure digunakan langsung sebagai parameter dalam pemanggilan fungsi atau metode, aturan format tetap berlaku.</p> <pre><code>//Contoh salah\n$foo-&gt;bar($arg1,function($arg2)use($var1){\n    // body\n},$arg3);\n//Contoh benar\n$foo-&gt;bar(\n    $arg1,\n    function ($arg2) use ($var1) {\n        // body\n    },\n    $arg3\n);\n</code></pre>"},{"location":"psr/psr-12/#6213-anonymouse-classes","title":"6.2.13 Anonymouse Classes","text":"<p>Anonymous classess harus mengikuti pedoman, gaya, dan prinsip yang sama seperti closures. Anonymous class dideklarasikan sebagai kata kunci class tanpa nama. Brace pembuka (<code>{</code>) dapat berada pada baris yang sama dengan kata kunci class apabila tidak ada daftar implementasi antarmuka yang membungkus baris.</p> <pre><code>//Contoh brace di baris yang sama\n$instance = new class {\n    // Class content\n};\n//Contoh brace di baris berikutnya\n$instance = new class extends \\Foo implements\n    \\ArrayAccess,\n    \\Countable\n{\n    // Class content\n};\n</code></pre> <p>Isi kelas harus mengikuti aturan standar untuk struktur kelas pada umumnya. Setiap properti, metode, atau blok kode pada anonymous class harus diindentasikan satu kali.</p> <pre><code>//Contoh salah\n$instance = new class {\nprivate $property;\n\npublic function method()\n{\n// Method body\n}\n};\n\n//Contoh Benar\n$instance = new class {\n    private $property;\n\n    public function method()\n    {\n        // Method body\n    }\n};\n</code></pre> <p>Apabila anonymous class memiliki daftar implements atau extends yang pendek (tidak membungkus baris), brace pembuka harus berada pada baris yang sama. Apabila daftar membungkus, brace pembuka harus berada pada baris setelah daftar terakhir.</p> <pre><code>// Daftar pendek\n$instance = new class extends \\BaseClass implements \\Interface1 {\n    // Class content\n};\n\n// Daftar panjang\n$instance = new class implements\n    \\Interface1,\n    \\Interface2,\n    \\Interface3\n{\n    // Class content\n};\n</code></pre> <p>Harus terdapat satu spasi antara daftar <code>extends</code> atau <code>implements</code> dengan brace pembuka.</p> <pre><code>//Contoh salah\n$instance = new class extends \\Foo implements \\Bar{\n    // Class content\n};\n//Contoh benar\n$instance = new class extends \\Foo implements \\Bar {\n    // Class content\n};\n</code></pre> <p>Penempatan anonymous class pada parameter, apabila anonymous class digunakan sebagai argumen fungsi atau metode dengan aturan format yang sama tetap berlaku.</p> <pre><code>//Contoh salah\n$foo-&gt;process(new class extends \\BaseClass{\n    public function execute()\n    {\n        // Method content\n    }\n});\n//Contoh benar\n$foo-&gt;process(new class extends \\BaseClass {\n    public function execute()\n    {\n        // Method content\n    }\n});\n</code></pre>"},{"location":"psr/psr-13/","title":"6.10 PSR-13 Hypermedia Links","text":"<p>PSR-13 adalah standar PHP yang dikenal sebagai \"Hypermedia Links\". Standar ini didefinisikan oleh PHP-FIG (PHP Framework Interoperability Group) dan bertujuan untuk menyediakan antarmuka dan cara standar untuk menangani dan bekerja dengan hypermedia links dalam aplikasi PHP.</p> <p>PSR-13 bertujuan untuk mendefinisikan antarmuka yang seragam untuk bekerja dengan hypermedia links, sehingga memudahkan interoperabilitas antara berbagai pustaka dan framework PHP. Standar ini membantu pengembang untuk mengelola link secara konsisten dan memungkinkan komponen yang berbeda untuk bekerja bersama dengan lancar.</p>"},{"location":"psr/psr-13/#6101-implementasi-kode","title":"6.10.1 Implementasi Kode","text":"<p>Contoh implementasi dan penggunaan PSR-13 pada framework Codeigniter 4:</p> <pre><code>namespace App\\Controllers;\n\nuse CodeIgniter\\RESTful\\ResourceController;\nuse App\\Libraries\\Link;\nuse App\\Libraries\\LinkProvider;\n\nclass UsersController extends ResourceController\n{\n    public function index()\n    {\n        // Contoh data pengguna\n        $users = [\n            ['id' =&gt; 1, 'name' =&gt; 'John Doe'],\n            ['id' =&gt; 2, 'name' =&gt; 'Jane Doe'],\n        ];\n\n        // Membuat LinkProvider\n        $linkProvider = new LinkProvider();\n\n        // Menambahkan link ke pengguna pertama\n        $linkProvider-&gt;addLink(new Link('self', '/users/1'));\n        $linkProvider-&gt;addLink(new Link('friends', '/users/1/friends'));\n\n        // Menambahkan link ke pengguna kedua\n        $linkProvider-&gt;addLink(new Link('self', '/users/2'));\n        $linkProvider-&gt;addLink(new Link('friends', '/users/2/friends'));\n\n        // Menggabungkan data pengguna dengan link\n        foreach ($users as &amp;$user) {\n            $user['links'] = iterator_to_array($linkProvider-&gt;getLinksByRel('self'));\n        }\n\n        return $this-&gt;respond($users);\n    }\n}\n</code></pre>"},{"location":"psr/psr-13/#6102-output-json","title":"6.10.2 Output JSON","text":"<p>Response yang akan diterima oleh klien akan berupa JSON:</p> <pre><code>[\n    {\n        \"id\": 1,\n        \"name\": \"John Doe\",\n        \"links\": [\n            {\n                \"rel\": \"self\",\n                \"href\": \"http://yourdomain.com/users/1\"\n            },\n            {\n                \"rel\": \"friends\",\n                \"href\": \"http://yourdomain.com/users/1/friends\"\n            }\n        ]\n    },\n    {\n        \"id\": 2,\n        \"name\": \"Jane Doe\",\n        \"links\": [\n            {\n                \"rel\": \"self\",\n                \"href\": \"http://yourdomain.com/users/2\"\n            },\n            {\n                \"rel\": \"friends\",\n                \"href\": \"http://yourdomain.com/users/2/friends\"\n            }\n        ]\n    }\n]\n</code></pre>"},{"location":"psr/psr-13/#6103-keuntungan-penggunaan","title":"6.10.3 Keuntungan Penggunaan","text":"<p>Mengapa PSR-13 Penting dalam konteks Ini :</p> <ol> <li> <p>Konsistensi </p> <p>PSR-13 menyediakan cara yang konsisten untuk mendefinisikan dan mengakses link, membuat kode lebih mudah dipahami dan dirawat.</p> </li> <li> <p>Interoperabilitas</p> <p>Dengan menggunakan standar PSR-13, berbagai pustaka dan komponen dapat bekerja bersama dengan lebih baik, meningkatkan kemampuan integrasi dan pengembangan modular.</p> </li> <li> <p>Kemudahan Pengembangan</p> <p>Dengan antarmuka yang sudah didefinisikan dengan baik, pengembang dapat fokus pada logika bisnis daripada memikirkan detail implementasi pengelolaan link.</p> </li> </ol>"},{"location":"psr/psr-14/","title":"6.13 PSR-14 Event Dispatcher","text":"<p>PSR-14 adalah standar yang mengatur tentang Event Dispatcher atau sistem pemicu peristiwa pada PHP. Spesifikasi ini bertujuan untuk menyediakan standar interoperabilitas pada sistem pengelolaan dan pengiriman event sehingga library dan componen dapat digunakan secara berulang dalam aplikasi PHP.</p>"},{"location":"psr/psr-14/#6131-konsep-dasar","title":"6.13.1 Konsep Dasar","text":"<p>Adapun konsep dasar dari PSR-14 adalah sebagai berikut:</p> <ol> <li>Event, dalam konteks PSR-14 merupakan objek yang merepresentasikan suatu kejadian yang terjadi dalam aplikasi. Event dapat berisi data yang relevan tentang kejadian tersebut.</li> <li>Event Dispatcher adalah komponen yang bertanggung jawab untuk mengelola dan mengirimkan event. Hal tersebut memungkinkan pengembang untuk mendaftarkan listener (pendengar) yang akan merespon ketiga event tertentu apabila dipanggil.</li> <li>Listener adalah fungsi atau objek yang mendengarkan event tertentu dan merespon ketika event tersebut terjadi. Listener dapat melakukan berbagai tindakan, seperti memperbarui status, mengirim notifikasi, atau menjalankan logika bisnis lainnya.</li> </ol>"},{"location":"psr/psr-14/#6132-komponen-utama","title":"6.13.2 Komponen Utama","text":"<p>PSR-14 mendefinisikan beberapa komponen utama sebagai berikut:</p> <ol> <li> <p>Event Interface</p> <p>PSR-14 mendefinisikan antarmuka untuk event. Setiap event harus mengimplementasikan antarmuka ini.</p> <pre><code>namespace Psr\\EventDispatcher;\n\ninterface EventInterface\n{\n    // Metode yang diperlukan untuk event\n}\n</code></pre> </li> <li> <p>Event Dispatcher Interface</p> <p>Antarmuka ini mendefinisikan method untuk mengelola dan mengirimkan event.</p> <pre><code>namespace Psr\\EventDispatcher;\n\ninterface EventDispatcherInterface\n{\n    public function dispatch(EventInterface $event): EventInterface;\n}\n</code></pre> </li> <li> <p>Listener merupakan fungsi atau objek yang merespons event. Listener dapat diimplementasikan sebagai class atau function/method yang sesuai dengan kebutuhan aplikasi.</p> </li> <li>Event merupakan object yang dipicu dan dikirimkan melalui event dispatcher. Sebuah event biasanya berisi informasi tentang peristiwa atau kondisi yang terjadi di dalam aplikasi, bisa dalam bentuk sederhana maupun kompleks.</li> <li>Event Subscriber (optional)  merupakan konsep tambahan yang memungkinkan sebuah objek untuk \"subscribe/berlangganan\" ke berbagai jenis event dan mendengarkan lebih dari satu event tanpa memerlukan penambahan listener satu per satu.</li> </ol> <p>Berikut adalah contoh sederhana PSR-14:</p> <pre><code>use Psr\\EventDispatcher\\EventDispatcherInterface;\nuse Psr\\EventDispatcher\\EventInterface;\n\nclass UserRegisteredEvent implements EventInterface\n{\n    private $user;\n\n    public function __construct($user)\n    {\n        $this-&gt;user = $user;\n    }\n\n    public function getUser ()\n    {\n        return $this-&gt;user;\n    }\n}\n\nclass UserRegisteredListener\n{\n    public function handle(UserRegisteredEvent $event)\n    {\n        // Logika untuk menangani event pengguna terdaftar\n        echo \"User  registered: \" . $event-&gt;getUser ();\n    }\n}\n\nclass EventDispatcher implements EventDispatcherInterface\n{\n    private $listeners = [];\n\n    public function addListener(string $eventName, callable $listener)\n    {\n        $this-&gt;listeners[$eventName][] = $listener;\n    }\n\n    public function dispatch(EventInterface $event): EventInterface\n    {\n        $eventName = get_class($event);\n        if (isset($this-&gt;listeners[$eventName])) {\n            foreach ($this-&gt;listeners[$eventName] as $listener) {\n                $listener($event);\n            }\n        }\n        return $event;\n    }\n}\n\n// Penggunaan\n$dispatcher = new EventDispatcher();\n$dispatcher-&gt;addListener(UserRegisteredEvent::class, [new UserRegisteredListener(), 'handle']);\n\n$event = new UserRegisteredEvent('John Doe');\n$dispatcher-&gt;dispatch($event);\n</code></pre>"},{"location":"psr/psr-15/","title":"6.6 PSR-15 HTTP Server Request Handlers","text":"<p>PSR-15 merupakan salah satu standar yang ditetapkan oleh PHP-FIG untuk mendefinisikan HTTP Server Request Handlers dan Middleware dalam PHP. Standar ini bertujuan untuk menyediakan kerangka kerja bagi pengelolaan permintaan HTTP yang konsisten dan interoperable menggunakan pendekatan berbasis middleware, yang mirip dengan konsep pada framework seperti Express.js di Node.js atau Middleware Pipeline di ASP.NET Core.</p> <p>Komponen Utama PSR-15</p> <ol> <li> <p>Antarmuka Middleware: Middleware merupakan komponen yang berada diantara permintaan klien dan aplikasi. Middleware memproses permintaan server yang masuk dan menghasilkan response, dengan pilihan untuk mendelegasikan pembuatan respons ke komponen middleware berikutnya. Middleware yang mengikuti pedoman PSR-15 ini sebaiknya menggunakan interface <code>Psr\\Http\\Server\\MiddlewareInterface</code></p> <pre><code>namespace Psr\\Http\\Server;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface;\n}\n</code></pre> </li> <li> <p>Antarmuka Request Handler: Request handler menerima permintaan server dan mengembalikan response. Objek yang mengimplementasikan interface ini menerima permintaan (PSR-7 <code>RequestInterface</code>) dan harus mengembalikan response (PSR-7 <code>ResponseInterface</code>).</p> <pre><code>namespace Psr\\Http\\Server;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface RequestHandlerInterface\n{\n    public function handle(ServerRequestInterface $request): ResponseInterface;\n}\n</code></pre> </li> </ol> <p>Contoh Penggunaan</p> <p>Berikut adalah contoh cara membuat middleware dan request handler menggunakan PSR-15:</p> <ol> <li> <p>Contoh middleware:</p> <pre><code>namespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass ExampleMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface\n    {\n        // Melakukan sesuatu dengan permintaan\n        $response = $handler-&gt;handle($request);\n        // Melakukan sesuatu dengan respons\n        return $response;\n    }\n}\n</code></pre> </li> <li> <p>Contoh request handler:</p> <pre><code>namespace App\\Handler;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response;\n\nclass ExampleHandler implements RequestHandlerInterface\n{\n    public function handle(ServerRequestInterface $request): ResponseInterface\n    {\n        $response = new Response();\n        $response-&gt;getBody()-&gt;write('Hello, World!');\n        return $response;\n    }\n}\n</code></pre> </li> <li> <p>Menggunakan middleware dan handler:</p> <p>Dispatcher middleware biasanya digunakan untuk menangani urutan middleware dan akhirnya memanggil request handler. Berikut adalah contoh sederhana cara mengaturnya:</p> <pre><code>use Laminas\\Stratigility\\MiddlewarePipe;\nuse Laminas\\Stratigility\\Middleware\\RequestHandlerMiddleware;\nuse Laminas\\Diactoros\\ServerRequestFactory;\nuse Laminas\\Diactoros\\ResponseFactory;\n\n$app = new MiddlewarePipe();\n$app-&gt;pipe(new ExampleMiddleware());\n$app-&gt;pipe(new RequestHandlerMiddleware(new ExampleHandler()));\n\n$request = ServerRequestFactory::fromGlobals();\n$response = $app-&gt;handle($request);\n\n// Emit respons\n$emitter = new \\Laminas\\HttpHandlerRunner\\Emitter\\SapiEmitter();\n$emitter-&gt;emit($response);\n</code></pre> <p>Dalam pengaturan ini, <code>MiddlewarePipe</code> menangani tumpukan middleware, dan setiap komponen middleware dapat memproses permintaan dan menghasilkan response atau meneruskan permintaan ke middleware berikutnya. <code>RequestHandlerMiddleware</code> membungkus request handler terakhir.</p> <p>Contoh ini menggunakan komponen Laminas (sebelumnya Zend) untuk menangani pesan HTTP dan dispatching middleware, tetapi pola serupa berlaku dengan pustaka lain yang kompatibel dengan PSR-7 dan PSR-15.</p> </li> </ol>"},{"location":"psr/psr-16/","title":"6.12 PSR-16 Simple Cache","text":"<p>PSR-16 adalah standar PHP-FIG (PHP Framework Interoperability Group) yang mendefinisikan antarmuka caching sederhana. PSR adalah singkatan dari \"PHP Standard Recommendation,\" dan PSR-16 secara khusus menguraikan sebuah antarmuka yang konsisten dan sederhana untuk operasi caching. PSR-16 berfokus pada penyediaan API yang minimalis untuk mengelola cache.</p>"},{"location":"psr/psr-16/#6121-antarmuka-utama","title":"6.12.1 Antarmuka Utama","text":"<p>PSR-16 mendefinisikan <code>Psr\\SimpleCache\\CacheInterface</code>, yang berisi metode dasar untuk operasi cache berikut:</p> <ol> <li> <p><code>get($key, $default = null)</code></p> <p>Fungsi ini mengambil nilai dari cache berdasarkan kunci yang diberikan. Kemudian akan mengembalikan nilai yang di-cache atau nilai default apabila kunci tidak ditemukan.</p> </li> <li> <p><code>set($key, $value, $ttl = null)</code></p> <p>Fungsi yang menyimpan nilai di cache dengan kunci yang diberikan. Dan parameter <code>$ttl</code> (time-to-live) adalah waktu kedaluwarsa dalam detik.</p> </li> <li> <p><code>delete($key)</code> untuk menghapus nilai dari cache berdasarkan kunci yang diberikan.</p> </li> <li><code>clear()</code> digunakan menghapus semua nilai dari cache.</li> <li> <p><code>getMultiple($keys, $default = null)</code></p> <p>Fungsi yang mengambil nilai dari cache berdasarkan beberapa kunci yang diberikan. Dan akan mengembalikan array nilai yang di-cache atau nilai default untuk kunci yang tidak ditemukan.</p> </li> <li> <p><code>setMultiple($values, $ttl = null)</code> akan menyimpan beberapa nilai di cache berdasarkan array pasangan kunci-nilai yang diberikan.</p> </li> <li><code>deleteMultiple($keys)</code> untuk menghapus beberapa nilai dari cache berdasarkan array kunci yang diberikan.</li> <li><code>has($key)</code> fungsi yang digunakan untuk memeriksa apakah kunci tertentu ada di cache.</li> </ol>"},{"location":"psr/psr-16/#6122-contoh-penggunaan","title":"6.12.2 Contoh Penggunaan","text":"<p>Berikut adalah contoh penggunaan PSR-16 pada sebuah aplikasi PHP menggunakan implementasi cache sederhana berbasis array seperti yang telah dijelaskan sebelumnya.</p> <ol> <li> <p>Implementasi cache</p> <pre><code>require 'vendor/autoload.php';\n\nuse Psr\\SimpleCache\\CacheInterface;\n\nclass ArrayCache implements CacheInterface\n{\n    private $cache = [];\n    private $ttl = [];\n\n    public function get($key, $default = null)\n    {\n        if ($this-&gt;has($key)) {\n            return $this-&gt;cache[$key];\n        }\n        return $default;\n    }\n\n    public function set($key, $value, $ttl = null)\n    {\n        $this-&gt;cache[$key] = $value;\n        if ($ttl !== null) {\n            $this-&gt;ttl[$key] = time() + $ttl;\n        }\n        return true;\n    }\n\n    public function delete($key)\n    {\n        unset($this-&gt;cache[$key], $this-&gt;ttl[$key]);\n        return true;\n    }\n\n    public function clear()\n    {\n        $this-&gt;cache = [];\n        $this-&gt;ttl = [];\n        return true;\n    }\n\n    public function getMultiple($keys, $default = null)\n    {\n        $results = [];\n        foreach ($keys as $key) {\n            $results[$key] = $this-&gt;get($key, $default);\n        }\n        return $results;\n    }\n\n    public function setMultiple($values, $ttl = null)\n    {\n        foreach ($values as $key =&gt; $value) {\n            $this-&gt;set($key, $value, $ttl);\n        }\n        return true;\n    }\n\n    public function deleteMultiple($keys)\n    {\n        foreach ($keys as $key) {\n            $this-&gt;delete($key);\n        }\n        return true;\n    }\n\n    public function has($key)\n    {\n        if (isset($this-&gt;ttl[$key]) &amp;&amp; time() &gt; $this-&gt;ttl[$key]) {\n            $this-&gt;delete($key);\n            return false;\n        }\n        return isset($this-&gt;cache[$key]);\n    }\n}\n</code></pre> </li> <li> <p>Mengintegrasikan cache dalam aplikasi</p> <pre><code>// Inisialisasi cache\n$cache = new ArrayCache();\n\n// Setel nilai di cache\n$key = 'user_123';\n$value = ['name' =&gt; 'John Doe', 'email' =&gt; 'john@example.com'];\n$ttl = 3600; // 1 jam\n$cache-&gt;set($key, $value, $ttl);\n\n// Ambil nilai dari cache\n$cachedUser = $cache-&gt;get($key);\nif ($cachedUser !== null) {\n    echo \"User found in cache: \" . print_r($cachedUser, true);\n} else {\n    echo \"User not found in cache, fetching from database...\";\n    // Logika untuk mengambil data dari database\n}\n\n// Menghapus nilai dari cache\n$cache-&gt;delete($key);\n\n// Menggunakan multiple cache methods\n$cache-&gt;setMultiple([\n    'user_1' =&gt; ['name' =&gt; 'Alice', 'email' =&gt; 'alice@example.com'],\n    'user_2' =&gt; ['name' =&gt; 'Bob', 'email' =&gt; 'bob@example.com']\n], $ttl);\n\n$users = $cache-&gt;getMultiple(['user_1', 'user_2']);\necho \"Users: \" . print_r($users, true);\n\n$cache-&gt;deleteMultiple(['user_1', 'user_2']);\n</code></pre> </li> </ol>"},{"location":"psr/psr-16/#6123-manfaat-penggunaan","title":"6.12.3 Manfaat Penggunaan","text":"<p>PSR-16 bertujuan untuk menyediakan antarmuka caching yang sederhana dan konsisten, yang memungkinkan pengembang untuk mengintegrasikan mekanisme caching pada aplikasi mereka dengan mudah. Beberapa permasalahan utama pada PSR-16 yang menjadi prioritas dalam penyelesaiannya meliputi:</p> <ol> <li> <p>Penghematan sumber daya</p> <p>Mengurangi beban pada sumber daya seperti basis data dan API eksternal dengan menyimpan data sementara pada cache.</p> </li> <li> <p>Peningkatan performa</p> <p>Mempercepat akses data dengan mengambil data dari cache yang cepat daripada harus memproses ulang atau mengambil dari sumber yang lebih lambat.</p> </li> <li> <p>Interoperabilitas</p> <p>Menstandarisasi antarmuka caching sehingga berbagai library dan framework dapat bekerja bersama-sama tanpa perlu penyesuaian besar.</p> </li> <li> <p>Kemudahan penggunaan</p> <p>Menyediakan API yang sederhana dan intuitif sehingga pengembang dapat dengan cepat dan mudah mengimplementasikan caching dalam aplikasi mereka.</p> </li> </ol>"},{"location":"psr/psr-17/","title":"6.7 PSR-17 HTTP Factories","text":"<p>PSR-17 menyediakan antarmuka untuk membuat objek HTTP yang sering digunakan pada aplikasi web berbasis PHP. Antarmuka ini berguna untuk mengabstraksi pembuatan objek HTTP dari logika aplikasi utama, sehingga mempermudah interoperabilitas antar framework atau library.</p>"},{"location":"psr/psr-17/#671-antarmuka","title":"6.7.1 Antarmuka","text":"<p>Setiap antarmuka ini mempermudah pengelolaan objek-objek HTTP pada aplikasi PHP dengan cara yang konsisten dan dapat digunakan secara lintas library. Antarmuka utama dalam PSR-17 meliputi:</p> Antarmuka Objek yang Dibuat Kegunaan RequestFactoryInterface Request Membuat permintaan HTTP untuk komunikasi keluar. ResponseFactoryInterface Response Membuat tanggapan HTTP untuk dikirim ke klien. ServerRequestFactoryInterface ServerRequest Membuat permintaan HTTP yang diterima oleh server. StreamFactoryInterface Stream Membuat aliran data, seperti membaca/menulis file atau data HTTP. UploadedFileFactoryInterface UploadedFile Membuat representasi file yang diunggah. UriFactoryInterface URI Membuat dan mengelola URI untuk permintaan HTTP."},{"location":"psr/psr-17/#672-cara-implementasi","title":"6.7.2 Cara Implementasi","text":"<p>Untuk menggunakan PSR-17, diperlukan library yang mengimplementasikan antarmuka tersebut. Salah satu library populer adalah nyholm/psr7. Dengan menambahkan dependensi library menggunakan Composer:</p> <pre><code>composer require nyholm/psr7\n</code></pre> <ol> <li> <p>Membuat request (RequestFactoryInterface)</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr7\\Factory\\Psr17Factory;\n\n$factory = new Psr17Factory();\n\n// Membuat Request HTTP GET ke URL tertentu\n$request = $factory-&gt;createRequest('GET', 'https://example.com');\n\n// Menambahkan header ke Request\n$request = $request-&gt;withHeader('Authorization', 'Bearer token123');\n\necho $request-&gt;getMethod(); // GET\necho $request-&gt;getUri();    // https://example.com\n</code></pre> </li> <li> <p>Membuat response (ResponseFactoryInterface)</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr7\\Factory\\Psr17Factory;\n\n$factory = new Psr17Factory();\n\n// Membuat Response dengan status 200 OK\n$response = $factory-&gt;createResponse(200);\n\n// Menambahkan konten ke Response\n$response = $response-&gt;withBody($factory-&gt;createStream('Hello, World!'));\n$response = $response-&gt;withHeader('Content-Type', 'text/plain');\n\necho $response-&gt;getStatusCode(); // 200\necho $response-&gt;getBody();       // Hello, World!\n</code></pre> </li> <li> <p>Membuat serverRequest (ServerRequestFactoryInterface)</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr7\\Factory\\Psr17Factory;\n\n$factory = new Psr17Factory();\n\n// Membuat ServerRequest dengan metode POST\n$serverRequest = $factory-&gt;createServerRequest('POST', 'https://example.com');\n\n// Menambahkan parameter query\n$serverRequest = $serverRequest-&gt;withQueryParams(['key' =&gt; 'value']);\n\necho $serverRequest-&gt;getMethod();            // POST\necho $serverRequest-&gt;getQueryParams()['key']; // value\n</code></pre> </li> <li> <p>Membuat stream (StreamFactoryInterface)</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr7\\Factory\\Psr17Factory;\n\n$factory = new Psr17Factory();\n\n// Membuat stream dari string\n$stream = $factory-&gt;createStream('Isi data stream.');\n\n// Membuat stream dari file\n$fileStream = $factory-&gt;createStreamFromFile('/path/to/file.txt', 'r');\n\necho $stream-&gt;getContents(); // Isi data stream.\n</code></pre> </li> <li> <p>Membuat uploadedFile (UploadedFileFactoryInterface)</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr7\\Factory\\Psr17Factory;\n\n$factory = new Psr17Factory();\n\n// Membuat UploadedFile dari stream\n$stream = $factory-&gt;createStream('file content');\n$uploadedFile = $factory-&gt;createUploadedFile($stream, 1234, UPLOAD_ERR_OK, 'example.txt', 'text/plain');\n\necho $uploadedFile-&gt;getClientFilename(); // example.txt\necho $uploadedFile-&gt;getSize();           // 1234\n</code></pre> </li> <li> <p>Membuat URI (UriFactoryInterface)</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr7\\Factory\\Psr17Factory;\n\n$factory = new Psr17Factory();\n\n// Membuat URI\n$uri = $factory-&gt;createUri('https://example.com/path?query=value');\n\necho $uri-&gt;getScheme(); // https\necho $uri-&gt;getHost();   // example.com\necho $uri-&gt;getPath();   // /path\n</code></pre> </li> </ol>"},{"location":"psr/psr-17/#673-keuntungan","title":"6.7.3 Keuntungan","text":"<ol> <li>Konsistensi: Menyediakan antarmuka standar untuk membuat objek HTTP.</li> <li>Interoperabilitas: Mempermudah integrasi antar library dan framework.</li> <li>Fleksibilitas: Memungkinkan penggantian implementasi objek HTTP tanpa memengaruhi logika aplikasi.</li> </ol>"},{"location":"psr/psr-18/","title":"6.8 PSR-18 HTTP Client","text":"<p>PSR-18 merupakan standar interface untuk library client HTTP di PHP. Standar ini bertujuan untuk menyederhanakan proses interaksi dengan server HTTP dan memfasilitasi interoperabilitas antar library client HTTP yang berbeda. Dengan mengikuti PSR-18, diharapkan dapat menciptakan aplikasi yang lebih terstruktur, mudah dipelihara, dan dapat berinteraksi dengan berbagai komponen lainnya dengan lebih baik.</p>"},{"location":"psr/psr-18/#681-prinsip-dasar-psr-18","title":"6.8.1 Prinsip Dasar PSR-18:","text":"<ol> <li> <p>Interface client</p> <p>Mendefinisikan interface <code>Psr\\Http\\Client\\ClientInterface</code> yang harus diimplementasikan oleh semua library client HTTP. Interface ini menyediakan metode untuk membuat dan mengirim permintaan HTTP, serta menerima dan memproses respons HTTP.</p> </li> <li> <p>Permintaan HTTP</p> <p>Mendefinisikan interface <code>Psr\\Http\\Message\\RequestInterface</code> untuk mewakili permintaan HTTP. Interface ini menyediakan metode untuk mendapatkan informasi tentang permintaan, seperti URL, metode HTTP, header, dan badan permintaan</p> </li> <li> <p>Response HTTP</p> <p>Mendefinisikan interface <code>Psr\\Http\\Message\\ResponseInterface</code> untuk mewakili respons HTTP. Interface ini menyediakan metode untuk mendapatkan informasi tentang respons, seperti status code, header, dan badan respons.</p> </li> <li> <p>Stream Pesan:</p> <p>Mendukung penggunaan stream untuk membaca dan menulis badan pesan HTTP.</p> </li> </ol> <p>Contoh Implementasi PSR-18 dalam kode:</p> <pre><code>use Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\n\nclass MyHttpClient implements ClientInterface\n{\n    public function sendRequest(RequestInterface $request): Promise\n    {\n        // Buat dan kirim permintaan HTTP\n        $curl = curl_init($request-&gt;getUri()-&gt;__toString());\n        curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $request-&gt;getMethod());\n        curl_setopt($curl, CURLOPT_HTTPHEADER, $request-&gt;getHeaders());\n        curl_setopt($curl, CURLOPT_POSTFIELDS, $request-&gt;getBody()-&gt;getContents());\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n\n        $response = curl_exec($curl);\n        curl_close($curl);\n\n        // Buat dan kembalikan Promise untuk respons HTTP\n        $promise = new Promise(function ($resolve, $reject) use ($response) {\n            if ($response === false) {\n                $reject(new Exception('CURL error: ' . curl_error($curl)));\n                return;\n            }\n\n            $statusLine = trim(fgets($response));\n            $statusCode = (int) explode(' ', $statusLine)[1];\n\n            $headers = [];\n            while (($line = fgets($response)) !== false) {\n                if (strlen(trim($line)) === 0) {\n                    break;\n                }\n\n                $parts = explode(':', $line, 2);\n                $headers[trim($parts[0])] = trim($parts[1]);\n            }\n\n            $responseBody = stream_get_contents($response);\n\n            $httpResponse = new Response($statusCode, $headers, $responseBody);\n            $resolve($httpResponse);\n        });\n\n        return $promise;\n    }\n}\n\n// Contoh penggunaan\n$httpClient = new MyHttpClient();\n$request = new Request('GET', 'https://example.com');\n\n$promise = $httpClient-&gt;sendRequest($request);\n$promise-&gt;then(function (ResponseInterface $response) {\n    echo \"Status code: \" . $response-&gt;getStatusCode() . \"\\n\";\n    echo \"Content: \" . $response-&gt;getBody()-&gt;getContents() . \"\\n\";\n});\n</code></pre>"},{"location":"psr/psr-18/#682-manfaat","title":"6.8.2 Manfaat","text":"<p>Adapun manfaat dari penerapan PSR-18 adalah sebagai berikut:</p> <ol> <li>Meningkatkan keterbacaan dan organisasi kode HTTP karena telah konsisten sesuai standar.</li> <li>Mempermudah integrasi dengan library HTTP pihak ketiga selama mengikuti interface yang sama.</li> <li>Memisahkan logika HTTP dari aplikasi sehingga dapat digunakan oleh class lainnya dalam satu aplikasi.</li> <li>Mendukung pengujian unit dan integrasi yang lebih mudah.</li> </ol>"},{"location":"psr/psr-18/#683-kelemahan","title":"6.8.3 Kelemahan","text":"<p>Meskipun disarankan untuk menggunakan PSR-18, namun PSR-18 masih memiliki beberapa kendal, antar lain:</p> <ol> <li>Standar ini masih tergolong baru dan belum diadopsi secara luas.</li> <li>Beberapa library HTTP populer belum mendukung PSR-18 secara penuh.</li> <li>Implementasi PSR-18 yang berbeda mungkin memiliki cara kerja yang berbeda.</li> </ol>"},{"location":"psr/psr-19/","title":"6.15 PSR-19 PHPDoc Tags","text":"<p>PSR-19 ****adalah standar untuk tag PHPDoc di PHP yang bertujuan untuk menyederhanakan dokumentasi kode PHP dengan menyediakan kumpulan tag standar dan konsisten. Dengan menerapkan PSR-19 diharapkan dapat meningkatkan kualitas dokumentasi kode sehingga lebih mudah dipahami dan digunakan oleh orang lain maupun tools documentor (alat otomatis).</p>"},{"location":"psr/psr-19/#6151-prinsip-dasar-psr-19","title":"6.15.1 Prinsip Dasar PSR-19","text":"<p>Adapun prinsip dasar pada PSR-19 adalah sebagai berikut:</p> <ol> <li>Menyediakan tag standar untuk mendeskripsikan berbagai aspek kode, seperti kelas, fungsi, parameter, jenis data, pengecualian, dan catatan.</li> <li>Menetapkan format tag yang konsisten dengan tanda <code>@</code> di awal baris, diikuti nama tag, dan parameter opsional.</li> <li>Mendorong dokumentasi yang jelas, ringkas, dan informatif untuk memudahkan pemahaman developer lain.</li> </ol>"},{"location":"psr/psr-19/#6152-manfaat","title":"6.15.2 Manfaat","text":"<p>Berbagai manfaat PSR-19 ini diantaranya yaitu:</p> <ol> <li>Meningkatkan keterbacaan dan organisasi dokumentasi kode.</li> <li>Memudahkan pemahaman kode oleh developer lain.</li> <li>Mendukung konsistensi dokumentasi antar project.</li> <li>Memudahkan integrasi dengan tools dokumentasi.</li> </ol>"},{"location":"psr/psr-19/#6153-kelemahan","title":"6.15.3 Kelemahan","text":"<p>Kelemahan PSR-19 diantaranya adalah:</p> <ol> <li>Standar ini masih dalam tahap draft dan belum resmi diadopsi.</li> <li>Beberapa tools dokumentasi mungkin belum mendukung PSR-19 secara penuh.</li> <li>Implementasi PSR-19 yang berbeda mungkin memiliki cara penulisan yang berbeda.</li> </ol> <p>Berikut merupakan daftar tag yang sering digunakan dalam PHPDocs:</p> Tag Metadata Deskripsi Contoh Penggunaan Lokasi Penggunaan <code>@author</code> Menyebutkan nama atau informasi penulis dari elemen kode. <code>@author Emiliano Purnomo &lt;emiliano.purnomo@example.com&gt;</code> class, method, file <code>@copyright</code> Menyatakan informasi hak cipta terkait elemen kode. <code>@copyright 2024 Company Name</code> class, file <code>@deprecated</code> Menandai elemen kode yang tidak lagi direkomendasikan untuk digunakan. <code>@deprecated Sejak versi 2.0. Gunakan fungsi newFunction()</code> class, method, property <code>@example</code> Memberikan contoh penggunaan kode. <code>@example /path/to/example.php</code> class, method, property <code>@global</code> Menjelaskan variabel global yang digunakan dalam elemen kode. <code>@global string $config</code> class, file <code>@ignore</code> Menandai elemen kode untuk diabaikan dalam pembuatan dokumentasi. <code>@ignore</code> class, method, property <code>@license</code> Menyebutkan informasi lisensi elemen kode. <code>@license MIT</code> class, file <code>@link</code> Menyertakan tautan ke sumber eksternal terkait elemen kode. <code>@link &lt;https://example.com/&gt;</code> class, method, property <code>@method</code> Mendefinisikan metode ajaib (magic method) yang tidak ada secara eksplisit di kelas. <code>@method string getName()</code> class <code>@package</code> Menentukan paket tempat elemen kode berada (biasanya untuk struktur aplikasi). <code>@package MyLibrary</code> class <code>@param</code> Menjelaskan parameter fungsi atau metode. <code>@param int $a Bilangan pertama.</code> method <code>@property</code> Mendefinisikan properti ajaib (magic property) di kelas. <code>@property string $name</code> class <code>@return</code> Menjelaskan tipe data yang dikembalikan oleh fungsi atau metode. <code>@return int Hasil penjumlahan.</code> method <code>@see</code> Menunjuk elemen kode lain yang relevan atau terkait. <code>@see AnotherClass::methodName()</code> class, method <code>@since</code> Menyatakan kapan elemen kode diperkenalkan. <code>@since 1.0.0</code> class, method, property <code>@throws</code> Menyebutkan jenis pengecualian yang bisa dilemparkan oleh fungsi atau metode. <code>@throws \\\\InvalidArgumentException</code> method <code>@todo</code> Menandai bagian kode yang perlu diperbaiki atau dikembangkan lebih lanjut. <code>@todo Tambahkan validasi input.</code> class, method, property <code>@uses</code> Menunjuk elemen kode lain yang digunakan oleh elemen kode saat ini. <code>@uses HelperClass</code> class, method <code>@var</code> Menjelaskan tipe variabel properti atau lokal dalam elemen kode. <code>@var string</code> property, variable <code>@version</code> Menyebutkan versi elemen kode. <code>@version 1.2.3</code> class, method, property <p>Berikut adalah contoh implementasi tag PHPDoc yang sesuai dengan standar PSR-19:</p> <pre><code>/**\n * Kelas yang mewakili sebuah produk.\n *\n * @author John Doe &lt;johndoe@example.com&gt;\n * @version 1.0.0\n * @since 2024-06-13\n */\nclass Product\n{\n    /**\n     * Nama produk.\n     *\n     * @var string\n     */\n    private $name;\n\n    /**\n     * Harga produk.\n     *\n     * @var float\n     */\n    private $price;\n\n    /**\n     * Konstruktor untuk kelas Product.\n     *\n     * @param string $name Nama produk\n     * @param float $price Harga produk\n     * @throws Exception Jika nama produk kosong\n     */\n    public function __construct($name, $price)\n    {\n        if (empty($name)) {\n            throw new Exception('Nama produk tidak boleh kosong');\n        }\n\n        $this-&gt;name = $name;\n        $this-&gt;price = $price;\n    }\n\n    /**\n     * Mendapatkan nama produk.\n     *\n     * @return string Nama produk\n     */\n    public function getName(): string\n    {\n        return $this-&gt;name;\n    }\n\n    /**\n     * Mengatur nama produk.\n     *\n     * @param string $name Nama produk baru\n     */\n    public function setName(string $name): void\n    {\n        $this-&gt;name = $name;\n    }\n\n    /**\n     * Mendapatkan harga produk.\n     *\n     * @return float Harga produk\n     */\n    public function getPrice(): float\n    {\n        return $this-&gt;price;\n    }\n\n    /**\n     * Mengatur harga produk.\n     *\n     * @param float $price Harga produk baru\n     */\n    public function setPrice(float $price): void\n    {\n        $this-&gt;price = $price;\n    }\n}\n</code></pre> <p>Keterangan:</p> <p><code>@author</code> digunakan untuk mencantumkan nama dan email penulis kode.</p> <p><code>@version</code> digunakan untuk mencantumkan versi kode.</p> <p>**<code>@since</code>:**digunakan untuk mencantumkan tanggal atau versi PHP minimum yang dibutuhkan untuk menjalankan kode.</p> <p><code>@var</code> digunakan untuk mencantumkan tipe data variabel.</p> <p><code>@param</code> digunakan untuk mendeskripsikan parameter fungsi, termasuk nama parameter, tipe data, dan deskripsi singkat.</p> <p><code>@throws</code> digunakan untuk mendeskripsikan pengecualian yang mungkin terjadi pada fungsi.</p> <p><code>@return</code> digunakan untuk mendeskripsikan nilai balik fungsi, termasuk tipe data dan deskripsi singkat.</p>"},{"location":"psr/psr-20/","title":"6.16 PSR-20 Clock","text":"<p>PSR-20 adalah standar yang dirancang untuk menyediakan antarmuka seragam dalam menangani waktu pada aplikasi PHP. Dengan PSR-20 pengelolaan waktu menjadi lebih fleksibel, terutama untuk kebutuhan pengujian dan pengaturan waktu dinamis.</p>"},{"location":"psr/psr-20/#6161-clockinterface","title":"6.16.1 ClockInterface","text":"<p>PSR-20 mendefinisikan antarmuka <code>ClockInterface</code>, yang menyediakan metode <code>now()</code> untuk mendapatkan waktu saat ini dalam bentuk objek <code>DateTimeImmutable</code>. Standar ini memungkinkan aplikasi menggunakan implementasi waktu yang dapat disesuaikan sesuai kebutuhan, baik untuk pengembangan maupun pengujian. Antarmuka <code>ClockInterface</code> didefinisikan sebagai berikut:</p> <pre><code>&lt;?php\n\nnamespace Psr\\Clock;\n\nuse DateTimeImmutable;\n\ninterface ClockInterface\n{\n    /**\n     * Mengembalikan waktu saat ini sebagai objek DateTimeImmutable.\n     *\n     * @return DateTimeImmutable\n     */\n    public function now(): DateTimeImmutable;\n}\n</code></pre>"},{"location":"psr/psr-20/#6162-cara-implementasi","title":"6.16.2 Cara Implementasi","text":"<p>Berikut ini merupakan berbagai cara dalam pengimplementasian PSR-20:</p> <ol> <li> <p>Menggunakan library pihak ketiga yang mendukung PSR-20</p> <p>Apabila terdapat library pihak ketiga yang mendukung PSR-20, instalasi dapat dilakukan menggunakan Composer. Contoh library seperti <code>nyholm/psr20</code>, dengan langkah-langkah sebagai berikut:</p> <ol> <li> <p>Jalankan perintah berikut untuk menginstal library melalui Composer</p> <pre><code>composer require nyholm/psr20\n</code></pre> </li> <li> <p>Setelah instalasi, library akan ditambahkan ke direktori <code>vendor/</code></p> </li> <li> <p>Tambahkan <code>autoload.php</code> dari Composer ke file PHP</p> <pre><code>require 'vendor/autoload.php';\n</code></pre> </li> <li> <p>Gunakan implementasi <code>ClockInterface</code> yang disediakan library</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr20\\SystemClock;\n\n$clock = new SystemClock();\necho \"Waktu saat ini: \" . $clock-&gt;now()-&gt;format('Y-m-d H:i:s');\n</code></pre> </li> </ol> </li> <li> <p>Membuat implementasi PSR-20 sendiri</p> <p>Langkah-langkahnya sebagai berikut:</p> <ol> <li> <p>Definisikan antarmuka <code>ClockInterface</code> Buatlah file untuk mendefinisikan antarmuka di lokasi seperti <code>src/Contracts/ClockInterface.php</code>.</p> <pre><code>&lt;?php\n\nnamespace App\\Contracts;\n\nuse DateTimeImmutable;\n\ninterface ClockInterface\n{\n    /**\n     * Mengembalikan waktu saat ini sebagai objek DateTimeImmutable.\n     *\n     * @return DateTimeImmutable\n     */\n    public function now(): DateTimeImmutable;\n}\n</code></pre> </li> <li> <p>Implementasi waktu sistem</p> <p>Buatlah kelas yang mengimplementasikan <code>ClockInterface</code> untuk mendapatkan waktu dari sistem. Kemudian simpan di <code>src/Services/SystemClock.php</code>.</p> <pre><code>&lt;?php\n\nnamespace App\\Services;\n\nuse App\\Contracts\\ClockInterface;\nuse DateTimeImmutable;\n\nclass SystemClock implements ClockInterface\n{\n    public function now(): DateTimeImmutable\n    {\n        return new DateTimeImmutable();\n    }\n}\n</code></pre> </li> <li> <p>Implementasi waktu tetap (opsional) Untuk kebutuhan pengujian, waktu tetap dapat digunakan. Dan simpan file di <code>src/Services/FixedClock.php</code>.</p> <pre><code>&lt;?php\n\nnamespace App\\Services;\n\nuse App\\Contracts\\ClockInterface;\nuse DateTimeImmutable;\n\nclass FixedClock implements ClockInterface\n{\n    private DateTimeImmutable $fixedTime;\n\n    public function __construct(DateTimeImmutable $time)\n    {\n        $this-&gt;fixedTime = $time;\n    }\n\n    public function now(): DateTimeImmutable\n    {\n        return $this-&gt;fixedTime;\n    }\n}\n</code></pre> </li> <li> <p>Implementasi</p> <p>Setelah implementasi selesai, pilihlah salah satu kelas <code>ClockInterface</code> sesuai kebutuhan.</p> <pre><code>&lt;?php\n\nuse App\\Services\\SystemClock;\n\n$clock = new SystemClock();\necho \"Waktu sistem: \" . $clock-&gt;now()-&gt;format('Y-m-d H:i:s');\n</code></pre> <pre><code>&lt;?php\n\nuse App\\Services\\FixedClock;\nuse DateTimeImmutable;\n\n$fixedTime = new DateTimeImmutable('2024-12-15 12:00:00');\n$clock = new FixedClock($fixedTime);\n\necho \"Waktu tetap: \" . $clock-&gt;now()-&gt;format('Y-m-d H:i:s');\n</code></pre> </li> </ol> </li> </ol>"},{"location":"psr/psr-20/#6163-kapan-harus-menggunakan-psr-20","title":"6.16.3 Kapan Harus Menggunakan PSR-20?","text":"<p>PSR-20 sangat berguna dalam skenario berikut:</p> <ol> <li>Aplikasi dengan ketergantungan waktu Contohnya pada sistem yang memerlukan timestamp untuk transaksi atau log.</li> <li> <p>Pengujian unit</p> <p>Dalam pengujian, waktu tetap memudahkan untuk menguji logika yang bergantung pada waktu tertentu. Misalnya menguji apakah fungsi berlaku pada jam kerja tertentu.</p> </li> <li> <p>Dependency injection</p> <p>Dalam hal ini kita dapat menyuntikkan sumber waktu (clock) yang berbeda ke dalam aplikasi sesuai dengan kebutuhan.</p> </li> </ol>"},{"location":"psr/psr-20/#6164-keuntungan","title":"6.16.4 Keuntungan","text":"<ol> <li>Fleksibilitas, mengacu pada sumber waktu yang dapat diubah tanpa memengaruhi logika utama aplikasi.</li> <li>Konsistensi, dengan implementasi waktu tetap, pengujian logika yang bergantung pada waktu menjadi lebih mudah.</li> <li>Testability, PSR-20 ini menjadikan kode lebih kompatibel dengan library atau framework lain.</li> </ol>"},{"location":"psr/psr-3/","title":"6.4 PSR-3 Antarmuka Logger","text":"<p>PSR-3 adalah standar yang mendefinisikan antarmuka universal untuk library logging di PHP. Tujuannya adalah membuat aplikasi dan library dapat menulis log dengan cara yang konsisten, mudah, dan fleksibel.</p> <p>Mengapa PSR-3 penting?</p> <ol> <li>Universal: library atau framework dapat bekerja dengan logger apapun yang mendukung PSR-3.</li> <li>Kemudahan: apabila aplikasi menggunakan PSR-3, maka bisa mengganti sistem logging tanpa mengubah kode log.</li> <li>Sentralisasi Log: semua log aplikasi, library pihak ketiga, dan framework dapat digabungkan dalam satu tempat.</li> </ol>"},{"location":"psr/psr-3/#641-loggerinterface","title":"6.4.1 LoggerInterface","text":"<p>PSR-3 mendefinisikan antarmuka umum untuk library logging. Tujuan utamanya adalah memungkinkan library atau framework menerima antarmuka bernama <code>LoggerInterface</code> dan menulis log dengan cara yang sederhana serta universal. Semua library logging yang mengikuti PSR-3 harus mengimplementasikan antarmuka ini. LoggerInterface menyediakan 8 metode utama yang sesuai dengan level log standar dari RFC 5424:</p> <ol> <li>Emergency: sistem tidak bisa digunakan (contoh: seluruh aplikasi down).</li> <li>Alert: aksi segera diperlukan (contoh: database hilang).</li> <li>Critical: kesalahan kritis yang memengaruhi sistem inti (contoh: exception penting).</li> <li>Error: kesalahan runtime yang tidak memerlukan aksi langsung.</li> <li>Warning: peringatan (contoh: penggunaan API yang salah).</li> <li>Notice: peristiwa normal tapi signifikan (contoh: konfigurasi berubah).</li> <li>Info: informasi umum (contoh: pengguna berhasil login).</li> <li>Debug: informasi rinci untuk debugging.</li> </ol> <p>Terdapat juga metode tambahan <code>log()</code> yang digunakan untuk menulis log dengan level yang ditentukan secara dinamis yaitu menerima level log sebagai argumen pertama dan apabila level log yang diberikan tidak dikenali, maka harus melemparkan <code>Psr\\Log\\InvalidArgumentException</code>.</p>"},{"location":"psr/psr-3/#642-pesan","title":"6.4.2 Pesan","text":"<p>Pesan ini terdiri atas:</p> <ul> <li>Pesan Log**:** setiap metode menerima pesan berupa string atau objek yang memiliki metode <code>__toString()</code>.</li> <li>Placeholder digunakan dalam pesan log, yang akan diganti dengan nilai dari konteks (<code>context</code>).</li> </ul> <p>Contoh:</p> <pre><code>$logger-&gt;error('Kesalahan pada {file}', ['file' =&gt; 'config.php']);\n</code></pre> <pre><code>Kesalahan pada config.php\n</code></pre> <p>Format placeholder:</p> <ul> <li>Ditulis dengan kurung kurawal <code>{...}</code>.</li> <li>Hanya diperbolehkan menggunakan karakter huruf, angka, garis bawah <code>_</code>, atau titik <code>.</code>.</li> </ul>"},{"location":"psr/psr-3/#643-konteks-context","title":"6.4.3 Konteks (Context)","text":"<p>Konteks adalah array tambahan untuk menyimpan data yang relevan dengan log. Misalnya, nama pengguna, ID, atau data tambahan lainnya. Apabila konteks memiliki key <code>'exception'</code>, maka nilai ini harus berupa objek Exception untuk menangkap stack trace.</p> <p>Contoh penggunaan konteks:</p> <pre><code>$logger-&gt;critical('Kesalahan terjadi', ['exception' =&gt; new Exception('Fatal error')]);\n</code></pre>"},{"location":"psr/psr-3/#644-kelas-dan-trait-bantu-helper","title":"6.4.4 Kelas dan Trait Bantu (Helper)","text":"<p>PSR-3 menyediakan kelas dan trait berikut untuk mempermudah implementasi:</p> <ol> <li>AbstractLogger: mempermudah implementasi dengan hanya mewajibkan untuk mengimplementasikan metode <code>log()</code>.</li> <li>LoggerTrait: memungkinkan untuk menggunakan semua metode log hanya dengan mengimplementasikan metode <code>log()</code>.</li> <li>NullLogger: logger \u201ckosong\u201d yang tidak menghasilkan apa-apa. Hal tersebut berguna sebagai fallback.</li> <li>LoggerAwareInterface: antarmuka untuk kelas yang membutuhkan logger. Contoh metode <code>setLogger(LoggerInterface $logger);</code>.</li> <li>LoggerAwareTrait: trait untuk mempermudah implementasi <code>LoggerAwareInterface</code>.</li> <li>LogLevel: kelas ini mendefinisikan konstanta level log seperti <code>LogLevel::ERROR</code>, <code>LogLevel::DEBUG</code>.</li> </ol> <p>Contoh LoggerInterface sesuai PSR-3:</p> <pre><code>namespace Psr\\Log;\n\ninterface LoggerInterface\n{\n    public function emergency($message, array $context = array());\n    public function alert($message, array $context = array());\n    public function critical($message, array $context = array());\n    public function error($message, array $context = array());\n    public function warning($message, array $context = array());\n    public function notice($message, array $context = array());\n    public function info($message, array $context = array());\n    public function debug($message, array $context = array());\n    public function log($level, $message, array $context = array());\n}\n</code></pre> <p>Contoh LoggerAwareInterface:</p> <p>Antarmuka ini memungkinkan kelas menerima logger dari luar.</p> <pre><code>namespace Psr\\Log;\n\ninterface LoggerAwareInterface\n{\n    public function setLogger(LoggerInterface $logger);\n}\n</code></pre> <p>Contoh Konstanta LogLevel:</p> <pre><code>namespace Psr\\Log;\n\nclass LogLevel\n{\n    const EMERGENCY = 'emergency';\n    const ALERT     = 'alert';\n    const CRITICAL  = 'critical';\n    const ERROR     = 'error';\n    const WARNING   = 'warning';\n    const NOTICE    = 'notice';\n    const INFO      = 'info';\n    const DEBUG     = 'debug';\n}\n</code></pre> <p>Untuk setiap pengembangan sistem informasi wajib menerapkan mekanisme logging dengan standar PSR-3 agar lebih seragam dan mudah dipahami.</p>"},{"location":"psr/psr-4/","title":"6.3 PSR-4 Autoloader","text":"<p>Autoloader adalah cara otomatis untuk memuat file kelas, interface, atau trait di PHP tanpa harus menggunakan require atau include secara manual. Dengan autoloader, PHP akan mencari dan memuat file yang sesuai dengan kelas yang dipanggil berdasarkan aturan tertentu.</p> <p>PSR-4 adalah standar yang menjelaskan bagaimana file PHP harus diorganisir agar dapat dimuat secara otomatis oleh autoloader. Standar ini memastikan kode yang digunakan konsisten dan mudah digunakan pada berbagai proyek atau framework.</p>"},{"location":"psr/psr-4/#631-tujuan","title":"6.3.1 Tujuan","text":"<p>Berikut merupakan beberapa tujuan dari autoloading standard:</p> <ul> <li>Konsistensi autoloading karena dilakukan dengan cara yang seragam</li> <li>Mengurangi penggunaan include atau require secara manual</li> <li>Mengatur struktur direktori yang jelas agar sesuai dengan namespace untuk memudahkan navigasi</li> <li>Interoperabilitas, yaitu memungkinkan integrasi yang lebih baik antar proyek atau library PHP lainnya karena standar yang sama.</li> </ul>"},{"location":"psr/psr-4/#632-penamaan-kelas","title":"6.3.2 Penamaan Kelas","text":"<p>Nama kelas lengkap (fully qualified class name) mengikuti struktur berikut:</p> <pre><code>\\VendorNamespace\\SubNamespace\\ClassName\n</code></pre> <p>Keterangan:</p> <p>VendorNamespace: Nama utama (contohnya: <code>Acme</code> atau <code>Symfony</code>).</p> <p>SubNamespace: Folder tambahan dalam namespace.</p> <p>ClassName: Nama file yang akan dimuat.</p>"},{"location":"psr/psr-4/#633-hubungan-namespace-dan-struktur-folder","title":"6.3.3 Hubungan Namespace dan Struktur Folder","text":"<p>Namespace diterjemahkan sebagai struktur folder. Setiap bagian namespace dipisahkan dengan <code>\\</code>, yang menjadi folder di dalam sistem file. Nama file sesuai dengan nama kelas dan harus berakhiran <code>.php</code>.</p> <p>Contoh:</p> <pre><code>\\Acme\\Log\\Writer\\FileWriter\n</code></pre> <p>Keterangan:</p> <p>Namespace <code>Acme\\log\\Writer</code> diterjemahkan ke folder <code>Acme/Log/Writer/</code>. </p> <p>Kelas <code>FileWriter</code> berada di file <code>FileWriter.php</code>.</p>"},{"location":"psr/psr-4/#634-direktori-dasar","title":"6.3.4 Direktori Dasar","text":"<p>Direktori dasar atau Base directory adalah lokasi utama tempat folder namespace dimulai.</p> <p>Misalnya: namespace <code>Acme\\Log\\Writer</code> dengan base directory <code>./src/</code> berarti file <code>FileWriter.php</code> berada di <code>./src/Acme/Log/Writer/FileWriter.php</code>.</p>"},{"location":"psr/psr-4/#635-kondisi-teknis","title":"6.3.5 Kondisi Teknis","text":"<p>Pada kondisi teknis ini, hal yang harus diperhatikan adalah:</p> <ol> <li>Tidak diperbolehkan terdapat Error, dengan kata lain autoloader tidak diperbolehkan menghasilkan error atau exception.</li> <li>Case-Sensitive yaitu nama file dan folder harus sesuai dengan huruf besar/kecil dalam namespace.</li> </ol>"},{"location":"psr/psr-4/#636-contoh-implementasi","title":"6.3.6 Contoh Implementasi","text":"Nama Kelas Lengkap Namespace Prefix Base Directory Path File Hasil <code>\\Acme\\Log\\Writer\\FileWriter</code> <code>Acme\\Log\\Writer</code> <code>./acme-log-writer/lib/</code> <code>./acme-log-writer/lib/FileWriter.php</code> <code>\\Symfony\\Core\\Request</code> <code>Symfony\\Core</code> <code>./vendor/Symfony/Core/</code> <code>./vendor/Symfony/Core/Request.php</code> <p>Autoloader sangat penting karena:</p> <ol> <li>Mengurangi kerumitan karena tidak perlu memuat file secara manual dengan require.</li> <li>Organisasi kode yang baik, memastikan file dan folder terstruktur.</li> <li>Kompabilitas, PSR-4 digunakan oleh banyak framework seperti laravel, symfony, dan composer.</li> </ol> <p>Autoloder membantu pengembang mengelola file secara efisien. Dengan mengikuti standar PSR-4 file dan kelas dalam proyek akan terorganisis dengan baik, mudah ditemukan, dan kompatibel dengan ekosistem PHP modern. Untuk itu wajib dalam sebuah proyek pengembangan sistem menggunakan PHP wajib menerapkan PSR-4.</p>"},{"location":"psr/psr-5/","title":"6.14 PSR-5 PHPDoc Standard","text":"<p>PSR-5 merupakan tata cara penulisan dokumentasi yang lengkap dan sesuai standar menggunakan PHPDoc. Harapannya adalah pengembang dapat membuat dokumentasi yang konsisten, mudah dibaca, dan dapat diproses secara otomatis seperti IDE, generator dokumentasi, maupun alat analisis kode lainnya.  Dalam konteks PHP, PHPDoc, DocBlock, dan DocComment saling berhubungan, tetapi memiliki perbedaan spesifik dalam penggunaan dan terminologinya. </p>"},{"location":"psr/psr-5/#6141-phpdoc","title":"6.14.1. PHPDoc","text":"<p>PHPDoc adalah format \u201cstandar\u201d yang digunakan untuk mendokumentasikan kode PHP. PHPDoc menyediakan aturan dan konvensi tertentu untuk membuat dokumentasi dalam kode PHP agar dapat dipahami oleh manusia maupun alat analisis otomatis seperti IDE (PhpStorm), alat dokumentasi (phpDocumentor), atau alat analisis statis (PHPStan, Psalm). PHPDoc merupakan bagian dari dokumentasi yang memberikan informasi tentang struktur elemen dalam kode PHP yang biasanya diletakkan pada suatu function, method, class, atau property.  Hal penting untuk dipahami bahwa PHPDoc, DocBlock, DocComment adalah hal yang berbeda. </p> <p>Contoh PHPDocs dengan komentar, tag, dan metadata yang telah terstandardisasi:</p> <pre><code>/**\n * Menambahkan dua angka.\n *\n * @param int $a Angka pertama.\n * @param int $b Angka kedua.\n * @return int Hasil penjumlahan.\n */\nfunction add(int $a, int $b): int {\n    return $a + $b;\n}\n</code></pre>"},{"location":"psr/psr-5/#6142-doccomment","title":"6.14.2. DocComment","text":"<p>DocComment adalah istilah umum yang mencakup semua jenis komentar yang ditulis DocBlock. Biasanya PHP dapat mengenali DocComment di dalam DocBlock yang menggunakan format <code>/** ... */</code> (bukan <code>/* ... */</code> atau <code>//</code>yang pada implementasi pengembangan sering dijumpai). Apabila komentar dibuat menggunakan format <code>/* ... */</code> atau <code>//</code>disebut komentar biasa yang tidak dapat dipahami oleh alat dokumentasi (biasanya ditujukan untuk manusia). Komentar biasa umumnya digunakan untuk meninggalkan pesan/penjelasan sebagai pengingat/petunjuk untuk pengembang berikutnya. </p> <p>Berikut aturan penulisan DocComment:</p> <ol> <li>Dimulai dengan barisan karakter\u00a0<code>/**</code>\u00a0kemudiaan diikuti whitespace</li> <li>Diakhiri dengan\u00a0<code>*/</code> </li> <li>Dapat ditulis dalam satu atau beberapa baris</li> </ol> <p>Contoh single line:</p> <pre><code>/** ... */\n</code></pre> <p>Apabila DocComment terdiri labih dari satu baris maka setiap baris harus diikuti dengan karakter <code>(*)</code> yang sejajar dengan klausa pembuka. </p> <p>Contoh multiple line:</p> <pre><code>/**\n * &lt;...&gt;\n * &lt;...&gt;\n */\n</code></pre>"},{"location":"psr/psr-5/#6143-docblock","title":"6.14.3. DocBlock","text":"<p>DocBlock adalah istilah untuk menyebut blok komentar PHPDoc yang digunakan untuk mendokumentasikan elemen kode tertentu, seperti fungsi, kelas, properti, atau file. Karakteristik DocBlock yaitu selalu dimulai dengan <code>/**</code> dan diakhiri dengan <code>*/</code> , serta berada tepat diatas elemen yang didokumentasikan. DocBlock terdiri dari 3 bagian yaitu deskripsi singkat (summary), deskripsi panjang (opsional) dan tag metadata (opsional). Deskripsi singkat berisi penjelasan ringkas tentang elemen kode tersebut dalam 1 atau 2 kalimat. Deskripsi panjang berisi penjelasan lebih rinci tentang elemen kode, termasuk konteks, asumsi, atau contoh penggunaan.</p> <p>Contoh lengkap DocBlock:</p> <pre><code>/**\n * Kelas untuk menghitung operasi matematika.\n *\n * @author Emiliano Purnomo\n * @since 1.0.0\n */\nclass Calculator {\n    /**\n     * @var int Menyimpan hasil terakhir.\n     */\n    private int $result;\n\n    /**\n     * Menambahkan dua angka.\n     *\n     * @param int $a Angka pertama.\n     * @param int $b Angka kedua.\n     * @return int Hasil penjumlahan.\n     */\n    public function add(int $a, int $b): int {\n        $this-&gt;result = $a + $b;\n        return $this-&gt;result;\n    }\n}\n</code></pre> <p>Contoh diatas memiliki 3 buah DocBlock. Yang pertama adalah pada bagian class menjelaskan kegunaan secara global. Yang kedua berada di atas property (deklarasi variabel global didalam class tersebut). Dan yang ketiga adalah diatas method/function untuk menjelaskan secara teknis mengenai method/function tersebut seperti deskripsi, hasil kembalian method, juga parameter pendukungnya.</p>"},{"location":"psr/psr-5/#6144-manfaat","title":"6.14.4. Manfaat","text":"<p>Adapun manfaat dengan menerapkan PHPDoc standard PSR-5 adalah sebagai berikut:</p> <ol> <li>Meningkatkan keterbacaan dan pemahaman kode karena dokumentasi disusun menggunakan pedoman yang konsisten yang sudah ditentukan.</li> <li>Mempermudah pemeliharan kode karena adanya standar yang jelas.</li> <li>Mempermudah kolaborasi antar pengembang dalam project karena mengikuti standard yang sama</li> <li>Dukungan terhadap alat pembantu (tools) dokumentasi dan analisis secara otomatis yang kompatibel dengan PSR-5 (PHPDocumentor, PHPStan, Psalm)</li> <li>Mempermudah pengujian dan debugging dengan pemanfaatan tag <code>@thrown</code> dan <code>@return</code></li> <li>Peningkatan konsistensi dan standarisasi karena semua telah ada pedomannya</li> <li>Mempermudah onboarding pengembang baru dengan mengurangi kurva pembelajaran</li> <li>Mempermudah refactoring kode</li> </ol>"},{"location":"psr/psr-6/","title":"6.11 PSR-6 Caching Interface","text":"<p>PSR-6 adalah rekomendasi standar PHP yang berfokus pada interoperabilitas cache. Tujuan utama dari PSR-6 adalah menyediakan antarmuka cache standar untuk digunakan pada berbagai proyek PHP, memungkinkan pengembang untuk menggunakan implementasi cache yang berbeda dengan cara yang konsisten dan seragam.</p>"},{"location":"psr/psr-6/#komponen-utama-psr-6","title":"Komponen Utama PSR-6","text":"<ol> <li> <p>CacheItemInterface</p> <p>Yang dimaksud adalah antarmuka yang mewakili satu item cache. Antarmuka ini menyediakan metode untuk mendapatkan dan menetapkan nilai, serta metadata lainnya yang terkait dengan item cache. Metode penting tersebut diantaranya: <code>get()</code>, <code>isHit()</code>, <code>set()</code>, dan <code>expiresAt()</code>.</p> </li> <li> <p>CacheItemPoolInterface</p> <p>Antarmuka yang mewakili kumpulan item cache. Dalam hal ini bertanggung jawab untuk mengelola item cache, termasuk mendapatkan item dari cache, menyimpan item di cache, dan membersihkan cache. Metode penting yang dimaksud yaitu <code>getItem()</code>, <code>getItems()</code>, <code>hasItem()</code>, <code>clear()</code>, <code>deleteItem()</code>, <code>deleteItems()</code>, dan <code>save()</code>.</p> </li> <li> <p>CacheException</p> <p>Antarmuka untuk pengecualian yang ditangani oleh PSR-6. Pengecualian ini memungkinkan penanganan kesalahan yang konsisten di seluruh implementasi cache.</p> </li> </ol>"},{"location":"psr/psr-7/","title":"6.5 PSR-7 HTTP Message Interface","text":"<p>PSR-7 adalah standar untuk mengelola pesan HTTP dalam aplikasi PHP. PSR-7 mendefinisikan antarmuka untuk objek yang mewakili permintaan HTTP (Request) dan respons HTTP (Response), serta cara mengelola elemen-elemen HTTP lainnya seperti header, URI, dan body.</p> <p>Implementasi PSR-7 memungkinkan pengelolaan pesan HTTP secara standar, yang membuat kode lebih modular dan dapat digunakan bersama dengan berbagai framework dan library PHP.</p> <p>Pesan HTTP biasanya disarikan dari konsumen pengguna akhir. Namun sebagai pengembang, penting untuk memahami bagaimana pesan ini disusun dan bagaimana cara mengakses atau memanipulasinya. Hal ini diperlukan baik untuk membuat permintaan ke API HTTP, maupun untuk menangani permintaan yang masuk. Setiap pesan permintaan HTTP memiliki struktur tertentu. Contohnya:</p> <pre><code>POST /path HTTP/1.1\nHost: example.com\n\nfoo=bar&amp;baz=bat\n</code></pre> <p>Pada contoh di atas, baris pertama adalah baris permintaan, yang berisi tiga komponen penting:</p> <ol> <li>Metode permintaan HTTP (seperti <code>POST</code>, <code>GET</code>, dll.)</li> <li>Target permintaan (biasanya berupa URI absolut atau jalur di server web)</li> <li>Versi protokol HTTP (misalnya, <code>HTTP/1.1</code>).</li> </ol> <p>Setelah baris permintaan, terdapat satu atau lebih header HTTP yang memberikan informasi tambahan tentang permintaan. Diikuti dengan baris kosong yang menandakan berakhirnya header, kemudian terdapat isi pesan (body) yang berisi data yang dikirimkan (misalnya data formulir dalam permintaan POST).</p> <p>Pesan response HTTP memiliki struktur yang mirip, namun terdapat perbedaan pada baris pertama. Contohnya:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: text/plain\n\nThis is the response body\n</code></pre> <p>Pada contoh response ini, baris pertama disebut baris status yang terdiri dari:</p> <ol> <li>Versi protokol HTTP</li> <li>Kode status HTTP (misalnya, <code>200</code> menandakan permintaan berhasil)</li> <li>Frasa alasan yang memberikan deskripsi kode status yang dapat dibaca manusia (misalnya, <code>OK</code>).</li> </ol> <p>Setelah baris status, ada satu atau lebih header HTTP yang memberikan informasi tambahan tentang respons tersebut, diikuti oleh baris kosong, dan kemudian isi pesan yang berisi data yang dikirimkan sebagai respons (misalnya teks atau file).</p> <p>Dengan memahami struktur pesan permintaan dan respons HTTP, pengembang dapat dengan mudah membuat, mengirim, dan memanipulasi data dalam aplikasi web, serta menangani permintaan yang diterima dengan tepat.</p>"},{"location":"psr/psr-7/#651-cara-implementasi","title":"6.5.1 Cara Implementasi","text":"<p>Untuk mulai menggunakan PSR-7, diperlukan library yang mendukung standar ini. Salah satu library yang banyak digunakan adalah nyholm/psr7.  Instal nyholm/psr7 menggunakan composer:</p> <pre><code>composer require nyholm/psr7\n</code></pre> <ol> <li> <p>Membuat dan mengonfigurasi request Untuk membuat permintaan HTTP menggunakan PSR-7, digunakan antarmuka <code>RequestInterface</code> yang mendefinisikan berbagai metode untuk mengelola request seperti URI, metode HTTP, header, dan body.</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr7\\Factory\\Psr17Factory;\n\n// Membuat instance Psr17Factory\n$factory = new Psr17Factory();\n\n// Membuat Request HTTP GET\n$request = $factory-&gt;createRequest('GET', 'https://example.com');\n\n// Menambahkan header\n$request = $request-&gt;withHeader('User-Agent', 'MyApp/1.0');\n\n// Menambahkan query string\n$request = $request-&gt;withQueryParams(['key' =&gt; 'value']);\n\n// Menambahkan body\n$request = $request-&gt;withBody($factory-&gt;createStream('This is the request body.'));\n\necho $request-&gt;getMethod();  \necho $request-&gt;getUri();  \necho $request-&gt;getBody();  \n</code></pre> <p>Output:</p> <pre><code>GET\nhttps://example.com?key=value\nThis is the request body.\n</code></pre> </li> <li> <p>Membuat dan mengonfigurasi response Untuk membuat response HTTP, digunakan antarmuka <code>ResponseInterface</code> yang mendefinisikan metode untuk mengelola status, header, dan body dari response.</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr7\\Factory\\Psr17Factory;\n\n// Membuat instance Psr17Factory\n$factory = new Psr17Factory();\n\n// Membuat Response HTTP 200 OK\n$response = $factory-&gt;createResponse(200);\n\n// Menambahkan header\n$response = $response-&gt;withHeader('Content-Type', 'text/plain');\n\n// Menambahkan body\n$response = $response-&gt;withBody($factory-&gt;createStream('Hello, World!'));\n\necho $response-&gt;getStatusCode(); \necho $response-&gt;getHeaderLine('Content-Type'); \necho $response-&gt;getBody();  \n</code></pre> <p>Output:</p> <pre><code>200\ntext/plain\nHello, World!\n</code></pre> </li> <li> <p>Membuat dan mengonfigurasi URI</p> <p>PSR-7 juga menyediakan antarmuka <code>UriInterface</code> untuk mengelola URI. URI digunakan untuk mengidentifikasi sumber daya pada web dan dapat digunakan pada request dan response.</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr7\\Factory\\Psr17Factory;\n\n// Membuat instance Psr17Factory\n$factory = new Psr17Factory();\n\n// Membuat URI\n$uri = $factory-&gt;createUri('https://example.com/path?query=value');\n\necho $uri-&gt;getScheme();  \necho $uri-&gt;getHost();    \necho $uri-&gt;getPath();    \necho $uri-&gt;getQuery();  \n</code></pre> <p>Output:</p> <pre><code>https\nexample.com\n/path\nquery=value\n</code></pre> </li> <li> <p>Menggunakan stream</p> <p>PSR-7 menyediakan antarmuka <code>StreamInterface</code> untuk menangani aliran data dalam body dari pesan HTTP. Data ini dapat berupa teks, file, atau data lainnya.</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr7\\Factory\\Psr17Factory;\n\n// Membuat instance Psr17Factory\n$factory = new Psr17Factory();\n\n// Membuat stream dari string\n$stream = $factory-&gt;createStream('This is the body content.');\n\necho $stream-&gt;getContents(); // This is the body content.\n</code></pre> <p>Output:</p> <pre><code>This is the body content.\n</code></pre> </li> </ol>"},{"location":"psr/psr-7/#652-menangani-header","title":"6.5.2 Menangani Header","text":"<p>Header adalah bagian penting dalam pesan HTTP yang menyertakan informasi tambahan. PSR-7 memungkinkan untuk mendapatkan, menambahkan, atau mengubah header.</p> <pre><code>&lt;?php\n\nrequire 'vendor/autoload.php';\n\nuse Nyholm\\Psr7\\Factory\\Psr17Factory;\n\n// Membuat instance Psr17Factory\n$factory = new Psr17Factory();\n\n// Membuat Response HTTP 200 OK\n$response = $factory-&gt;createResponse(200);\n\n// Menambahkan header Content-Type\n$response = $response-&gt;withHeader('Content-Type', 'application/json');\n\n// Mengambil nilai header\necho $response-&gt;getHeaderLine('Content-Type');  // application/json\n</code></pre>"},{"location":"psr/psr-7/#653-keuntungan","title":"6.5.3 Keuntungan","text":"<ol> <li>Modularitas: PSR-7 memungkinkan pengelolaan pesan HTTP secara modular dengan antarmuka standar yang dapat digunakan di berbagai library dan framework.</li> <li>Interoperabilitas: mempermudah aplikasi untuk bekerja dengan berbagai library atau framework yang mendukung PSR-7, seperti middleware atau server HTTP.</li> <li>Fleksibilitas: PSR-7 memberi fleksibilitas dalam menangani berbagai aspek HTTP seperti body, header, dan URI tanpa terikat pada implementasi spesifik.</li> </ol>"},{"location":"python/integrasi/","title":"14.3 Integrasi Dokumentasi dan Uji Coba API","text":"<p>FastAPI secara otomatis menghasilkan dokumentasi interaktif untuk API yang dibangun. Dokumentasi ini dapat diakses melalui Swagger UI atau ReDoc. Hal ini memungkinkan pengembang untuk menguji endpoint API secara langsung tanpa menulis tes manual.</p>"},{"location":"python/integrasi/#1431-dokumentasi-api-dengan-swagger","title":"14.3.1 Dokumentasi API dengan Swagger","text":"<p>FastAPI menggunakan OpenAPI untuk menghasilkan dokumentasi otomatis. Dengan mendefinisikan endpoint API dengan benar, FastAPI akan membuat dokumentasi yang lengkap.</p> <p>Contoh:</p> <pre><code>@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, q: str | None = None):\n    \"\"\"\n    Get an item by its ID.\n    - **item_id**: The ID of the item\n    - **q**: Optional query parameter for additional filtering\n    \"\"\"\n    return {\"item_id\": item_id, \"q\": q}\n</code></pre> <p>Dokumentasi untuk endpoint ini akan muncul di Swagger UI dan dapat digunakan untuk menguji API langsung dari browser.</p>"},{"location":"python/integrasi/#1432-pengujian-unit","title":"14.3.2 Pengujian Unit","text":"<p>Pengujian unit adalah bagian penting dari pengembangan API. FastAPI mendukung pengujian dengan menggunakan pustaka seperti <code>pytest</code>.</p> <p>Contoh pengujian dengan pytest:</p> <pre><code>from fastapi.testclient import TestClient\nfrom app.main import app\n\nclient = TestClient(app)\n\ndef test_read_item():\n    response = client.get(\"/items/5\")\n    assert response.status_code == 200\n    assert response.json() == {\"item_id\": 5}\n</code></pre> <p>Pengujian ini mengirimkan permintaan GET ke endpoint <code>/items/{item_id}</code> dan memverifikasi bahwa status dan data yang diterima sesuai.</p>"},{"location":"python/pedoman/","title":"14.1 PEP 8: Pedoman Gaya Penulisan Kode Python","text":"<p>PEP 8 adalah pedoman gaya penulisan kode Python yang diterima secara luas oleh komunitas Python  untuk membuat kode Python yang konsisten, mudah dibaca, dan mudah dipelihara. Beberapa prinsip utama dalam PEP 8 termasuk indentasi, penamaan, komentar, dan pemformatan kode. </p> <p>Selain PEP 8, saat membangun API dengan FastAPI, ada beberapa praktik terbaik (best practices) yang perlu dipahami. Dalam bab ini, dibahas pedoman PEP 8 untuk penulisan kode Python secara umum dan penerapannya dalam pengembangan API menggunakan FastAPI.</p>"},{"location":"python/pedoman/#1411-indentasi-dan-pemformatan-baris","title":"14.1.1 Indentasi dan Pemformatan Baris","text":"<p>Indentasi adalah aspek penting dalam Python karena digunakan untuk menentukan blok kode. PEP 8 menyarankan penggunaan 4 spasi untuk indentasi, bukan tab.</p> <p>Contoh:</p> <pre><code>def greet(name):\n    if name:\n        print(f\"Hello, {name}\")\n    else:\n        print(\"Hello, world!\")\n</code></pre>"},{"location":"python/pedoman/#1412-panjang-baris","title":"14.1.2 Panjang Baris","text":"<p>Panjang baris kode tidak boleh melebihi 79 karakter. Untuk kode yang lebih panjang, pisahkan menjadi beberapa baris.</p> <p>Contoh:</p> <pre><code>def greet_long_name(name, surname, age, profession, city, country):\n    print(f\"Hello, {name} {surname}, Age: {age}, Profession: {profession}, \"\n          f\"City: {city}, Country: {country}\")\n</code></pre>"},{"location":"python/pedoman/#1413-penamaan-variabel-dan-fungsi","title":"14.1.3 Penamaan Variabel dan Fungsi","text":"<p>Untuk variabel dan nama fungsi, gunakan snake_case (huruf kecil dan dipisahkan dengan garis bawah). Untuk kelas, gunakan CamelCase.</p> <p>Contoh:</p> <pre><code># Variabel dan fungsi menggunakan snake_case\nfirst_name = \"John\"\nlast_name = \"Doe\"\ndef get_full_name(first_name, last_name):\n    return f\"{first_name} {last_name}\"\n\n# Kelas menggunakan CamelCase\nclass Person:\n    def __init__(self, first_name, last_name):\n        self.first_name = first_name\n        self.last_name = last_name\n</code></pre>"},{"location":"python/pedoman/#1414-komentar-dan-docstring","title":"14.1.4 Komentar dan Docstring","text":"<p>Komentar digunakan untuk menjelaskan kode yang rumit atau tidak langsung terlihat maksudnya. Semua fungsi dan kelas harus memiliki docstring yang menjelaskan tujuannya.</p> <p>Contoh komentar:</p> <pre><code># Menghitung usia berdasarkan tahun kelahiran\ndef calculate_age(birth_year):\n    current_year = 2024\n    age = current_year - birth_year\n    return age\n</code></pre> <p>Contoh docstring</p> <pre><code>def greet(name):\n    \"\"\"\n    Menyapa pengguna dengan nama yang diberikan.\n\n    Parameter:\n    name (str): Nama pengguna yang akan disapa\n\n    Mengembalikan:\n    str: Pesan sapaan\n    \"\"\"\n    return f\"Hello, {name}\"\n</code></pre>"},{"location":"python/praktik/","title":"14.2 Praktik Terbaik dalam Membangun API dengan FastAPI","text":"<p>FastAPI adalah framework Python untuk membangun API yang cepat, mudah digunakan, dan mendukung penulisan kode yang sesuai dengan standar PEP 8. Berikut adalah beberapa praktik terbaik saat membangun API dengan FastAPI.</p>"},{"location":"python/praktik/#1421-penataan-struktur-proyek-api","title":"14.2.1 Penataan Struktur Proyek API","text":"<p>Struktur proyek yang baik memudahkan pengembangan dan pemeliharaan API. Umumnya, struktur proyek FastAPI dapat diatur sebagai berikut:</p> <pre><code>project/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u251c\u2500\u2500 models/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 user.py\n\u2502   \u251c\u2500\u2500 schemas/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 user_schema.py\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 api/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 user_api.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 README.md\n</code></pre> <p>Struktur ini memisahkan komponen utama seperti model, schema, layanan, dan API ke dalam folder yang terpisah untuk menjaga keteraturan dan memudahkan pemeliharaan.</p>"},{"location":"python/praktik/#1422-penggunaan-pydantic-untuk-validasi-data","title":"14.2.2 Penggunaan Pydantic untuk Validasi Data","text":"<p>FastAPI menggunakan Pydantic untuk validasi data input dan output. Pydantic memungkinkan pembuatan model data yang kuat dengan penanganan otomatis untuk validasi.</p> <p>Contoh:</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    username: str\n    full_name: str | None = None\n    email: str\n\nclass UserInResponse(User):\n    id: int\n</code></pre> <p>Di atas, <code>User</code> adalah model input, dan <code>UserInResponse</code> adalah model yang digunakan untuk respons API. FastAPI akan secara otomatis memvalidasi data berdasarkan tipe yang ditentukan dalam model Pydantic.</p>"},{"location":"python/praktik/#1423-menangani-error-dengan-exception-handling","title":"14.2.3 Menangani Error dengan Exception Handling","text":"<p>Menangani error adalah aspek penting dalam API. FastAPI memungkinkan untuk menangani error dengan jelas menggunakan exception handler.</p> <p>Contoh:</p> <pre><code>from fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id == 3:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return {\"item_id\": item_id}\n</code></pre> <p>Pada contoh di atas, jika <code>item_id</code> adalah 3, maka API akan mengembalikan error 404 dengan pesan \"Item not found\".</p>"},{"location":"security/broken-access-control/","title":"13.1.6 Broken Access Control","text":"<ol> <li> <p>Penjelasan singkat</p> <p>Broken Access Control terjadi ketika mekanisme otorisasi dalam aplikasi tidak diimplementasikan dengan benar, memungkinkan pengguna untuk mengakses sumber daya atau fungsionalitas yang seharusnya tidak mereka miliki.</p> </li> <li> <p>Dampak</p> <ul> <li>Akses ke data sensitif pengguna lain.</li> <li>Modifikasi atau penghapusan data yang tidak sah.</li> <li>Pengambilan kendali akun pengguna lain.</li> <li>Eskalasi privilege (mendapatkan hak akses yang lebih tinggi dari yang seharusnya).</li> </ul> </li> <li>Pencegahan<ul> <li>Least Privilege: Terapkan prinsip least privilege, di mana pengguna hanya diberikan izin yang benar-benar dibutuhkan untuk melakukan tugasnya.</li> <li>Use Cases dan Role: Identifikasi use case dan peran pengguna dengan jelas. Tentukan izin yang sesuai untuk setiap peran.</li> <li>Otentikasi dan Otorisasi yang Kuat: Implementasikan sistem otentikasi dan otorisasi yang kuat. Gunakan middleware atau dependensi untuk mengelola otorisasi di FastAPI.</li> <li>Jangan Mengandalkan ID Objek Langsung (IDOR): Hindari penggunaan ID objek secara langsung dalam URL. Gunakan mekanisme otorisasi untuk memverifikasi akses ke objek.</li> </ul> </li> </ol>"},{"location":"security/command-injection/","title":"13.1.5 Command Injection","text":"<ol> <li> <p>Penjelasan singkat</p> <p>Command Injection terjadi ketika penyerang menyuntikkan perintah sistem operasi ke dalam input yang dieksekusi oleh aplikasi.</p> </li> <li> <p>Dampak</p> <ul> <li>Eksekusi perintah arbitrer di server.</li> <li>Pengambilan kendali server.</li> <li>Akses data sensitif.</li> </ul> </li> <li>Pencegahan<ul> <li>Hindari Eksekusi Perintah Sistem: Sebisa mungkin, hindari eksekusi perintah sistem secara langsung.</li> <li>Input Validation: Validasi input dengan sangat ketat.</li> <li>subprocess.run dengan Argumen Terpisah: Jika eksekusi perintah sistem diperlukan, gunakan <code>subprocess.run</code> dengan argumen yang dipisahkan sebagai list, bukan sebagai string. Hindari <code>os.system</code> dan <code>os.popen</code>.</li> </ul> </li> </ol>"},{"location":"security/cross-site-request-forgery/","title":"13.1.3 Cross-site Request Forgery","text":"<ol> <li> <p>Penjelasan singkat</p> <p>CSRF terjadi ketika penyerang menipu pengguna yang sudah login untuk melakukan permintaan yang tidak diinginkan ke server. Biasanya, ini dilakukan dengan menyematkan permintaan berbahaya (misalnya, dalam gambar atau tautan) di situs web yang dikendalikan penyerang.</p> </li> <li> <p>Dampak</p> <ul> <li>Perubahan data pengguna (misalnya, kata sandi, alamat email).</li> <li>Pembelian yang tidak sah.</li> <li>Tindakan lain yang tidak diinginkan atas nama pengguna.</li> </ul> </li> <li>Pencegahan<ul> <li>CSRF Tokens: Gunakan CSRF token yang unik untuk setiap sesi atau permintaan. Token ini harus disertakan dalam setiap permintaan POST dan divalidasi oleh server.</li> <li>SameSite Cookie Attribute: Setel atribut <code>SameSite</code> pada cookie ke <code>Strict</code> atau <code>Lax</code> untuk mencegah browser mengirim cookie dengan permintaan lintas situs.</li> <li>Verifikasi Origin Header: Verifikasi header <code>Origin</code> atau <code>Referer</code> untuk memastikan bahwa permintaan berasal dari domain yang diizinkan. Untuk API yang stateless dan menggunakan token bearer (JWT), biasanya tidak rentan terhadap CSRF. Untuk aplikasi berbasis browser, gunakan library seperti <code>fastapi-csrf-protect</code>.</li> </ul> </li> </ol>"},{"location":"security/cross-site-scripting/","title":"13.1.2 Cross-site Scripting","text":"<ol> <li> <p>Penjelasan singkat</p> <p>XSS terjadi ketika penyerang menyuntikkan skrip berbahaya (biasanya JavaScript) ke dalam halaman web yang dilihat oleh pengguna lain. Ketika pengguna mengunjungi halaman yang terinfeksi, skrip akan dieksekusi di browser mereka</p> </li> <li> <p>Dampak</p> <ul> <li>Pencurian cookie dan sesi (mengambil alih akun pengguna).</li> <li>Pengalihan ke situs web berbahaya.</li> <li>Perubahan tampilan halaman web.</li> <li>Pencurian informasi sensitif.</li> </ul> </li> <li>Pencegahan<ul> <li>Input Validation: Validasi semua input pengguna dengan ketat. Tolak input yang mencurigakan atau yang tidak sesuai dengan format yang diharapkan.</li> <li>Output Encoding/Escaping: Gunakan output encoding atau escaping untuk mengubah karakter HTML khusus (seperti <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>, <code>\"</code>, <code>'</code>) menjadi entitas HTML yang sesuai.</li> <li>Content Security Policy (CSP): Implementasikan CSP untuk membatasi sumber dari mana browser diizinkan untuk memuat sumber daya, seperti skrip dan style.</li> <li>HTTPOnly Cookie Flag: Setel flag <code>HttpOnly</code> pada cookie untuk mencegah JavaScript mengakses cookie tersebut.</li> </ul> </li> </ol>"},{"location":"security/dast/","title":"13.2.2 Dynamic Application Security Testing (DAST)","text":"<p>DAST menganalisis aplikasi yang sedang berjalan (runtime) dari perspektif eksternal. Tools DAST mensimulasikan serangan untuk mengidentifikasi kerentanan yang dapat dieksploitasi oleh penyerang. DAST sering disebut sebagai black-box testing karena tidak memerlukan akses ke kode sumber.</p> <ol> <li>Kelebihan DAST:<ul> <li>Deteksi Kerentanan Runtime: Efektif dalam mendeteksi kerentanan yang muncul selama aplikasi berjalan, seperti masalah autentikasi, otorisasi, dan konfigurasi server.</li> <li>Tidak Memerlukan Kode Sumber: Dapat menguji aplikasi tanpa akses ke kode sumber, berguna untuk menguji aplikasi pihak ketiga.</li> <li>Simulasi Serangan Nyata: Mensimulasikan serangan yang mungkin dilakukan oleh penyerang, memberikan gambaran yang lebih realistis tentang potensi risiko.</li> </ul> </li> <li>Kekurangan DAST:<ul> <li>Cakupan Kode Terbatas: Hanya dapat menguji bagian aplikasi yang dapat diakses melalui antarmuka pengguna.</li> <li>Lambat: Proses pengujian bisa memakan waktu, terutama untuk aplikasi yang kompleks.</li> <li>Kesulitan Identifikasi Lokasi: Sulit mengidentifikasi lokasi kerentanan secara spesifik dalam kode sumber.</li> <li>Membutuhkan Lingkungan yang Berfungsi: Membutuhkan aplikasi yang berfungsi dan dapat diakses untuk diuji.</li> </ul> </li> </ol> <p>Contoh tools: OWASP ZAP, Burp Suite, Netsparker</p>"},{"location":"security/intro-celah-keamanan/","title":"13.1 Celah Keamanan","text":"<p>Celah keamanan dalam API dapat membuka pintu bagi potensi ancaman yang membahayakan integritas dan kerahasiaan sistem yang ada. Dalam ekosistem digital yang berkembang pesat, di mana API menghubungkan berbagai aplikasi dan layanan, kerentanannya dapat dimanfaatkan oleh pihak yang tidak bertanggung jawab untuk mengeksploitasi data atau merusak fungsionalitas sistem. Celah keamanan ini seringkali muncul akibat kelalaian dalam pengelolaan input pengguna, kesalahan konfigurasi, atau penggunaan teknologi yang rentan terhadap serangan. Oleh karena itu, sangat penting untuk mengidentifikasi dan mengatasi berbagai celah keamanan ini sebelum dapat dimanfaatkan oleh penyerang, yang dapat menimbulkan kerugian finansial dan reputasi yang signifikan.</p> <p>Secara umum, celah keamanan dalam API dapat mencakup berbagai vektor serangan yang menargetkan berbagai lapisan sistem, mulai dari kode sumber hingga konfigurasi server. Beberapa celah keamanan yang umum ditemukan meliputi SQL Injection, Cross-site Scripting (XSS), dan berbagai jenis serangan lainnya yang dapat merusak atau mengakses informasi yang seharusnya terlindungi. Pemahaman yang mendalam tentang jenis-jenis celah ini, serta cara pencegahannya, sangat penting untuk memastikan bahwa API tetap aman dan terlindungi dari potensi ancaman.</p>"},{"location":"security/intro-pengujian/","title":"13.2 Pengujian Keamanan Aplikasi Web","text":"<p>SAST (Static Application Security Testing) dan DAST (Dynamic Application Security Testing) adalah dua pendekatan utama dalam pengujian keamanan aplikasi web. Keduanya memiliki fokus dan metodologi yang berbeda, dan idealnya digunakan secara bersamaan untuk memberikan cakupan pengujian yang lebih komprehensif. SAST digunakan di awal siklus pengembangan untuk mendeteksi kerentanan sejak dini, sementara DAST digunakan setelah aplikasi di-deploy untuk memastikan tidak ada kerentanan yang terlewat dan untuk menguji aplikasi dalam lingkungan yang lebih realistis.</p>"},{"location":"security/intro/","title":"BAB 13 KEAMANAN","text":"<p>Keamanan merupakan fondasi krusial dalam pengembangan API (Application Programming Interface), mengingat perannya sebagai jembatan penghubung antar sistem dan platform dalam ekosistem digital modern. API yang andal dan aman mutlak diperlukan untuk melindungi data sensitif, mencegah akses tidak sah, dan menjaga integritas sistem secara keseluruhan. Kegagalan dalam menerapkan praktik keamanan yang memadai dapat mengakibatkan konsekuensi serius, seperti kebocoran data, manipulasi informasi, hingga pengambilalihan kendali sistem oleh pihak yang tidak bertanggung jawab.</p>"},{"location":"security/path-traversal/","title":"13.1.4 Path Traversal","text":"<ol> <li> <p>Penjelasan singkat</p> <p>Path Traversal memungkinkan penyerang untuk mengakses file dan direktori yang tidak seharusnya dapat diakses, dengan memanipulasi input yang digunakan untuk merujuk ke lokasi file di server. Penyerang menggunakan karakter seperti <code>../</code> untuk naik ke direktori parent dan mengakses file sensitif di luar direktori yang dituju.</p> </li> <li> <p>Dampak</p> <ul> <li>Akses ke file konfigurasi, log, atau data sensitif lainnya.</li> </ul> </li> <li>Pencegahan<ul> <li>Input Validation/Whitelisting: Validasi input dan hanya izinkan karakter atau path yang diizinkan. Gunakan whitelist.</li> <li>Canonicalization: Gunakan fungsi seperti <code>os.path.abspath()</code> untuk membersihkan path dan menghilangkan komponen seperti <code>../</code>.</li> <li>Hindari Input Langsung untuk Path: Jangan pernah menggunakan input pengguna secara langsung untuk membangun path file. Gunakan <code>os.path.join()</code> untuk menggabungkan path dengan aman.</li> </ul> </li> </ol>"},{"location":"security/sast/","title":"13.2.1 Static Application Security Testing (SAST)","text":"<p>SAST menganalisis kode sumber aplikasi secara statis, tanpa menjalankan aplikasi tersebut. Fokusnya adalah pada identifikasi potensi kerentanan berdasarkan pola kode yang mencurigakan atau penggunaan fungsi yang tidak aman. SAST sering disebut sebagai white-box testing karena membutuhkan akses ke kode sumber.</p> <ol> <li>Kelebihan SAST:<ul> <li>Deteksi Dini: Dapat mendeteksi kerentanan pada tahap awal siklus pengembangan perangkat lunak (SDLC), bahkan sebelum aplikasi di-compile atau di-deploy.</li> <li>Lokasi Spesifik: Memberikan informasi detail mengenai lokasi kerentanan dalam kode sumber, memudahkan pengembang untuk memperbaikinya.</li> <li>Otomatisasi: Proses pemindaian dapat diotomatisasi dan diintegrasikan ke dalam pipeline CI/CD.</li> <li>Efisiensi: Relatif cepat dalam melakukan pemindaian dan dapat menangani basis kode yang besar.</li> </ul> </li> <li>Kekurangan SAST:<ul> <li>False Positive*: Cenderung menghasilkan *false positive (laporan kerentanan yang sebenarnya bukan kerentanan), sehingga membutuhkan verifikasi manual.</li> <li>Keterbatasan Konteks: Kurang efektif dalam mendeteksi kerentanan yang terkait dengan konfigurasi atau interaksi runtime aplikasi.</li> <li>Ketergantungan pada Kode Sumber: Membutuhkan akses ke kode sumber, sehingga tidak dapat digunakan untuk menguji aplikasi pihak ketiga atau aplikasi yang kode sumbernya tidak tersedia.</li> </ul> </li> <li>Contoh tools:<ul> <li>Semgrep</li> </ul> </li> </ol> <pre><code>bash$ semgrep --config 'p/fastapi' .\n\n\u250c\u2500\u2500\u2500\u2500 \u25cb\u25cb\u25cb \u2500\u2500\u2500\u2500\u2510\n\u2502 Semgrep CLI \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\nScanning 60 files (only git-tracked) with 60 Code rules:\n\n  CODE RULES\n  Scanning 51 files with 60 python rules.\n\n  SUPPLY CHAIN RULES\n\n  \ud83d\udc8e Run `semgrep ci` to find dependency\n     vulnerabilities and advanced cross-file findings. \n\n\n  PROGRESS\n\n  \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% 0:00:14                                                                                                                        \n\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nSome files were skipped or only partially analyzed.\n  Scan was limited to files tracked by git.\n\nRan 60 rules on 51 files: 0 findings.\n</code></pre> <ul> <li>Snyk</li> </ul> <pre><code>bash$ snyk code test .\n\nTesting . ...\n\n \u2717 [Low] Use of Password Hash With Insufficient Computational Effort \n   Path: app/api/v1/endpoints/users.py, line 47 \n   Info: hashlib.md5 is insecure. Consider changing it to a secure hashing algorithm.\n\n \u2717 [Low] Use of Password Hash With Insufficient Computational Effort \n   Path: app/api/v1/endpoints/users.py, line 121 \n   Info: hashlib.md5 is insecure. Consider changing it to a secure hashing algorithm.\n\n \u2717 [Low] Use of Password Hash With Insufficient Computational Effort \n   Path: app/api/v2/endpoints/users.py, line 47 \n   Info: hashlib.md5 is insecure. Consider changing it to a secure hashing algorithm.\n\n \u2717 [Low] Use of Password Hash With Insufficient Computational Effort \n   Path: app/api/v2/endpoints/users.py, line 121 \n   Info: hashlib.md5 is insecure. Consider changing it to a secure hashing algorithm.\n\n \u2717 [Low] Use of Password Hash With Insufficient Computational Effort \n   Path: app/api/v2/endpoints/banner.py, line 48 \n   Info: hashlib.md5 is insecure. Consider changing it to a secure hashing algorithm.\n\n \u2717 [Low] Use of Password Hash With Insufficient Computational Effort \n   Path: app/api/v1/endpoints/banner.py, line 48 \n   Info: hashlib.md5 is insecure. Consider changing it to a secure hashing algorithm.\n\n\u2714 Test completed\n\nOrganization:      UGM\nTest type:         Static code analysis\nProject path:      .\n\nSummary:\n\n  6 Code issues found\n  6 [Low]\n</code></pre>"},{"location":"security/sensitive-data-exposure/","title":"13.1.7 Sensitive Data Exposure","text":"<ol> <li> <p>Penjelasan singkat</p> <p>Sensitive Data Exposure terjadi ketika aplikasi mengungkapkan data sensitif, seperti kata sandi, nomor kartu kredit, informasi pribadi, atau kunci API, kepada pihak yang tidak berhak. </p> </li> <li> <p>Dampak</p> <ul> <li>Pencurian identitas.</li> <li>Kerugian finansial.</li> <li>Kerusakan reputasi.</li> <li>Pelanggaran privasi.</li> </ul> </li> <li>Pencegahan<ul> <li>HTTPS: Selalu gunakan HTTPS untuk mengenkripsi komunikasi.</li> <li>Enkripsi Data at Rest: Enkripsi data sensitif yang disimpan di database.</li> <li>Hashing Password: Jangan pernah menyimpan kata sandi dalam bentuk plain text. Gunakan hashing algorithm yang kuat seperti bcrypt atau Argon2.</li> <li>HTTP Security Headers: Gunakan header keamanan HTTP seperti HSTS, X-Frame-Options, dan Content-Security-Policy.</li> <li>Logging yang Hati-hati: Hindari mencatat data sensitif dalam log.</li> </ul> </li> </ol>"},{"location":"security/sql-injection/","title":"13.1.1 SQL Injection","text":"<ol> <li> <p>Penjelasan singkat</p> <p>SQL Injection terjadi ketika penyerang menyuntikkan kode SQL berbahaya ke dalam input yang digunakan dalam query database. Ini memungkinkan penyerang untuk memanipulasi query, mengakses data yang tidak sah, atau bahkan memodifikasi atau menghapus data.</p> </li> <li> <p>Dampak</p> <ul> <li>Akses data sensitif yang tidak sah.</li> <li>Modifikasi atau penghapusan data.</li> <li>Pengambilan kendali server database.</li> <li>Bypass proses otentikasi</li> </ul> </li> <li>Pencegahan<ul> <li>Parameterized Queries/Prepared Statements: Selalu gunakan parameterized queries atau prepared statements. Ini akan memperlakukan input pengguna sebagai data, bukan bagian dari perintah SQL.</li> <li>ORM (Object-Relational Mapper): Gunakan ORM seperti SQLAlchemy yang umumnya menyediakan mekanisme untuk mencegah SQL Injection secara otomatis.</li> <li>Input Validation: Validasi input pengguna dan pastikan sesuai dengan format yang diharapkan.</li> </ul> </li> </ol>"},{"location":"tools/dbdiagram/","title":"12.17 dbdiagram.io","text":"<p>dbdiagram.io adalah alat online yang digunakan untuk membuat dan berbagi diagram entitas-relasi (ERD). Alat ini memungkinkan pengguna untuk merancang struktur database secara visual dan menghasilkan representasi ERD yang mudah dipahami. dbdiagram.io mendukung format DBML (Database Markup Language), yang memungkinkan pengguna untuk mendefinisikan tabel, kolom, relasi, dan jenis data secara deklaratif. Setelah diagram dibuat, dbdiagram.io dapat mengonversi desain ke dalam query SQL, yang dapat langsung digunakan untuk membuat struktur database di sistem manajemen database (DBMS) yang didukung.</p>"},{"location":"tools/dbdiagram/#12171-fitur-utama-dbdiagramio","title":"12.17.1 Fitur Utama dbdiagram.io","text":"<ol> <li>Pembuatan ERD Secara Visual<ul> <li>dbdiagram.io menyediakan antarmuka grafis untuk menggambar diagram entitas dan relasi antar tabel secara langsung. Pengguna dapat menarik dan menyusun elemen tabel serta mendefinisikan relasi antar tabel dengan mudah.</li> </ul> </li> <li>Support DBML (Database Markup Language)<ul> <li>Pengguna dapat menulis definisi struktur database menggunakan sintaks DBML, yang memungkinkan mereka untuk mendesain database dalam bentuk teks. Format ini sederhana, mudah dibaca, dan efisien untuk bekerja dengan pengembang lainnya.</li> </ul> </li> <li>Konversi DBML ke SQL<ul> <li>Salah satu fitur utama dbdiagram.io adalah kemampuannya untuk mengonversi diagram atau kode DBML langsung menjadi query SQL. Ini memungkinkan pengguna untuk menghasilkan SQL untuk membuat tabel, relasi, dan struktur database secara otomatis, mempercepat proses implementasi.</li> </ul> </li> <li>Ekspor ke Berbagai Format<ul> <li>dbdiagram.io memungkinkan pengguna untuk mengekspor diagram ke berbagai format, seperti PNG, PDF, atau bahkan DBML, untuk berbagi dengan tim atau dokumentasi lebih lanjut.</li> </ul> </li> <li>Kolaborasi dan Berbagi Diagram<ul> <li>Pengguna dapat dengan mudah berbagi diagram ERD dengan orang lain. dbdiagram.io mendukung kolaborasi tim, di mana beberapa pengguna dapat mengedit diagram secara bersamaan, mempercepat proses desain database.</li> </ul> </li> <li>Integrasi dengan Alat Lain<ul> <li>dbdiagram.io dapat diintegrasikan dengan berbagai alat pengembangan, termasuk GitHub dan GitLab, untuk memungkinkan pengelolaan diagram dalam repositori bersama dengan kode sumber.</li> </ul> </li> <li>Antarmuka Sederhana dan Mudah Digunakan<ul> <li>Alat ini dirancang dengan antarmuka yang sederhana, memungkinkan pengguna untuk mulai membuat diagram tanpa memerlukan banyak pelatihan. Fitur-fitur drag-and-drop memudahkan penyusunan tabel dan relasi.</li> </ul> </li> </ol>"},{"location":"tools/dbdiagram/#12172-keunggulan-dbdiagramio","title":"12.17.2 Keunggulan dbdiagram.io","text":"<ol> <li>Mudah Digunakan dan Cepat<ul> <li>Dibandingkan dengan alat lain, dbdiagram.io lebih mudah digunakan dan lebih cepat dalam menghasilkan diagram ERD, berkat antarmuka yang intuitif dan fitur otomatis untuk konversi DBML ke SQL.</li> </ul> </li> <li>Gratis dan Aksesibilitas<ul> <li>dbdiagram.io menawarkan versi gratis yang memberikan akses ke sebagian besar fungsionalitas. Pengguna dapat membuat diagram ERD dan menghasilkan SQL tanpa biaya tambahan.</li> </ul> </li> <li>Fleksibilitas Format<ul> <li>Format DBML yang digunakan di dbdiagram.io mudah dipahami dan memungkinkan pengguna untuk mendesain struktur database secara deklaratif. Format ini juga mendukung berbagai jenis database, sehingga memungkinkan konversi ke SQL yang sesuai dengan DBMS pilihan pengguna.</li> </ul> </li> <li>Berbagi dan Kolaborasi<ul> <li>Kemudahan berbagi diagram dengan anggota tim atau kolaborasi dengan orang lain membuat dbdiagram.io menjadi pilihan yang baik untuk tim pengembangan yang bekerja bersama dalam desain database.</li> </ul> </li> <li>Konversi Langsung ke SQL<ul> <li>Salah satu fitur yang sangat bermanfaat adalah kemampuan untuk mengonversi desain ERD ke dalam query SQL secara otomatis. Ini memungkinkan pengguna untuk langsung menghasilkan query yang dapat dijalankan di database, menghemat waktu dan meminimalkan kesalahan manual.</li> </ul> </li> </ol>"},{"location":"tools/dbdiagram/#12173-kekurangan-dbdiagramio","title":"12.17.3 Kekurangan dbdiagram.io","text":"<ol> <li>Fitur Terbatas di Versi Gratis<ul> <li>Meskipun versi gratis sudah cukup untuk banyak pengguna, dbdiagram.io membatasi beberapa fitur di versi ini, seperti jumlah diagram yang dapat dibuat dan kemampuan untuk mengunduh file diagram dalam format tertentu.</li> </ul> </li> <li>Fitur Kolaborasi Terbatas<ul> <li>Meskipun dbdiagram.io mendukung kolaborasi, fitur ini mungkin terbatas pada beberapa rencana berbayar. Tim dengan kebutuhan kolaborasi yang lebih besar atau pengguna yang ingin menggunakan lebih banyak fitur mungkin harus mempertimbangkan berlangganan.</li> </ul> </li> <li>Kurang Fleksibel untuk Desain Kompleks<ul> <li>Untuk proyek database yang sangat besar atau kompleks, dbdiagram.io mungkin terasa kurang fleksibel dibandingkan dengan alat desain database profesional lainnya. Alat ini lebih cocok untuk desain database sederhana hingga menengah.</li> </ul> </li> </ol>"},{"location":"tools/dbdiagram/#12174-lisensi-dan-versi-dbdiagramio","title":"12.17.4 Lisensi dan Versi dbdiagram.io","text":"<ol> <li>Versi Gratis<ul> <li>Versi gratis dbdiagram.io menawarkan sebagian besar fungsionalitas, termasuk pembuatan diagram ERD dan konversi DBML ke SQL. Namun, ada batasan dalam jumlah diagram yang dapat dibuat dan fitur berbagi diagram.</li> </ul> </li> <li>Versi Berbayar<ul> <li>dbdiagram.io menawarkan versi berbayar yang membuka lebih banyak fitur, seperti kolaborasi lebih luas, penyimpanan diagram yang lebih banyak, dan ekspor diagram dalam berbagai format.</li> </ul> </li> </ol>"},{"location":"tools/dbdiagram/#12175-penggunaan-dbdiagramio-dalam-proyek-pengembangan","title":"12.17.5 Penggunaan dbdiagram.io dalam Proyek Pengembangan","text":"<ol> <li>Desain dan Perencanaan Database<ul> <li>dbdiagram.io sangat berguna dalam fase perencanaan proyek pengembangan, di mana tim dapat merancang struktur database secara visual dan langsung menghasilkan query SQL yang siap digunakan.</li> </ul> </li> <li>Kolaborasi Tim dalam Desain Database<ul> <li>Tim pengembang yang bekerja pada proyek yang melibatkan desain database dapat menggunakan dbdiagram.io untuk berkolaborasi dalam membuat diagram ERD, berbagi diagram, dan memastikan bahwa struktur database disepakati bersama sebelum implementasi.</li> </ul> </li> <li>Generasi SQL dari DBML<ul> <li>Salah satu manfaat utama menggunakan dbdiagram.io adalah kemampuannya untuk mengonversi DBML ke SQL secara otomatis. Setelah diagram ERD selesai, pengguna dapat menghasilkan query SQL yang tepat untuk membuat tabel dan relasi di DBMS yang dipilih. Ini mempercepat proses implementasi dan mengurangi kemungkinan kesalahan dalam penulisan query.</li> </ul> </li> <li>Dokumentasi dan Referensi<ul> <li>dbdiagram.io juga bisa digunakan untuk membuat dokumentasi visual untuk database. Diagram ERD yang dihasilkan bisa dibagikan kepada pemangku kepentingan proyek atau digunakan dalam dokumentasi proyek untuk menjelaskan struktur database.</li> </ul> </li> </ol>"},{"location":"tools/dbeaver/","title":"DBeaver Community","text":""},{"location":"tools/dbeaver/#127-dbeaver-community","title":"12.7 DBeaver Community","text":"<p>DBeaver Community adalah alat manajemen database berbasis GUI yang open-source dan mendukung berbagai jenis database. DBeaver dirancang untuk mempermudah pengelolaan database SQL dan NoSQL dengan antarmuka yang ramah pengguna serta menyediakan banyak fitur untuk pengembang, administrator, dan analis data.</p> <p>Tool ini mendukung banyak database populer seperti MySQL, PostgreSQL, SQLite, Oracle, SQL Server, dan MongoDB, serta dapat diintegrasikan dengan berbagai plugin untuk memperluas fungsionalitasnya.</p>"},{"location":"tools/dbeaver/#1271-fitur-utama-dbeaver-community","title":"12.7.1 Fitur Utama DBeaver Community","text":"<ol> <li>Dukungan Multi-Database<ul> <li>Dapat terhubung ke berbagai jenis database SQL dan NoSQL, termasuk MySQL, PostgreSQL, Oracle, SQL Server, SQLite, dan MongoDB.</li> <li>Mendukung koneksi ke database lokal, remote, serta layanan cloud seperti AWS RDS dan Google Cloud.</li> </ul> </li> <li>Antarmuka Pengguna yang Intuitif<ul> <li>Menyediakan antarmuka grafis yang mudah digunakan dengan desain yang bersih dan fungsional.</li> <li>Mendukung tampilan visual untuk tabel, kolom, dan hubungan antar entitas.</li> </ul> </li> <li>SQL Editor<ul> <li>Editor SQL dengan fitur auto-complete dan highlight sintaks untuk mempermudah penulisan query.</li> <li>Mendukung eksekusi query SQL langsung dengan hasil yang ditampilkan secara interaktif.</li> </ul> </li> <li>Visualisasi Data<ul> <li>Menyediakan berbagai alat visualisasi untuk analisis data, termasuk grafik, diagram, dan tabel pivot.</li> <li>Memungkinkan pembuatan ERD (Entity-Relationship Diagram) untuk memvisualisasikan relasi antar tabel.</li> </ul> </li> <li>Manajemen Data<ul> <li>Dapat melakukan import dan export data dalam berbagai format seperti CSV, Excel, JSON, XML, dan SQL.</li> <li>Mempermudah manipulasi data dengan editor visual.</li> </ul> </li> <li>Backup dan Restore<ul> <li>Mendukung proses pencadangan dan pemulihan data dengan antarmuka yang mudah digunakan.</li> </ul> </li> <li>Pengelolaan Skrip dan Prosedur<ul> <li>Memungkinkan pengelolaan dan pengeditan prosedur tersimpan, fungsi, dan skrip SQL.</li> <li>Fitur debug untuk menganalisis dan memperbaiki skrip SQL dan prosedur.</li> </ul> </li> <li>Pencarian dan Penyaringan Data<ul> <li>Menyediakan fitur pencarian dan penyaringan data yang kuat, memungkinkan pencarian dengan berbagai kriteria dan pengaturan.</li> </ul> </li> <li>Fitur Automasi<ul> <li>Mendukung eksekusi tugas otomatis seperti pencadangan, pemeliharaan database, atau eksekusi query.</li> </ul> </li> <li>Keamanan<ul> <li>Menyediakan koneksi yang aman dengan dukungan untuk SSL dan SSH untuk memastikan keamanan data saat terkoneksi dengan server database.</li> </ul> </li> </ol>"},{"location":"tools/dbeaver/#1272-keunggulan-dbeaver-community","title":"12.7.2 Keunggulan DBeaver Community","text":"<ol> <li>Gratis dan Open-Source<ul> <li>DBeaver Community dapat digunakan tanpa biaya dan dapat dimodifikasi sesuai kebutuhan proyek berkat lisensi open-source.</li> </ul> </li> <li>Kompatibilitas dengan Banyak Database<ul> <li>Mendukung berbagai database SQL dan NoSQL dalam satu alat, mengurangi kebutuhan untuk banyak aplikasi manajer database.</li> </ul> </li> <li>Antarmuka Pengguna yang Mudah Digunakan<ul> <li>Antarmuka yang intuitif dan sederhana membuatnya cocok bagi pengembang dari berbagai tingkat pengalaman.</li> </ul> </li> <li>Fleksibilitas dalam Pengelolaan Data<ul> <li>DBeaver mempermudah tugas pengelolaan data seperti import, export, dan modifikasi data secara visual tanpa menulis query manual.</li> </ul> </li> <li>Komunitas Pengguna yang Aktif<ul> <li>DBeaver memiliki komunitas besar yang menyediakan dukungan dan pengembangan berkelanjutan melalui forum, dokumentasi, dan plugin.</li> </ul> </li> <li>Fitur Visualisasi dan Diagram<ul> <li>Alat visualisasi seperti ERD dan grafik data mempermudah analisis dan pemahaman struktur serta isi database.</li> </ul> </li> </ol>"},{"location":"tools/dbeaver/#1273-kekurangan-dbeaver-community","title":"12.7.3 Kekurangan DBeaver Community","text":"<ol> <li>Fitur Terbatas pada Versi Community<ul> <li>Beberapa fitur canggih seperti integrasi dengan alat pengelolaan proyek atau fitur enterprise hanya tersedia di versi berbayar (DBeaver Enterprise).</li> </ul> </li> <li>Performa pada Database Besar<ul> <li>Pada database dengan ukuran yang sangat besar, kinerja DBeaver bisa menurun jika dibandingkan dengan alat lain yang lebih ringan.</li> </ul> </li> <li>Tampilan Antarmuka yang Kurang Ringan<ul> <li>Meskipun intuitif, antarmuka DBeaver bisa terasa sedikit berat bagi pengguna dengan konfigurasi komputer yang lebih tua atau sumber daya terbatas.</li> </ul> </li> <li>Kurangnya Fitur untuk Pemrograman Lanjut<ul> <li>DBeaver lebih fokus pada manajemen dan analisis data, sehingga kurang cocok untuk pengembang yang membutuhkan alat pengembangan database lanjutan.</li> </ul> </li> </ol>"},{"location":"tools/dbeaver/#1274-lisensi-dan-versi-dbeaver","title":"12.7.4 Lisensi dan Versi DBeaver","text":"<ol> <li>Versi Community (Gratis dan Open-Source)<ul> <li>Tersedia secara gratis dan dapat digunakan tanpa biaya dengan akses ke berbagai fitur dasar untuk pengelolaan database.</li> <li>Fitur open-source memungkinkan pengguna untuk memodifikasi dan memperluas fungsionalitas sesuai kebutuhan.</li> </ul> </li> <li>Versi Enterprise (Berbayar)<ul> <li>Menyediakan fitur tambahan seperti integrasi dengan alat pengelolaan proyek, koneksi ke alat analitik, dan dukungan perusahaan.</li> <li>Harga bervariasi berdasarkan lisensi dan jumlah pengguna.</li> </ul> </li> </ol>"},{"location":"tools/dbeaver/#1275-penggunaan-dbeaver-community-dalam-proyek-pengembangan","title":"12.7.5 Penggunaan DBeaver Community dalam Proyek Pengembangan","text":"<ol> <li>Pengelolaan Multi-Database<ul> <li>Ideal bagi tim yang bekerja dengan berbagai jenis database dalam satu proyek atau organisasi, mengurangi kebutuhan untuk aplikasi manajer database yang berbeda.</li> </ul> </li> <li>Analisis dan Visualisasi Data<ul> <li>Membantu menganalisis dan memvisualisasikan data dalam berbagai format, serta membuat diagram ERD untuk memperjelas struktur database.</li> </ul> </li> <li>Pemeliharaan Database<ul> <li>Mempermudah pengelolaan tugas pemeliharaan seperti pencadangan, restore, dan sinkronisasi antar database.</li> </ul> </li> <li>Pengembangan dan Debugging SQL<ul> <li>Menyediakan lingkungan yang cocok untuk menulis dan mendebug query SQL, serta memperbaiki prosedur tersimpan.</li> </ul> </li> <li>Fleksibilitas dan Kustomisasi<ul> <li>Kemampuan untuk menambahkan plugin atau memodifikasi alat sesuai dengan kebutuhan proyek atau tim pengembangan.</li> </ul> </li> </ol>"},{"location":"tools/draw.io/","title":"12.15 Draw.io","text":"<p>Draw.io (sekarang dikenal sebagai diagrams.net) adalah aplikasi pembuat diagram dan alat pemetaan visual yang memungkinkan pengguna untuk membuat berbagai jenis diagram, seperti diagram alur (flowchart), diagram jaringan, diagram organisasi, dan banyak lagi. Draw.io adalah alat berbasis web yang sangat fleksibel dan dapat digunakan secara gratis, dengan opsi untuk menyimpan diagram di berbagai platform seperti Google Drive, OneDrive, dan GitHub. Draw.io cocok digunakan baik oleh individu maupun tim dalam membuat diagram visual untuk merencanakan, menjelaskan, atau memecahkan masalah.</p>"},{"location":"tools/draw.io/#12151-fitur-utama-drawio","title":"12.15.1 Fitur Utama Draw.io","text":"<ol> <li>Berbasis Web dan Desktop<ul> <li>Draw.io dapat diakses melalui browser web atau diunduh sebagai aplikasi desktop untuk Windows, macOS, dan Linux. Hal ini memudahkan pengguna untuk memilih cara yang paling nyaman untuk menggunakan alat ini.</li> </ul> </li> <li>Banyak Template dan Bentuk<ul> <li>Draw.io menyediakan berbagai template dan bentuk untuk diagram, termasuk diagram alur, diagram ERD (Entity Relationship Diagram), diagram jaringan, diagram organisasi, dan banyak lagi. Template ini mempermudah pengguna untuk memulai desain diagram dengan cepat.</li> </ul> </li> <li>Integrasi dengan Layanan Cloud<ul> <li>Draw.io memungkinkan penyimpanan dan berbagi diagram di berbagai platform cloud seperti Google Drive, OneDrive, dan GitHub. Pengguna dapat menyimpan file diagram mereka di cloud untuk akses mudah dan berbagi dengan tim.</li> </ul> </li> <li>Antarmuka Pengguna yang Intuitif<ul> <li>Alat ini menawarkan antarmuka pengguna yang bersih dan sederhana, dengan alat drag-and-drop yang memungkinkan pengguna untuk dengan mudah menarik dan menempatkan elemen dalam diagram.</li> </ul> </li> <li>Pembuatan Diagram Kolaboratif<ul> <li>Pengguna dapat bekerja bersama-sama dalam membuat diagram secara real-time, memfasilitasi kolaborasi tim yang efektif. Ini sangat berguna dalam tim yang bekerja jarak jauh atau dalam proyek yang melibatkan banyak orang.</li> </ul> </li> <li>Export ke Berbagai Format<ul> <li>Diagram yang dibuat di Draw.io dapat diekspor ke berbagai format seperti PNG, JPEG, SVG, PDF, dan XML. Ini memungkinkan pengguna untuk menggunakan diagram dalam berbagai presentasi atau dokumentasi.</li> </ul> </li> <li>Pengaturan dan Kustomisasi Diagram<ul> <li>Pengguna dapat menyesuaikan diagram dengan berbagai pilihan warna, font, dan gaya untuk membuat diagram yang sesuai dengan kebutuhan atau preferensi pribadi.</li> </ul> </li> <li>Versi Offline<ul> <li>Draw.io menyediakan versi offline yang memungkinkan pengguna untuk membuat dan mengedit diagram tanpa koneksi internet. Diagram yang dibuat dapat disimpan secara lokal dan disinkronkan dengan cloud nanti.</li> </ul> </li> <li>Fitur Keamanan dan Kontrol Akses<ul> <li>Jika digunakan dalam pengaturan perusahaan atau organisasi, Draw.io menyediakan kontrol akses dan izin yang memungkinkan pengguna untuk menentukan siapa yang dapat mengedit atau melihat diagram mereka.</li> </ul> </li> <li>Kode QR dan Integrasi Alat<ul> <li>Draw.io mendukung pembuatan QR Code dan memiliki kemampuan integrasi dengan berbagai alat lain, seperti Slack, Jira, dan Confluence, yang meningkatkan kemudahan berbagi dan kolaborasi dalam tim.</li> </ul> </li> </ol>"},{"location":"tools/draw.io/#12152-keunggulan-drawio","title":"12.15.2 Keunggulan Draw.io","text":"<ol> <li>Gratis dan Open Source<ul> <li>Draw.io adalah alat gratis dan open-source, yang memungkinkan siapa saja untuk menggunakannya tanpa biaya dan tanpa batasan fungsionalitas. Ini menjadikannya pilihan yang sangat hemat biaya untuk individu dan organisasi.</li> </ul> </li> <li>Antarmuka yang Sederhana dan Mudah Digunakan<ul> <li>Antarmuka pengguna yang intuitif membuatnya mudah bagi pemula untuk memulai, sementara fitur lanjutan memberikan fleksibilitas bagi pengguna berpengalaman.</li> </ul> </li> <li>Integrasi yang Luas<ul> <li>Draw.io terintegrasi dengan banyak layanan cloud dan alat lain, memungkinkan penggunaan yang fleksibel dalam berbagai skenario, baik untuk kolaborasi tim atau manajemen proyek.</li> </ul> </li> <li>Mendukung Kolaborasi Real-Time<ul> <li>Dengan kemampuan kolaborasi real-time, Draw.io memungkinkan tim untuk bekerja bersama dalam diagram yang sama pada waktu yang bersamaan, yang memfasilitasi komunikasi dan kolaborasi lebih baik.</li> </ul> </li> <li>Penyimpanan dan Berbagi Diagram yang Mudah<ul> <li>Penyimpanan diagram di cloud dan kemampuan berbagi mempermudah distribusi diagram ke kolega, anggota tim, atau klien tanpa memerlukan pengaturan teknis yang rumit.</li> </ul> </li> <li>Dapat Digunakan Tanpa Koneksi Internet<ul> <li>Versi offline Draw.io memungkinkan pengguna untuk tetap produktif meskipun tidak memiliki akses ke internet, sangat berguna dalam situasi di mana koneksi terbatas.</li> </ul> </li> <li>Dukungan untuk Berbagai Format Ekspor<ul> <li>Kemampuan untuk mengekspor diagram ke berbagai format memungkinkan diagram digunakan dalam berbagai konteks, mulai dari dokumentasi teknis hingga presentasi bisnis.</li> </ul> </li> </ol>"},{"location":"tools/draw.io/#12153-kekurangan-drawio","title":"12.15.3 Kekurangan Draw.io","text":"<ol> <li>Tidak Ada Fitur Pencadangan Otomatis<ul> <li>Meskipun Draw.io memungkinkan penyimpanan diagram ke cloud, aplikasi ini tidak memiliki sistem pencadangan otomatis yang menyeluruh, sehingga pengguna harus secara manual menyimpan dan mengelola salinan cadangan.</li> </ul> </li> <li>Kurangnya Fitur Fungsionalitas Lanjutan<ul> <li>Meskipun Draw.io sangat baik untuk membuat diagram dasar hingga menengah, alat ini tidak memiliki fitur yang lebih kompleks seperti yang terdapat di aplikasi desain diagram profesional lainnya (misalnya, fitur animasi atau diagram dinamis).</li> </ul> </li> <li>Kurva Pembelajaran untuk Fitur Lanjut<ul> <li>Meskipun antarmuka dasar sangat mudah digunakan, beberapa fitur lanjutan mungkin memerlukan waktu untuk dipelajari oleh pengguna baru atau mereka yang belum berpengalaman dalam alat desain diagram.</li> </ul> </li> <li>Performa Tergantung pada Koneksi Internet<ul> <li>Pengguna yang mengandalkan versi berbasis web mungkin mengalami keterbatasan performa jika koneksi internet mereka tidak stabil atau lambat.</li> </ul> </li> </ol>"},{"location":"tools/draw.io/#12154-lisensi-dan-akses-drawio","title":"12.15.4 Lisensi dan Akses Draw.io","text":"<ol> <li>Lisensi Gratis<ul> <li>Draw.io adalah alat gratis untuk digunakan, dengan akses penuh ke semua fitur tanpa biaya. Pengguna hanya perlu mendaftar jika ingin menyimpan diagram ke cloud atau berbagi diagram dengan tim mereka.</li> </ul> </li> <li>Penyimpanan Cloud atau Lokal<ul> <li>Diagram dapat disimpan di berbagai platform penyimpanan cloud seperti Google Drive, OneDrive, atau GitHub, atau di penyimpanan lokal pengguna.</li> </ul> </li> </ol>"},{"location":"tools/draw.io/#12155-penggunaan-drawio-dalam-proyek-pengembangan","title":"12.15.5 Penggunaan Draw.io dalam Proyek Pengembangan","text":"<ol> <li>Perencanaan dan Desain Arsitektur Sistem<ul> <li>Draw.io sangat berguna dalam merancang diagram arsitektur sistem, seperti diagram alur, diagram jaringan, dan ERD. Ini memungkinkan tim pengembang untuk merencanakan dan memvisualisasikan struktur aplikasi atau sistem mereka.</li> </ul> </li> <li>Desain dan Prototipe UI<ul> <li>Dalam proyek desain antarmuka pengguna (UI), Draw.io dapat digunakan untuk membuat wireframe atau prototipe awal dari aplikasi, memberikan gambaran kasar tentang bagaimana antarmuka akan terlihat dan berfungsi.</li> </ul> </li> <li>Kolaborasi Tim<ul> <li>Tim pengembang atau desain dapat bekerja bersama dalam membuat diagram yang menjelaskan alur kerja, perencanaan, dan pengembangan produk. Dengan fitur kolaborasi real-time, Draw.io mendukung efisiensi dan komunikasi antar anggota tim.</li> </ul> </li> <li>Pembuatan Dokumentasi Visual<ul> <li>Draw.io digunakan untuk membuat dokumentasi teknis yang menjelaskan proses bisnis, struktur data, dan desain teknis lainnya, yang dapat digunakan oleh tim pengembang dan pihak terkait lainnya.</li> </ul> </li> </ol>"},{"location":"tools/figma/","title":"12.13 Figma (Education Version)","text":"<p>Figma adalah alat desain berbasis web yang memungkinkan kolaborasi secara real-time dalam pembuatan desain antarmuka pengguna (UI), prototipe, wireframe, dan mockup. Figma memiliki keunggulan utama dalam kemudahan kolaborasi, karena memungkinkan banyak orang untuk bekerja bersama dalam satu desain secara bersamaan, baik secara langsung maupun dengan cara yang terkoordinasi. Figma banyak digunakan oleh desainer UX/UI, pengembang, dan tim produk dalam proses desain produk digital. Untuk dunia pendidikan, Figma menyediakan Figma for Education, yang memberikan akses gratis ke fitur-fitur premium Figma untuk pengajar dan siswa.</p>"},{"location":"tools/figma/#12131-fitur-utama-figma","title":"12.13.1 Fitur Utama Figma","text":"<ol> <li>Akses Gratis ke Fitur Premium<ul> <li>Figma for Education memungkinkan pengajar dan siswa untuk menggunakan Figma Pro secara gratis, yang mencakup berbagai fitur premium seperti versi sejarah tak terbatas, pembuatan tim tak terbatas, dan kolaborasi lebih efektif.</li> </ul> </li> <li>Kolaborasi Real-Time<ul> <li>Figma memungkinkan banyak orang untuk bekerja pada proyek yang sama dalam waktu yang bersamaan. Setiap perubahan yang dibuat oleh satu pengguna langsung terlihat oleh semua orang, yang membuat kolaborasi dalam tim desain menjadi sangat efisien.</li> </ul> </li> <li>Desain UI dan Prototipe Interaktif<ul> <li>Dengan Figma, pengguna dapat membuat desain UI yang interaktif dan prototipe fungsional yang dapat diujicoba langsung. Figma mendukung pembuatan animasi dan transisi yang dapat memberikan gambaran nyata tentang bagaimana aplikasi atau situs web akan berfungsi.</li> </ul> </li> <li>Pengelolaan Versi dan Sejarah Proyek<ul> <li>Figma menyimpan riwayat desain yang memungkinkan pengguna untuk melacak perubahan, mengembalikan desain ke versi sebelumnya, dan mengelola iterasi desain yang lebih mudah.</li> </ul> </li> <li>Plugin dan Integrasi<ul> <li>Figma mendukung berbagai plugin yang memungkinkan integrasi dengan alat lain, seperti Slack, Jira, dan Zeplin. Plugin ini dapat digunakan untuk mempercepat alur kerja dan meningkatkan kolaborasi antara desainer dan pengembang.</li> </ul> </li> <li>Desain Responsif dan Desain Kolaboratif<ul> <li>Figma memungkinkan pembuatan desain responsif yang dapat disesuaikan dengan berbagai ukuran layar dan perangkat. Fitur desain kolaboratif memungkinkan pengajar dan siswa bekerja bersama pada proyek yang sama, meningkatkan pemahaman dan keterampilan desain.</li> </ul> </li> <li>Feedback dan Komentar<ul> <li>Figma menyediakan fitur komentar yang memungkinkan pemangku kepentingan atau anggota tim lainnya untuk memberikan umpan balik langsung pada desain. Fitur ini sangat berguna untuk memastikan komunikasi yang jelas dan meminimalkan kesalahan dalam desain.</li> </ul> </li> <li>Mudah Akses Melalui Web<ul> <li>Figma adalah aplikasi berbasis web, yang berarti tidak perlu instalasi perangkat lunak tambahan dan bisa diakses dari perangkat apapun yang memiliki koneksi internet, baik itu laptop, desktop, atau tablet.</li> </ul> </li> </ol>"},{"location":"tools/figma/#12132-keunggulan-figma","title":"12.13.2 Keunggulan Figma","text":"<ol> <li>Fitur Premium Tanpa Biaya<ul> <li>Akses gratis ke fitur premium memungkinkan pengajar dan siswa untuk menggunakan Figma tanpa harus membayar biaya berlangganan. Ini sangat berguna untuk pendidikan desain di sekolah, perguruan tinggi, dan universitas yang memiliki anggaran terbatas.</li> </ul> </li> <li>Kolaborasi dalam Waktu Nyata<ul> <li>Figma membuat kolaborasi tim menjadi lebih mudah karena memungkinkan anggota tim untuk bekerja bersama secara langsung pada desain yang sama tanpa hambatan jarak atau waktu.</li> </ul> </li> <li>Platform Berbasis Cloud<ul> <li>Karena berbasis cloud, Figma memudahkan akses ke proyek dari perangkat apapun yang terhubung ke internet, memungkinkan pengajar dan siswa untuk bekerja secara fleksibel di luar jam kelas.</li> </ul> </li> <li>Pengelolaan Desain yang Efisien<ul> <li>Figma menawarkan berbagai alat manajemen desain yang efisien, seperti pengelolaan versi dan prototipe interaktif. Ini membantu siswa untuk membangun portofolio desain yang lebih terstruktur dan profesional.</li> </ul> </li> <li>Peningkatan Keterampilan Kolaborasi<ul> <li>Dengan menggunakan Figma dalam lingkungan pendidikan, siswa dapat belajar cara bekerja dengan tim dalam proyek desain nyata, meningkatkan keterampilan komunikasi dan kolaborasi mereka.</li> </ul> </li> <li>Integrasi dengan Alat Lain<ul> <li>Figma for Education memungkinkan integrasi dengan berbagai alat populer seperti Slack, Jira, dan GitHub, yang memudahkan siswa dan pengajar untuk berkolaborasi dalam lingkungan pengembangan perangkat lunak atau manajemen proyek.</li> </ul> </li> </ol>"},{"location":"tools/figma/#12133-kekurangan-figma","title":"12.13.3 Kekurangan Figma","text":"<ol> <li>Ketergantungan pada Koneksi Internet<ul> <li>Figma sepenuhnya berbasis web, yang berarti pengguna harus selalu terhubung ke internet untuk dapat mengakses dan bekerja dengan proyek desain. Hal ini dapat menjadi kendala jika koneksi internet tidak stabil atau terbatas.</li> </ul> </li> <li>Bergantung pada Perangkat yang Memadai<ul> <li>Meskipun Figma dapat diakses melalui web, perangkat yang digunakan harus memiliki spesifikasi yang memadai, terutama untuk desain yang lebih kompleks. Pengguna dengan perangkat keras yang lebih rendah mungkin mengalami keterlambatan atau kesulitan dalam menjalankan aplikasi dengan lancar.</li> </ul> </li> <li>Kurva Pembelajaran untuk Pengguna Baru<ul> <li>Meskipun Figma sangat intuitif, bagi siswa yang baru pertama kali bekerja dengan alat desain digital, ada kurva pembelajaran untuk memahami semua fitur dan fungsionalitas yang tersedia.</li> </ul> </li> </ol>"},{"location":"tools/figma/#12134-lisensi-dan-akses-figma-education","title":"12.13.4 Lisensi dan Akses Figma Education","text":"<ol> <li>Pendaftaran dan Persyaratan<ul> <li>Pengajar dan siswa dapat mendaftar untuk Figma for Education dengan menggunakan alamat email akademik yang valid. Figma for Education memberi mereka akses ke fitur-fitur premium secara gratis selama masa pendidikan mereka.</li> </ul> </li> <li>Akses Seumur Hidup untuk Pengajar<ul> <li>Pengajar yang terdaftar dapat terus menggunakan Figma for Education setelah masa pendidikan berakhir, selagi mereka masih terlibat dalam kegiatan pendidikan. Ini memungkinkan pengajar untuk terus mengembangkan keterampilan desain mereka setelah mengajar.</li> </ul> </li> <li>Akses Gratis untuk Siswa<ul> <li>Siswa dapat menikmati akses gratis selama mereka terdaftar di institusi pendidikan dan dapat memanfaatkan semua fitur premium Figma tanpa biaya selama masa studi mereka.</li> </ul> </li> </ol>"},{"location":"tools/figma/#12135-penggunaan-figma-dalam-proyek-pengembangan","title":"12.13.5 Penggunaan Figma dalam Proyek Pengembangan","text":"<ol> <li>Desain Antarmuka Pengguna (UI)<ul> <li>Figma memungkinkan siswa untuk membuat desain antarmuka pengguna yang fungsional dan interaktif, yang merupakan keterampilan penting dalam pengembangan aplikasi dan perangkat lunak.</li> </ul> </li> <li>Prototipe dan Wireframe<ul> <li>Siswa dapat membuat prototipe dan wireframe untuk aplikasi web atau mobile, yang memberikan gambaran awal tentang bagaimana produk akhir akan terlihat dan berfungsi.</li> </ul> </li> <li>Kolaborasi Tim<ul> <li>Dalam proyek kelompok atau tim, Figma memungkinkan siswa untuk berkolaborasi secara real-time, membangun keterampilan kerja tim yang sangat dibutuhkan di dunia industri.</li> </ul> </li> <li>Pembuatan Portfolio<ul> <li>Figma for Education memungkinkan siswa untuk mengembangkan portofolio desain mereka dengan mudah, yang dapat digunakan untuk melamar pekerjaan atau magang setelah lulus.</li> </ul> </li> </ol>"},{"location":"tools/intro/","title":"BAB 12 REKOMENDASI ALAT PENGEMBANGAN","text":"<p>Penggunaan alat yang tepat dapat meningkatkan efisiensi pengembangan, pengujian, dan pemeliharaan sistem. Berikut adalah rekomendasi alat berdasarkan kategori, yang mencakup alat pengembangan, pengujian, monitoring, logging, desain, dan analisis. Alat-alat ini dikhususkan untuk pengembangan dengan CodeIgniter, Laravel, dan FastAPI, dengan pembagian berdasarkan apakah alat tersebut berbayar atau gratis/open source.</p>"},{"location":"tools/laragon/","title":"12.9 Laragon","text":"<p>Laragon adalah lingkungan pengembangan lokal (local development environment) yang ringan dan mudah digunakan, dirancang untuk mempermudah pengembangan aplikasi web berbasis PHP, seperti WordPress, Laravel, atau aplikasi berbasis teknologi web lainnya. Laragon menyediakan alat dan server yang diperlukan untuk menjalankan aplikasi secara lokal, termasuk server web Apache atau Nginx, database MySQL atau MariaDB, serta PHP dan beberapa alat lain yang dapat digunakan untuk pengembangan web. Dengan antarmuka pengguna yang ramah, Laragon sangat cocok untuk pengembang yang ingin memulai pengembangan aplikasi secara cepat tanpa perlu konfigurasi rumit.</p>"},{"location":"tools/laragon/#1291-fitur-utama-laragon","title":"12.9.1 Fitur Utama Laragon","text":"<ol> <li>Instalasi Mudah<ul> <li>Laragon menyediakan instalasi yang sangat mudah, dengan sekali klik untuk menginstal seluruh lingkungan pengembangan yang dibutuhkan. Ini menghemat waktu dan usaha dalam menyiapkan server lokal.</li> </ul> </li> <li>Dukungan Multi-Stack<ul> <li>Laragon mendukung beberapa stack pengembangan populer seperti PHP, Node.js, Python, Ruby, dan lainnya. Pengguna dapat memilih stack sesuai kebutuhan proyek mereka.</li> </ul> </li> <li>Server Web dan Database<ul> <li>Laragon dilengkapi dengan server web Apache atau Nginx, serta database MySQL atau MariaDB untuk menjalankan aplikasi berbasis PHP dan MySQL.</li> <li>Memungkinkan pengelolaan aplikasi berbasis PHP dengan konfigurasi yang sederhana dan tidak memerlukan setup server yang rumit.</li> </ul> </li> <li>Manajemen Virtual Host<ul> <li>Memudahkan pembuatan dan pengelolaan virtual host dengan mudah, termasuk pembuatan domain lokal dan pengalihan otomatis ke direktori aplikasi yang tepat.</li> </ul> </li> <li>Pengelolaan SSL<ul> <li>Laragon mendukung pengelolaan SSL untuk aplikasi yang memerlukan HTTPS, memungkinkan pengembang menguji aplikasi mereka dengan keamanan yang sesuai.</li> </ul> </li> <li>Portabel dan Ringan<ul> <li>Laragon dapat dijalankan sebagai aplikasi portabel, memungkinkan pengembang untuk mengonfigurasi dan membawa lingkungan pengembangan mereka ke komputer lain tanpa memerlukan instalasi ulang.</li> </ul> </li> <li>Akses ke Alat Pengembangan Populer<ul> <li>Laragon mengintegrasikan berbagai alat pengembangan seperti Composer (untuk manajeman dependensi PHP), Git, dan PHPUnit, sehingga memudahkan pengembang dalam bekerja dengan alat-alat tersebut.</li> </ul> </li> <li>Antarmuka Pengguna yang Intuitif<ul> <li>Dengan antarmuka grafis yang ramah pengguna, Laragon menyediakan tampilan yang jelas dan memungkinkan pengelolaan server, database, dan aplikasi dengan mudah.</li> </ul> </li> <li>Dukungan untuk Framework PHP<ul> <li>Laragon menyediakan dukungan bawaan untuk berbagai framework PHP seperti Laravel, Symfony, dan CodeIgniter, serta memungkinkan instalasi aplikasi seperti WordPress hanya dengan beberapa klik.</li> </ul> </li> <li>Lingkungan Pengembangan Isolated<ul> <li>Setiap proyek dapat dikelola dalam lingkungan terisolasi, sehingga tidak mengganggu proyek lain yang berjalan di Laragon.</li> </ul> </li> </ol>"},{"location":"tools/laragon/#1292-keunggulan-laragon","title":"12.9.2 Keunggulan Laragon","text":"<ol> <li>Instalasi Cepat dan Mudah<ul> <li>Instalasi Laragon sangat cepat dan langsung menyediakan lingkungan pengembangan penuh yang siap digunakan, menghemat waktu konfigurasi.</li> </ul> </li> <li>Portabilitas<ul> <li>Dapat digunakan sebagai aplikasi portabel, memungkinkan pengembang untuk bekerja dengan konfigurasi yang konsisten di berbagai mesin tanpa instalasi ulang.</li> </ul> </li> <li>Kompatibilitas dengan Berbagai Framework<ul> <li>Laragon mendukung berbagai framework PHP dan aplikasi lain seperti WordPress, memberikan fleksibilitas untuk berbagai jenis proyek pengembangan.</li> </ul> </li> <li>Server dan Alat Pengembangan Terintegrasi<ul> <li>Menyediakan server web, database, dan alat pengembangan lainnya dalam satu paket, mengurangi kebutuhan untuk mengonfigurasi berbagai alat secara terpisah.</li> </ul> </li> <li>Dukungan SSL<ul> <li>Laragon mempermudah pengaturan SSL untuk aplikasi web, yang penting bagi pengujian aplikasi berbasis HTTPS.</li> </ul> </li> <li>Pengelolaan Virtual Host yang Mudah<ul> <li>Menyediakan cara yang mudah dan efisien untuk membuat dan mengelola virtual host, memungkinkan pengembang untuk menyesuaikan pengaturan server untuk setiap proyek.</li> </ul> </li> </ol>"},{"location":"tools/laragon/#1293-kekurangan-laragon","title":"12.9.3 Kekurangan Laragon","text":"<ol> <li>Fokus Terbatas pada Pengembangan PHP<ul> <li>Walaupun Laragon mendukung berbagai teknologi, fokus utamanya adalah pada pengembangan aplikasi PHP. Ini mungkin tidak cocok untuk pengembang yang bekerja dengan bahasa pemrograman atau framework lain.</li> </ul> </li> <li>Tergantung pada Windows<ul> <li>Laragon sebagian besar dirancang untuk sistem operasi Windows, sehingga kurang fleksibel untuk pengembangan di sistem operasi lain seperti macOS atau Linux.</li> </ul> </li> <li>Kurang Populer Dibandingkan XAMPP atau WAMP<ul> <li>Meskipun sangat baik, Laragon tidak sepopuler XAMPP atau WAMP, sehingga sumber daya komunitas dan dokumentasi tidak sebanyak dua alat tersebut.</li> </ul> </li> <li>Kemungkinan Konflik dengan Pengaturan Lain<ul> <li>Meskipun dirancang untuk menghindari konflik, terkadang pengaturan atau konfigurasi lainnya di komputer bisa mengganggu operasi Laragon, terutama jika ada alat lain yang mengakses port atau sumber daya yang sama.</li> </ul> </li> </ol>"},{"location":"tools/laragon/#1294-lisensi-dan-versi-laragon","title":"12.9.4 Lisensi dan Versi Laragon","text":"<ol> <li>Versi Gratis<ul> <li>Laragon tersedia secara gratis untuk penggunaan pribadi dan pengembangan.</li> </ul> </li> <li>Versi Komersial<ul> <li>Laragon juga menawarkan versi berbayar dengan fitur tambahan seperti dukungan premium, tetapi sebagian besar fitur utama tersedia dalam versi gratis.</li> </ul> </li> </ol>"},{"location":"tools/laragon/#1295-penggunaan-laragon-dalam-proyek-pengembangan","title":"12.9.5 Penggunaan Laragon dalam Proyek Pengembangan","text":"<ol> <li>Lingkungan Pengembangan PHP<ul> <li>Ideal untuk pengembang PHP yang membutuhkan lingkungan pengembangan yang cepat dan terintegrasi untuk framework dan aplikasi berbasis PHP.</li> </ul> </li> <li>Pengembangan Aplikasi Web dengan Framework Populer<ul> <li>Laragon sangat cocok untuk pengembang yang menggunakan framework PHP seperti Laravel, Symfony, atau CodeIgniter, karena memberikan alat dan server yang diperlukan dalam satu paket.</li> </ul> </li> <li>Pengujian Aplikasi Berbasis HTTPS<ul> <li>Pengelolaan SSL yang mudah membuat Laragon menjadi pilihan yang baik untuk pengujian aplikasi berbasis HTTPS di lingkungan lokal.</li> </ul> </li> <li>Pengelolaan Beberapa Proyek dengan Virtual Host<ul> <li>Laragon memungkinkan pengelolaan banyak proyek secara bersamaan dengan pengaturan virtual host yang mudah, cocok untuk pengembang yang bekerja dengan beberapa aplikasi sekaligus.</li> </ul> </li> <li>Penggunaan Portabel dalam Pengembangan Bersama<ul> <li>Dengan versi portabel, Laragon memungkinkan pengembang untuk membawa lingkungan pengembangan mereka dan bekerja dengan konfigurasi yang sama di mesin yang berbeda, mengurangi perbedaan lingkungan antar pengembang.</li> </ul> </li> </ol>"},{"location":"tools/miro/","title":"12.14 Miro (Education Version)","text":"<p>Miro adalah platform kolaborasi visual yang memungkinkan tim untuk berkolaborasi, berbagi ide, dan merencanakan proyek dalam ruang kerja digital. Miro menyediakan papan putih virtual (virtual whiteboard) yang memungkinkan pengguna untuk membuat diagram, wireframe, mind map, dan berbagai macam visualisasi lainnya. Miro sangat populer di kalangan tim yang bekerja secara remote, serta di dunia pendidikan, karena kemampuannya untuk memfasilitasi kolaborasi secara real-time. Miro for Education adalah program khusus yang memberikan akses gratis ke Fitur Premium Miro bagi pengajar dan siswa untuk mendukung pembelajaran, proyek kolaboratif, dan pengembangan ide kreatif dalam lingkungan pendidikan.</p>"},{"location":"tools/miro/#12141-fitur-utama-miro","title":"12.14.1 Fitur Utama Miro","text":"<ol> <li>Papan Kerja Kolaboratif Real-Time<ul> <li>Miro memungkinkan pengguna untuk bekerja bersama pada papan yang sama secara real-time, membuatnya ideal untuk proyek kelompok dan diskusi di kelas. Pengguna dapat menambahkan elemen seperti sticky notes, gambar, diagram, dan teks di papan kerja yang sama.</li> </ul> </li> <li>Template Edukasi<ul> <li>Miro menyediakan berbagai template yang dirancang khusus untuk pendidikan, termasuk template untuk pembuatan mind map, diagram alir, perencanaan proyek, dan wireframe. Template ini memudahkan siswa dan pengajar untuk memulai dengan ide-ide yang terstruktur.</li> </ul> </li> <li>Alat Visualisasi dan Diagram<ul> <li>Miro menyediakan alat untuk membuat diagram dan flowchart, yang memungkinkan penggunanya untuk menggambarkan ide-ide atau proses secara visual. Ini sangat berguna dalam merencanakan proyek atau menggambarkan konsep-konsep kompleks dengan cara yang mudah dipahami.</li> </ul> </li> <li>Komentar dan Umpan Balik<ul> <li>Fitur komentar di Miro memungkinkan pengajar dan siswa untuk memberikan umpan balik langsung pada papan kerja. Ini sangat berguna untuk kolaborasi, diskusi, dan evaluasi ide-ide secara langsung dalam satu tempat.</li> </ul> </li> <li>Integrasi dengan Alat Lain<ul> <li>Miro mendukung integrasi dengan berbagai alat populer yang digunakan dalam pendidikan dan pengembangan, seperti Slack, Google Drive, Microsoft Teams, dan banyak lagi. Ini memudahkan alur kerja yang terkoordinasi dengan alat lain yang sudah biasa digunakan oleh pengajar dan siswa.</li> </ul> </li> <li>Kolaborasi Asinkron<ul> <li>Selain kolaborasi real-time, Miro juga mendukung kolaborasi asinkron, di mana pengguna dapat bekerja di papan yang sama pada waktu yang berbeda. Hal ini memudahkan proyek yang melibatkan banyak orang di berbagai zona waktu.</li> </ul> </li> <li>Papan Berbagi dan Presentasi<ul> <li>Miro memungkinkan pengguna untuk membagikan papan mereka dengan orang lain dan menggunakannya untuk presentasi interaktif. Pengguna dapat mengatur papan untuk presentasi yang lebih terstruktur atau berbagi hasil diskusi dengan audiens yang lebih luas.</li> </ul> </li> <li>Keamanan dan Kontrol Akses<ul> <li>Fitur kontrol akses yang disediakan Miro memungkinkan pengajar untuk mengatur siapa yang dapat mengedit atau melihat papan kerja. Ini memberikan pengendalian penuh atas privasi dan keamanan materi yang dikerjakan di dalam ruang kelas atau proyek.</li> </ul> </li> </ol>"},{"location":"tools/miro/#12142-keunggulan-miro","title":"12.14.2 Keunggulan Miro","text":"<ol> <li>Akses Gratis ke Fitur Premium<ul> <li>Program Miro for Education memberikan akses gratis ke fitur premium bagi pengajar dan siswa, memungkinkan mereka untuk memanfaatkan seluruh potensi Miro tanpa biaya.</li> </ul> </li> <li>Kolaborasi Visual yang Efektif<ul> <li>Miro memungkinkan kolaborasi visual yang lebih efektif, sehingga ide-ide dapat digambarkan secara jelas dan mudah dipahami. Fitur visualisasi ini sangat berguna untuk siswa yang lebih suka belajar melalui visual daripada teks.</li> </ul> </li> <li>Mendukung Pembelajaran Jarak Jauh<ul> <li>Karena berbasis cloud, Miro memungkinkan kolaborasi jarak jauh dengan mudah, baik itu di kelas virtual atau dalam proyek kelompok yang melibatkan anggota dari berbagai lokasi.</li> </ul> </li> <li>Template Khusus untuk Pendidikan<ul> <li>Fitur template khusus untuk pendidikan memungkinkan pengajar dan siswa untuk lebih cepat memulai proyek dan tugas-tugas kelas dengan struktur yang telah disiapkan sebelumnya.</li> </ul> </li> <li>Pengelolaan Proyek yang Mudah<ul> <li>Fitur papan kerja di Miro memungkinkan pengajar dan siswa untuk merencanakan proyek, merancang wireframe, atau membuat alur proses secara bersama-sama, meningkatkan pengelolaan proyek secara lebih efisien.</li> </ul> </li> <li>Mendukung Berbagai Metode Pengajaran<ul> <li>Miro sangat berguna untuk berbagai metode pengajaran, baik itu diskusi kelas, pembelajaran berbasis proyek, atau sesi brainstorming. Miro mendukung beragam gaya pembelajaran dan memungkinkan pengajar untuk menyesuaikan alat dengan kebutuhan mereka.</li> </ul> </li> <li>Fasilitas Pembelajaran Kolaboratif<ul> <li>Miro memfasilitasi pembelajaran kolaboratif, yang memungkinkan siswa untuk bekerja bersama dalam menyelesaikan masalah atau merencanakan proyek. Ini meningkatkan keterampilan komunikasi dan kerja tim yang sangat dibutuhkan di dunia profesional.</li> </ul> </li> </ol>"},{"location":"tools/miro/#12143-kekurangan-miro","title":"12.14.3 Kekurangan Miro","text":"<ol> <li>Ketergantungan pada Koneksi Internet<ul> <li>Miro adalah aplikasi berbasis cloud, yang memerlukan koneksi internet yang stabil untuk akses dan kolaborasi. Hal ini dapat menjadi kendala di daerah dengan konektivitas internet yang terbatas atau tidak stabil.</li> </ul> </li> <li>Tantangan untuk Pengguna Baru<ul> <li>Bagi pengguna yang baru pertama kali menggunakan Miro, ada kurva pembelajaran untuk memahami semua fitur dan cara terbaik untuk menggunakannya secara efektif. Meskipun antarmuka cukup intuitif, banyaknya fitur yang tersedia dapat membuat pengguna merasa sedikit kewalahan.</li> </ul> </li> <li>Membutuhkan Perangkat dengan Spesifikasi yang Memadai<ul> <li>Pengguna dengan perangkat yang lebih rendah mungkin mengalami sedikit keterlambatan atau kesulitan ketika bekerja dengan papan yang besar dan kompleks, terutama jika terdapat banyak elemen yang ditambahkan.</li> </ul> </li> <li>Fitur Terbatas pada Versi Gratis<ul> <li>Meskipun Miro for Education memberikan akses gratis ke banyak fitur premium, beberapa fitur canggih mungkin masih dibatasi untuk pengguna dengan langganan berbayar.</li> </ul> </li> </ol>"},{"location":"tools/miro/#12144-lisensi-dan-akses-miro","title":"12.14.4 Lisensi dan Akses Miro","text":"<ol> <li>Pendaftaran dan Persyaratan<ul> <li>Pengajar dan siswa yang memiliki alamat email akademik yang valid dapat mendaftar untuk Miro for Education. Dengan program ini, mereka dapat mengakses papan kerja premium dan memanfaatkan semua fitur Miro tanpa biaya.</li> </ul> </li> <li>Akses Sepanjang Tahun Akademik<ul> <li>Akses ke Miro for Education diberikan sepanjang tahun akademik, dengan pengajaran yang memungkinkan siswa dan pengajar menggunakan platform ini untuk berbagai tugas dan kolaborasi sepanjang semester.</li> </ul> </li> <li>Bergabung dengan Tim Miro Edu<ul> <li>Pengguna yang terdaftar dalam Miro for Education dapat bergabung dengan tim atau ruang kerja pendidikan di Miro untuk kolaborasi dengan siswa atau pengajar lainnya dalam satu proyek yang lebih besar.</li> </ul> </li> </ol>"},{"location":"tools/miro/#12145-penggunaan-miro-dalam-proyek-pengembangan","title":"12.14.5 Penggunaan Miro dalam Proyek Pengembangan","text":"<ol> <li>Perencanaan Proyek<ul> <li>Miro sangat berguna untuk merencanakan proyek secara visual, seperti pengembangan perangkat lunak, riset, atau proyek desain. Dengan fitur diagram dan peta konsep, pengguna dapat memetakan langkah-langkah yang diperlukan untuk menyelesaikan proyek.</li> </ul> </li> <li>Brainstorming dan Ideasi<ul> <li>Dalam sesi brainstorming, Miro memungkinkan semua anggota tim untuk berpartisipasi dan berbagi ide secara langsung di papan kerja yang sama, yang sangat mendukung inovasi dan kreativitas.</li> </ul> </li> <li>Desain Wireframe dan Prototipe<ul> <li>Miro dapat digunakan untuk membuat wireframe dan prototipe aplikasi atau situs web secara kolaboratif, memungkinkan tim desain untuk merencanakan dan mengevaluasi desain awal bersama-sama.</li> </ul> </li> <li>Kolaborasi Jarak Jauh<ul> <li>Fitur kolaborasi real-time dan asinkron menjadikan Miro sangat efektif untuk proyek kolaboratif yang melibatkan siswa atau pengajar dari berbagai lokasi, memungkinkan mereka untuk bekerja bersama meskipun terpisah jarak.</li> </ul> </li> </ol>"},{"location":"tools/mkdocs/","title":"12.18 MkDocs","text":"<p>MkDocs adalah alat yang digunakan untuk membuat dokumentasi proyek dengan menggunakan Markdown sebagai format penulisannya. MkDocs menyediakan cara yang sederhana dan cepat untuk menghasilkan situs web dokumentasi yang mudah dibaca dan dinavigasi, serta memungkinkan pengelolaan dokumentasi secara efisien. Dengan menggunakan MkDocs, pengembang dapat mengonversi file Markdown menjadi halaman-halaman HTML yang dapat disajikan di browser. MkDocs juga menyediakan berbagai tema dan plugin yang dapat disesuaikan untuk memenuhi kebutuhan dokumentasi yang berbeda.</p>"},{"location":"tools/mkdocs/#12181-fitur-utama-mkdocs","title":"12.18.1 Fitur Utama MkDocs","text":"<ol> <li>Antarmuka Sederhana<ul> <li>MkDocs menggunakan Markdown untuk menulis dokumentasi, yang lebih sederhana dan lebih mudah dipelajari daripada format penulisan lainnya. Markdown memudahkan penulis untuk fokus pada konten tanpa harus mengkhawatirkan format HTML yang rumit.</li> </ul> </li> <li>Pengelolaan Halaman Dokumentasi<ul> <li>MkDocs memungkinkan pengguna untuk mengatur dokumentasi dalam struktur yang jelas dengan folder dan file Markdown. Setiap halaman yang ditulis dalam Markdown dapat dipetakan ke halaman HTML di situs web dokumentasi.</li> </ul> </li> <li>Tema yang Dapat Disesuaikan<ul> <li>MkDocs menyediakan beberapa tema bawaan, termasuk tema yang responsif dan modern. Pengguna dapat memilih tema yang paling sesuai dengan kebutuhan mereka, atau mengkustomisasi tema untuk menciptakan desain dokumentasi yang unik.</li> </ul> </li> <li>Pengaturan Navigasi yang Mudah<ul> <li>Dengan MkDocs, struktur navigasi situs dokumentasi dapat diatur dengan mudah dalam file konfigurasi. Daftar isi dan menu navigasi otomatis dibuat berdasarkan struktur folder dan file Markdown yang ada.</li> </ul> </li> <li>Dukungan Plugin<ul> <li>MkDocs mendukung berbagai plugin yang memungkinkan penambahan fungsionalitas tambahan, seperti pencarian, integrasi dengan sistem kontrol versi, dan bahkan pelaporan analitik situs. Plugin ini dapat memperkaya pengalaman pengguna dan meningkatkan kualitas dokumentasi.</li> </ul> </li> <li>Pembuatan Dokumentasi Otomatis<ul> <li>Setelah semua halaman dokumentasi selesai, MkDocs dapat dengan mudah mengonversinya menjadi situs web statis dalam format HTML yang siap untuk diunggah ke server web atau platform seperti GitHub Pages atau Netlify.</li> </ul> </li> <li>Integrasi dengan GitHub Pages<ul> <li>MkDocs sangat kompatibel dengan GitHub Pages, memungkinkan penggunanya untuk meng-host situs dokumentasi mereka langsung di GitHub secara gratis. Hal ini membuatnya ideal untuk proyek open-source atau dokumentasi proyek yang dikelola secara publik.</li> </ul> </li> <li>Dukungan Versi<ul> <li>MkDocs mendukung pengelolaan beberapa versi dokumentasi. Hal ini sangat berguna untuk proyek yang terus berkembang, di mana dokumentasi perlu dikelola untuk versi yang berbeda dari perangkat lunak atau sistem yang sedang dikembangkan.</li> </ul> </li> </ol>"},{"location":"tools/mkdocs/#12182-keunggulan-mkdocs","title":"12.18.2 Keunggulan MkDocs","text":"<ol> <li>Mudah Digunakan dan Ringan<ul> <li>MkDocs sangat mudah dipasang dan digunakan. Dengan sedikit konfigurasi, pengguna dapat mulai menulis dokumentasi menggunakan Markdown dan menghasilkan situs web statis dalam hitungan menit.</li> </ul> </li> <li>Dokumentasi yang Bersih dan Responsif<ul> <li>Situs dokumentasi yang dihasilkan oleh MkDocs memiliki tampilan yang bersih, terstruktur, dan responsif di berbagai perangkat. Ini memastikan pengalaman pengguna yang baik saat membaca dokumentasi, baik di desktop maupun perangkat mobile.</li> </ul> </li> <li>Kompatibilitas dengan Markdown<ul> <li>Karena menggunakan Markdown sebagai format utama, penulis dokumentasi tidak perlu mempelajari bahasa markup lain yang rumit. Markdown menawarkan cara cepat dan efisien untuk menulis dokumentasi yang mudah dibaca.</li> </ul> </li> <li>Fleksibilitas Tema dan Kustomisasi<ul> <li>MkDocs menawarkan berbagai tema dan opsi kustomisasi yang memungkinkan pengguna untuk menyesuaikan tampilan situs dokumentasi mereka sesuai dengan branding atau preferensi desain.</li> </ul> </li> <li>Integrasi dengan GitHub Pages<ul> <li>Kemudahan untuk meng-host dokumentasi di GitHub Pages membuat MkDocs sangat ideal untuk proyek open-source atau proyek yang berbasis di GitHub, memungkinkan dokumentasi untuk diperbarui dan dipublikasikan secara otomatis bersama dengan kode sumber.</li> </ul> </li> <li>Dukungan Plugin<ul> <li>Plugin memungkinkan untuk memperluas fungsionalitas MkDocs, sehingga dokumentasi dapat disesuaikan lebih lanjut sesuai dengan kebutuhan khusus, seperti menambahkan pencarian, analitik, atau sistem versi.</li> </ul> </li> </ol>"},{"location":"tools/mkdocs/#12183-kekurangan-mkdocs","title":"12.18.3 Kekurangan MkDocs","text":"<ol> <li>Kurang Fitur untuk Dokumentasi Interaktif<ul> <li>MkDocs lebih fokus pada pembuatan dokumentasi statis, sehingga kurang cocok untuk proyek yang membutuhkan dokumentasi interaktif atau dinamis. Untuk fitur interaktif, pengguna mungkin perlu mencari alat lain.</li> </ul> </li> <li>Kemampuan Kustomisasi Terbatas<ul> <li>Meskipun MkDocs memungkinkan kustomisasi tema, pengguna dengan kebutuhan desain yang sangat spesifik mungkin merasa terbatas dengan opsi yang ada, terutama dalam hal kustomisasi tampilan yang lebih mendalam.</li> </ul> </li> <li>Kurangnya Fitur WYSIWYG<ul> <li>MkDocs tidak menyediakan editor WYSIWYG (What You See Is What You Get), yang berarti pengguna harus menulis dokumentasi dalam format Markdown secara manual, tanpa pratinjau langsung seperti yang tersedia di beberapa alat lain.</li> </ul> </li> </ol>"},{"location":"tools/mkdocs/#12184-lisensi-dan-versi-mkdocs","title":"12.18.4 Lisensi dan Versi MkDocs","text":"<ol> <li>Lisensi<ul> <li>MkDocs adalah proyek open-source yang dilisensikan di bawah MIT License, yang memungkinkan pengguna untuk menggunakan, memodifikasi, dan mendistribusikan perangkat lunak ini secara bebas.</li> </ul> </li> <li>Versi<ul> <li>MkDocs selalu diperbarui dengan fitur baru dan perbaikan bug. Pembaruan dapat diunduh melalui manajer paket Python seperti pip, dan pengguna dapat memeriksa dokumentasi resmi untuk informasi lebih lanjut tentang versi terbaru.</li> </ul> </li> </ol>"},{"location":"tools/mkdocs/#12185-penggunaan-mkdocs-dalam-proyek-pengembangan","title":"12.18.5 Penggunaan MkDocs dalam Proyek Pengembangan","text":"<ol> <li>Membuat Dokumentasi Proyek<ul> <li>MkDocs sangat ideal untuk membuat dokumentasi proyek pengembangan, baik untuk perangkat lunak open-source maupun proyek internal. Dokumentasi dapat meliputi panduan pengguna, instalasi, API, dan panduan pengembang lainnya.</li> </ul> </li> <li>Situs Dokumentasi untuk Proyek Open-Source<ul> <li>MkDocs adalah pilihan populer untuk membuat situs dokumentasi untuk proyek open-source yang di-host di GitHub. Dengan kemampuan untuk terintegrasi dengan GitHub Pages, pengembang dapat dengan mudah memperbarui dokumentasi bersamaan dengan kode sumber.</li> </ul> </li> <li>Pengelolaan Dokumentasi Versi<ul> <li>MkDocs memungkinkan pengelolaan beberapa versi dokumentasi, yang sangat berguna untuk proyek yang memiliki banyak versi perangkat lunak atau modul yang perlu didokumentasikan.</li> </ul> </li> <li>Dokumentasi untuk Proyek Internal<ul> <li>MkDocs juga dapat digunakan untuk proyek internal, membantu tim pengembang dan pemangku kepentingan untuk mengakses dokumentasi teknis dengan cara yang terorganisir dan mudah dinavigasi.</li> </ul> </li> </ol>"},{"location":"tools/navicat/","title":"Navicat Premium","text":""},{"location":"tools/navicat/#126-navicat-premium","title":"12.6 Navicat Premium","text":"<p>Navicat Premium adalah alat manajemen database berbasis GUI (Graphical User Interface) yang mendukung berbagai jenis database secara terintegrasi. Dikembangkan oleh PremiumSoft, Navicat Premium memungkinkan pengguna untuk mengelola database seperti MySQL, MariaDB, PostgreSQL, SQLite, SQL Server, Oracle, dan MongoDB dalam satu aplikasi. Alat ini dirancang untuk meningkatkan produktivitas pengembang, administrator, dan analis data melalui antarmuka yang intuitif dan berbagai fitur canggih.</p>"},{"location":"tools/navicat/#1261-fitur-utama-navicat-premium","title":"12.6.1 Fitur Utama Navicat Premium","text":"<ol> <li> <p>Dukungan Multi-Database</p> <ul> <li>Dapat terhubung ke berbagai jenis database dalam satu antarmuka.</li> <li>Mendukung koneksi ke server lokal, remote, atau layanan cloud seperti Amazon RDS, Google Cloud, dan Azure.</li> </ul> </li> <li> <p>Antarmuka Pengguna Modern</p> <ul> <li>Navigasi yang mudah dengan desain antarmuka yang bersih dan profesional.</li> <li>Menyediakan tampilan visual untuk tabel, hubungan, dan data.</li> </ul> </li> <li> <p>Query Builder</p> <ul> <li>Membuat query SQL tanpa menulis kode manual.</li> <li>Mendukung drag-and-drop untuk memilih tabel dan kolom.</li> </ul> </li> <li> <p>Manajemen Data</p> <ul> <li>Import dan export data dalam berbagai format seperti CSV, Excel, JSON, XML, dan SQL.</li> <li>Editor data yang memudahkan manipulasi data dalam format tabel.</li> </ul> </li> <li> <p>Backup dan Restore</p> <ul> <li>Mendukung pencadangan dan pemulihan database dengan antarmuka visual.</li> </ul> </li> <li> <p>Replikasi dan Sinkronisasi</p> <ul> <li>Sinkronisasi data antar server dengan mudah.</li> <li>Sinkronisasi skema untuk memastikan struktur database tetap konsisten.</li> </ul> </li> <li> <p>Visualisasi Relasi</p> <ul> <li>Diagram ERD (Entity-Relationship Diagram) untuk memvisualisasikan hubungan antar tabel.</li> </ul> </li> <li> <p>Alat Debugging</p> <ul> <li>Visual Explain Plan untuk menganalisis kinerja query.</li> <li>Debugger untuk mengidentifikasi kesalahan dalam prosedur tersimpan (stored procedures) dan fungsi.</li> </ul> </li> <li> <p>Automasi</p> <ul> <li>Menyediakan Scheduler untuk menjalankan tugas otomatis seperti sinkronisasi, pencadangan, atau eksekusi query.</li> </ul> </li> <li> <p>Keamanan</p> <ul> <li>Mendukung koneksi aman melalui SSL dan SSH Tunnel.</li> <li>Mendukung autentikasi berbasis Kerberos.</li> </ul> </li> </ol>"},{"location":"tools/navicat/#1262-keunggulan-navicat-premium","title":"12.6.2 Keunggulan Navicat Premium","text":"<ol> <li>Kompatibilitas Multi-Platform<ul> <li>Tersedia untuk Windows, macOS, dan Linux.</li> </ul> </li> <li>Mendukung Banyak Database<ul> <li>Mengelola berbagai jenis database dalam satu aplikasi, menghemat waktu dan biaya.</li> </ul> </li> <li>Fleksibilitas Format Data<ul> <li>Mempermudah transfer data antar format dan server.</li> </ul> </li> <li>Antarmuka Visual untuk Proses Kompleks<ul> <li>Membantu pengguna yang tidak terbiasa dengan command-line untuk mengelola database dengan lebih nyaman.</li> </ul> </li> <li>Dukungan Cloud<ul> <li>Koneksi mudah ke layanan cloud database seperti Amazon RDS, Google Cloud, dan Microsoft Azure.</li> </ul> </li> <li>Fitur Automasi yang Kuat<ul> <li>Menjadwalkan tugas untuk pencadangan, sinkronisasi, atau eksekusi query, sehingga meminimalkan intervensi manual.</li> </ul> </li> </ol>"},{"location":"tools/navicat/#1263-kekurangan-navicat-premium","title":"12.6.3 Kekurangan Navicat Premium","text":"<ol> <li>Harga Tinggi<ul> <li>Biaya lisensi cukup mahal, terutama bagi individu atau usaha kecil.</li> </ul> </li> <li>Tidak Open Source<ul> <li>Tidak dapat dikustomisasi sesuai kebutuhan spesifik seperti alat open source.</li> </ul> </li> <li>Konsumsi Sumber Daya<ul> <li>Membutuhkan lebih banyak memori dan CPU dibandingkan alat database sederhana.</li> </ul> </li> <li>Kompleks untuk Pemula<ul> <li>Meskipun memiliki antarmuka GUI, fitur yang terlalu banyak dapat membingungkan pengguna baru.</li> </ul> </li> </ol>"},{"location":"tools/navicat/#1264-lisensi-dan-versi-navicat-premium","title":"12.6.4 Lisensi dan Versi Navicat Premium","text":"<ol> <li>Versi Berbayar (Premium)<ul> <li>Mendukung semua jenis database dan fitur lengkap.</li> <li>Lisensi tersedia untuk individu, bisnis, dan institusi pendidikan.</li> <li>Harga berkisar dari \\(29 per bulan** untuk lisensi langganan atau sekitar **\\)1.299 untuk lisensi seumur hidup (harga dapat berbeda tergantung promo dan wilayah).</li> </ul> </li> <li>Versi Trial<ul> <li>Tersedia uji coba gratis selama 14 hari untuk semua fitur.</li> </ul> </li> </ol>"},{"location":"tools/navicat/#1265-penggunaan-navicat-premium-dalam-proyek-pengembangan","title":"12.6.5 Penggunaan Navicat Premium dalam Proyek Pengembangan","text":"<ol> <li>Pengelolaan Multi-Database<ul> <li>Ideal untuk tim yang menggunakan beberapa jenis database sekaligus, seperti MySQL untuk produksi dan MongoDB untuk analitik.</li> </ul> </li> <li>Pencadangan dan Sinkronisasi Data<ul> <li>Mempermudah pengaturan pencadangan rutin dan sinkronisasi data antar server.</li> </ul> </li> <li>Optimisasi Kinerja Query<ul> <li>Membantu mengidentifikasi bottleneck dalam query melalui Visual Explain Plan.</li> </ul> </li> <li>Pengelolaan Database Cloud<ul> <li>Mendukung koneksi ke layanan cloud database populer.</li> </ul> </li> <li>Automasi Proses Database<ul> <li>Membantu mengotomatiskan tugas-tugas berulang seperti pencadangan atau pengiriman laporan.</li> </ul> </li> </ol>"},{"location":"tools/notion/","title":"12.16 Notion Education","text":"<p>Notion adalah aplikasi produktivitas yang menggabungkan berbagai fungsi, seperti pencatat, manajer tugas, database, dan alat kolaborasi, dalam satu platform. Dengan antarmuka yang fleksibel dan berbagai template yang dapat disesuaikan, Notion memungkinkan pengguna untuk mengorganisir pekerjaan dan informasi mereka dengan cara yang sangat terstruktur namun tetap mudah digunakan. Notion memiliki versi gratis untuk individu, namun versi Notion Education memberikan akses premium tanpa biaya untuk mahasiswa dan pendidik, memberikan manfaat lebih dalam hal kapasitas penyimpanan, kolaborasi tim, dan fungsionalitas tambahan.</p>"},{"location":"tools/notion/#12161-fitur-utama-notion-education","title":"12.16.1 Fitur Utama Notion Education","text":"<ol> <li>Workspace yang Dapat Disesuaikan<ul> <li>Notion memungkinkan pengguna untuk membuat berbagai jenis halaman untuk mengorganisir informasi, seperti catatan, daftar tugas, dan proyek. Halaman-halaman ini bisa disesuaikan dengan berbagai jenis blok, termasuk teks, gambar, tabel, database, dan banyak lagi.</li> </ul> </li> <li>Database dan Tabel<ul> <li>Notion memiliki fitur database yang memungkinkan pengguna membuat tabel, daftar, atau galeri untuk mengorganisir dan melacak berbagai jenis informasi, seperti tugas, jadwal, atau ide. Pengguna dapat mengatur kolom, filter, dan mengkategorikan data dengan cara yang sangat fleksibel.</li> </ul> </li> <li>Kolaborasi Tim<ul> <li>Fitur kolaborasi memungkinkan pengguna untuk berbagi halaman dengan orang lain dan bekerja bersama dalam proyek atau tugas secara real-time. Notion mendukung pengeditan kolaboratif, memungkinkan banyak pengguna untuk mengedit halaman yang sama secara bersamaan.</li> </ul> </li> <li>Template untuk Penggunaan yang Lebih Cepat<ul> <li>Notion menyediakan berbagai template untuk memulai, mulai dari template catatan kuliah, manajemen proyek, hingga template untuk perencanaan pribadi. Template ini mempercepat pengguna dalam membuat dokumen atau halaman yang sesuai dengan kebutuhan mereka.</li> </ul> </li> <li>Pencatatan dan Pengelolaan Tugas<ul> <li>Notion memungkinkan pengguna untuk mencatat informasi secara detail, membuat daftar tugas, menetapkan tenggat waktu, dan melacak kemajuan. Semua informasi ini dapat diorganisir dalam satu halaman atau database yang terstruktur.</li> </ul> </li> <li>Integrasi dengan Alat Lain<ul> <li>Notion mendukung integrasi dengan berbagai alat lain seperti Google Calendar, Slack, dan berbagai alat lainnya. Hal ini memudahkan pengguna untuk menghubungkan Notion dengan aplikasi yang sudah mereka gunakan sehari-hari.</li> </ul> </li> <li>Offline Mode<ul> <li>Notion memungkinkan pengguna untuk mengakses dan mengedit dokumen secara offline, yang sangat berguna ketika tidak ada koneksi internet. Perubahan yang dilakukan akan disinkronkan kembali setelah koneksi internet tersedia.</li> </ul> </li> <li>Pencarian yang Canggih<ul> <li>Fitur pencarian Notion memungkinkan pengguna untuk menemukan catatan atau informasi yang mereka butuhkan dengan cepat, bahkan di dalam database yang besar. Pengguna dapat mencari berdasarkan kata kunci, tag, atau jenis konten.</li> </ul> </li> <li>Penyimpanan Cloud<ul> <li>Semua informasi yang disimpan di Notion otomatis disinkronkan ke cloud, memastikan bahwa data dapat diakses dari perangkat mana pun dan aman jika terjadi kerusakan perangkat.</li> </ul> </li> </ol>"},{"location":"tools/notion/#12162-keunggulan-notion-education","title":"12.16.2 Keunggulan Notion Education","text":"<ol> <li>Gratis untuk Mahasiswa dan Dosen<ul> <li>Versi pendidikan Notion memberikan akses premium tanpa biaya bagi mahasiswa dan pendidik yang terdaftar. Fitur premium ini mencakup penyimpanan tak terbatas, kolaborasi tim yang lebih mudah, dan fungsionalitas tambahan yang tidak tersedia di versi gratis.</li> </ul> </li> <li>Antarmuka yang Fleksibel dan Mudah Digunakan<ul> <li>Antarmuka Notion sangat fleksibel, memungkinkan pengguna untuk mendesain halaman mereka sesuai dengan kebutuhan pribadi. Pengguna dapat mengatur workspace mereka dengan cara yang paling produktif bagi mereka, baik untuk pencatatan kuliah, manajemen proyek, atau organisasi pribadi.</li> </ul> </li> <li>Fitur Kolaborasi yang Kuat<ul> <li>Fitur kolaborasi di Notion memungkinkan penggunanya bekerja bersama dalam proyek atau tugas secara real-time. Pengguna dapat memberi komentar, memberikan umpan balik, atau mendiskusikan ide langsung di dalam aplikasi, menjadikannya alat yang sangat berguna untuk proyek kelompok.</li> </ul> </li> <li>Template yang Mempercepat Penggunaan<ul> <li>Dengan berbagai template yang tersedia, pengguna dapat memulai dengan cepat tanpa perlu mendesain sistem dari awal. Ini sangat menghemat waktu dan memungkinkan pengguna untuk fokus pada pekerjaan yang lebih penting.</li> </ul> </li> <li>Kemudahan Akses di Berbagai Perangkat<ul> <li>Notion dapat diakses melalui berbagai perangkat, baik desktop maupun mobile. Hal ini memungkinkan pengguna untuk mengakses dan mengedit dokumen mereka kapan saja dan di mana saja.</li> </ul> </li> <li>Penyimpanan Tak Terbatas<ul> <li>Versi pendidikan menawarkan penyimpanan tanpa batas, yang sangat berguna bagi mahasiswa atau dosen yang perlu menyimpan banyak catatan atau materi kuliah.</li> </ul> </li> </ol>"},{"location":"tools/notion/#12163-kekurangan-notion-education","title":"12.16.3 Kekurangan Notion Education","text":"<ol> <li>Kurva Pembelajaran untuk Pengguna Baru<ul> <li>Meskipun Notion sangat fleksibel, pengguna baru mungkin merasa kewalahan dengan banyaknya fitur dan opsi kustomisasi. Dibutuhkan waktu untuk mempelajari dan memaksimalkan semua fitur Notion.</li> </ul> </li> <li>Tergantung pada Koneksi Internet<ul> <li>Meskipun Notion memiliki mode offline, beberapa fitur dan fungsionalitas dapat terbatas jika tidak terhubung ke internet. Ini bisa menjadi kendala bagi pengguna yang bekerja di tempat dengan koneksi internet yang tidak stabil.</li> </ul> </li> <li>Performa Tergantung pada Ukuran Halaman<ul> <li>Jika halaman atau database Notion terlalu besar atau kompleks, aplikasi ini bisa terasa lambat. Pengguna dengan banyak data mungkin merasakan penurunan kinerja, terutama di perangkat dengan sumber daya terbatas.</li> </ul> </li> <li>Fitur Terbatas di Versi Gratis untuk Pengguna Non-Edukasi<ul> <li>Versi gratis Notion memiliki keterbatasan, terutama terkait dengan kolaborasi tim dan penyimpanan file. Versi premium memberikan lebih banyak keuntungan, yang membuat pengguna non-edukasi harus membayar untuk mendapatkan fungsionalitas penuh.</li> </ul> </li> </ol>"},{"location":"tools/notion/#12164-lisensi-dan-akses-notion-education","title":"12.16.4 Lisensi dan Akses Notion Education","text":"<ol> <li>Lisensi Pendidikan<ul> <li>Mahasiswa dan pendidik yang terdaftar dapat mengakses Notion secara gratis dengan lisensi pendidikan, yang memberikan akses ke fitur premium, seperti penyimpanan tak terbatas dan kemampuan untuk berkolaborasi dengan lebih banyak orang.</li> </ul> </li> <li>Lisensi untuk Organisasi<ul> <li>Selain penggunaan individu, Notion juga menawarkan lisensi untuk organisasi, seperti kelompok studi atau tim pengajaran, dengan fitur kolaborasi yang lebih lengkap.</li> </ul> </li> </ol>"},{"location":"tools/notion/#12165-penggunaan-notion-dalam-proyek-pengembangan","title":"12.16.5 Penggunaan Notion dalam Proyek Pengembangan","text":"<ol> <li>Pengelolaan Proyek dan Tugas<ul> <li>Notion sangat efektif dalam mengelola proyek pengembangan, mulai dari tugas harian hingga perencanaan jangka panjang. Pengguna dapat membuat database tugas dengan tenggat waktu dan prioritas, yang memudahkan pengelolaan proyek secara keseluruhan.</li> </ul> </li> <li>Pencatatan dan Dokumentasi<ul> <li>Notion adalah alat yang sangat baik untuk pencatatan teknis, membuat dokumentasi proyek, dan menyimpan referensi penting. Ini dapat digunakan untuk membuat dokumentasi API, catatan rapat, atau panduan penggunaan perangkat lunak.</li> </ul> </li> <li>Kolaborasi Tim<ul> <li>Notion memungkinkan kolaborasi antara pengembang, desainer, dan anggota tim lainnya dalam proyek. Fitur berbagi dan pengeditan bersama mempermudah koordinasi dan memastikan bahwa semua orang memiliki akses ke informasi yang sama.</li> </ul> </li> <li>Perencanaan dan Pelacakan Kemajuan<ul> <li>Dengan template dan database, Notion memungkinkan pengguna untuk melacak kemajuan proyek atau pengembangan produk secara efektif. Ini sangat berguna untuk memantau milestone dan memastikan proyek tetap pada jalurnya.</li> </ul> </li> </ol>"},{"location":"tools/pgadmin/","title":"pgAdmin","text":""},{"location":"tools/pgadmin/#128-pgadmin","title":"12.8 pgAdmin","text":"<p>pgAdmin adalah alat manajemen dan pengembangan database PostgreSQL yang bersifat open-source. Alat ini menyediakan antarmuka grafis untuk mempermudah pengguna dalam mengelola database PostgreSQL. pgAdmin memungkinkan pengguna untuk melakukan berbagai operasi database, seperti menjalankan query, memanipulasi data, serta merancang dan mengelola skema database dengan cara yang lebih visual. Tool ini sangat berguna bagi administrator database dan pengembang yang bekerja dengan PostgreSQL, baik dalam lingkungan pengembangan, pengujian, maupun produksi.</p>"},{"location":"tools/pgadmin/#1281-fitur-utama-pgadmin","title":"12.8.1 Fitur Utama pgAdmin","text":"<ol> <li>Dukungan PostgreSQL<ul> <li>Menyediakan antarmuka lengkap untuk PostgreSQL, memungkinkan pengguna untuk mengelola dan mengonfigurasi database PostgreSQL dengan mudah.</li> <li>Mendukung versi terbaru PostgreSQL dan fitur-fitur canggih seperti JSONB, partitioning, dan foreign data wrappers.</li> </ul> </li> <li>Antarmuka Pengguna Grafis<ul> <li>Menyediakan GUI yang ramah pengguna dengan desain yang intuitif.</li> <li>Navigasi yang mudah untuk mengelola objek database seperti tabel, tampilan, dan prosedur tersimpan.</li> </ul> </li> <li>SQL Query Tool<ul> <li>Editor SQL yang canggih untuk menulis dan mengeksekusi query SQL.</li> <li>Fitur auto-complete dan highlight sintaks untuk memudahkan penulisan query.</li> </ul> </li> <li>Visualisasi dan Diagram<ul> <li>Memiliki kemampuan untuk membuat diagram ERD (Entity-Relationship Diagram) untuk memvisualisasikan struktur dan hubungan antar tabel.</li> <li>Dapat membuat visualisasi data dan skema untuk analisis dan dokumentasi.</li> </ul> </li> <li>Manajemen Data<ul> <li>Mempermudah manipulasi data dalam database dengan editor visual.</li> <li>Mendukung operasi seperti insert, update, delete, dan import/export data dalam berbagai format, seperti CSV dan SQL.</li> </ul> </li> <li>Backup dan Restore<ul> <li>Menyediakan fitur pencadangan dan pemulihan data yang dapat dilakukan melalui antarmuka grafis.</li> <li>Mendukung pencadangan terjadwal untuk memastikan data tetap aman.</li> </ul> </li> <li>Pengelolaan Pengguna dan Keamanan<ul> <li>Menyediakan alat untuk mengelola pengguna database dan hak akses.</li> <li>Mendukung autentikasi berbasis SSL dan SSH untuk koneksi yang aman.</li> </ul> </li> <li>Monitoring dan Statistik<ul> <li>Dapat memantau status server PostgreSQL, seperti penggunaan CPU, memori, dan aktivitas query.</li> <li>Menyediakan grafik statistik dan laporan untuk menganalisis kinerja database.</li> </ul> </li> <li>Fitur Administratif Lanjutan<ul> <li>Memungkinkan pengelolaan fungsi-fungsi lanjutan seperti pengelolaan log, partisi tabel, dan replikasi.</li> <li>Menyediakan fitur pengelolaan skema untuk mendukung operasi database berskala besar.</li> </ul> </li> <li>Automasi dan Pengelolaan Tugas<ul> <li>Menyediakan alat untuk mengelola tugas-tugas otomatis seperti pencadangan, pemeliharaan, dan optimasi database.</li> </ul> </li> </ol>"},{"location":"tools/pgadmin/#1282-keunggulan-pgadmin","title":"12.8.2 Keunggulan pgAdmin","text":"<ol> <li>Gratis dan Open-Source<ul> <li>pgAdmin sepenuhnya gratis dan open-source, dapat dimodifikasi sesuai kebutuhan serta dilengkapi dengan dokumentasi yang luas.</li> </ul> </li> <li>Dukungan Lengkap untuk PostgreSQL<ul> <li>Merupakan alat yang didesain khusus untuk PostgreSQL, memberikan dukungan penuh untuk fitur-fitur PostgreSQL terbaru.</li> </ul> </li> <li>Antarmuka yang Ramah Pengguna<ul> <li>Meskipun alat ini kuat, antarmukanya sangat ramah pengguna, mempermudah pengguna baru untuk memulai serta memungkinkan pengelolaan database secara efisien.</li> </ul> </li> <li>Fitur Administratif yang Kuat<ul> <li>Menyediakan berbagai fitur administratif untuk pengelolaan database dan server PostgreSQL, dari tugas dasar hingga yang lebih kompleks.</li> </ul> </li> <li>Komunitas yang Aktif<ul> <li>Sebagai proyek open-source, pgAdmin memiliki komunitas pengguna dan pengembang yang aktif, yang menyediakan dukungan serta pengembangan berkelanjutan.</li> </ul> </li> </ol>"},{"location":"tools/pgadmin/#1283-kekurangan-pgadmin","title":"12.8.3 Kekurangan pgAdmin","text":"<ol> <li>Performa pada Database Besar<ul> <li>Pada database yang sangat besar atau beban kerja yang tinggi, pgAdmin dapat menunjukkan penurunan performa, terutama pada operasi yang memerlukan pemrosesan data besar atau query yang kompleks.</li> </ul> </li> <li>Fitur Terbatas untuk Database Non-PostgreSQL<ul> <li>Alat ini fokus pada PostgreSQL, sehingga tidak cocok untuk proyek yang menggunakan database lain seperti MySQL atau MongoDB.</li> </ul> </li> <li>Antarmuka yang Cukup Berat<ul> <li>Meskipun antarmuka pengguna cukup lengkap, pgAdmin dapat terasa berat di komputer dengan spesifikasi rendah atau jika digunakan dengan banyak koneksi dan data.</li> </ul> </li> <li>Kurangnya Fitur untuk Pemrograman Lanjutan<ul> <li>Untuk pengembang yang membutuhkan alat pemrograman lanjutan, seperti pengembangan aplikasi berbasis database atau integrasi CI/CD, pgAdmin kurang cocok dibandingkan dengan alat yang lebih fokus pada pengembangan perangkat lunak.</li> </ul> </li> </ol>"},{"location":"tools/pgadmin/#1284-lisensi-dan-versi-pgadmin","title":"12.8.4 Lisensi dan Versi pgAdmin","text":"<ol> <li>Versi Community (Gratis dan Open-Source)<ul> <li>pgAdmin tersedia sepenuhnya gratis sebagai alat open-source dengan akses penuh ke semua fitur dasar untuk pengelolaan database PostgreSQL.</li> <li>Dapat digunakan tanpa biaya dan dikustomisasi sesuai kebutuhan.</li> </ul> </li> <li>Versi Cloud (Berbayar)<ul> <li>pgAdmin juga menawarkan layanan berbasis cloud yang memungkinkan pengelolaan PostgreSQL secara lebih fleksibel dan skalabel di lingkungan cloud.</li> </ul> </li> </ol>"},{"location":"tools/pgadmin/#1285-penggunaan-pgadmin-dalam-proyek-pengembangan","title":"12.8.5 Penggunaan pgAdmin dalam Proyek Pengembangan","text":"<ol> <li>Pengelolaan dan Administrasi PostgreSQL<ul> <li>Ideal bagi tim yang mengelola PostgreSQL, baik untuk pengembangan, pengujian, maupun produksi. pgAdmin memungkinkan pengelolaan database secara efisien dengan antarmuka yang mudah digunakan.</li> </ul> </li> <li>Visualisasi dan Analisis Data<ul> <li>Membantu dalam membuat diagram relasi antar tabel dan visualisasi data untuk analisis lebih lanjut, mendukung pengembangan sistem berbasis data besar.</li> </ul> </li> <li>Pemeliharaan dan Pencadangan Data<ul> <li>Memudahkan proses pemeliharaan database, pencadangan data secara terjadwal, serta pengembalian data dengan antarmuka grafis.</li> </ul> </li> <li>Monitoring Kinerja Database<ul> <li>Menyediakan fitur untuk memantau kinerja database secara real-time, membantu mengidentifikasi masalah kinerja dan optimasi query.</li> </ul> </li> <li>Pengelolaan Keamanan dan Pengguna<ul> <li>Memfasilitasi pengelolaan pengguna, hak akses, dan keamanan database PostgreSQL dengan dukungan autentikasi dan enkripsi koneksi.</li> </ul> </li> </ol>"},{"location":"tools/php-built-in-server/","title":"12.9 PHP Built-in Server","text":"<p>PHP Built-in Server adalah fitur bawaan yang disediakan oleh PHP sejak versi 5.4, memungkinkan pengembang untuk menjalankan server web sederhana tanpa memerlukan instalasi perangkat lunak tambahan seperti Apache atau Nginx. Server ini dirancang khusus untuk keperluan pengembangan dan bukan untuk digunakan di lingkungan produksi.  </p>"},{"location":"tools/php-built-in-server/#1291-fitur-utama","title":"12.9.1 Fitur Utama","text":"<ol> <li>Ringan dan Tanpa Instalasi Tambahan </li> <li>Server berjalan langsung dari binary PHP, mengurangi kebutuhan konfigurasi.  </li> <li>Dukungan Routing Sederhana </li> <li>Mendukung file router PHP untuk menangani permintaan, seperti routing untuk framework kecil.  </li> <li>Dukungan HTTPS </li> <li>Mulai PHP versi 5.4.13, mendukung HTTPS untuk pengujian menggunakan sertifikat lokal.  </li> <li>Log Real-time </li> <li>Menampilkan log permintaan langsung di terminal.  </li> <li>Custom Port dan Host </li> <li>Server dapat dikonfigurasi untuk mendengarkan di port atau host tertentu.  </li> </ol>"},{"location":"tools/php-built-in-server/#1292-keunggulan","title":"12.9.2 Keunggulan","text":"<ol> <li>Sangat Ringan </li> <li>Tidak memerlukan sumber daya tambahan atau perangkat lunak pihak ketiga.  </li> <li>Cepat dan Mudah Digunakan </li> <li>Server dapat dijalankan dengan satu perintah: <pre><code>php -S localhost:8000\n</code></pre></li> <li>Integrasi dengan Framework PHP </li> <li>Cocok untuk framework seperti Laravel, Symfony, atau Slim dalam pengembangan lokal.  </li> <li>Portabel </li> <li>Cukup menginstal PHP di sistem untuk menjalankannya.  </li> </ol>"},{"location":"tools/php-built-in-server/#1293-kekurangan","title":"12.9.3 Kekurangan","text":"<ol> <li>Tidak Cocok untuk Produksi </li> <li>Tidak dirancang untuk menangani beban tinggi atau koneksi simultan yang besar.  </li> <li>Fitur Terbatas </li> <li>Tidak memiliki fitur kompleks seperti modul yang tersedia di Apache atau Nginx.  </li> <li>Konfigurasi HTTPS Manual </li> <li>Membutuhkan pengaturan tambahan untuk pengujian HTTPS, termasuk membuat sertifikat lokal.  </li> </ol>"},{"location":"tools/php-built-in-server/#1294-lisensi-dan-versi","title":"12.9.4 Lisensi dan Versi","text":"<ul> <li>Lisensi: PHP adalah perangkat lunak sumber terbuka yang dilisensikan di bawah PHP License.  </li> <li>Versi Minimum: PHP Built-in Server tersedia sejak PHP versi 5.4.  </li> </ul>"},{"location":"tools/php-built-in-server/#1295-penggunaan-php-built-in-server-dalam-proyek","title":"12.9.5 Penggunaan PHP Built-in Server dalam Proyek","text":"<p>PHP Built-in Server sering digunakan untuk: 1. Pengembangan Cepat    - Menjalankan aplikasi kecil atau API untuk pengujian lokal tanpa perlu konfigurasi. 2. Uji Fungsionalitas    - Cocok untuk memastikan skrip berjalan sebelum diterapkan ke server yang lebih kompleks. 3. Pendidikan dan Prototipe    - Membantu pemula memulai pengembangan PHP tanpa memerlukan pengetahuan server yang mendalam.  </p>"},{"location":"tools/php-built-in-server/#contoh-penggunaan","title":"Contoh Penggunaan","text":"<p>Jalankan server untuk melayani file di direktori saat ini: <pre><code>php -S localhost:8000\n</code></pre> Menggunakan file router untuk aplikasi: <pre><code>php -S localhost:8000 router.php\n</code></pre> Di mana router.php mengatur logika routing: <pre><code>&lt;?php\nif (file_exists(__DIR__ . $_SERVER['REQUEST_URI'])) {\n    return false; // Layani file langsung jika ada.\n}\nrequire 'index.php'; // Arahkan ke index.php untuk menangani permintaan lainnya.\n</code></pre> PHP Built-in Server adalah solusi ringan dan cepat untuk pengembangan lokal, ideal untuk aplikasi sederhana atau API selama tahap pengembangan.</p>"},{"location":"tools/phpstorm/","title":"PHPStorm (Education Version)","text":""},{"location":"tools/phpstorm/#121-phpstorm-education-version","title":"12.1 PHPStorm (Education Version)","text":"<p>PHPStorm adalah sebuah Integrated Development Environment (IDE) yang dikembangkan oleh JetBrains, dirancang khusus untuk pengembangan aplikasi berbasis PHP. PHPStorm mendukung berbagai framework populer seperti Laravel, CodeIgniter, Symfony, Zend Framework, serta bahasa pendukung seperti HTML, CSS, JavaScript, dan SQL. PHPStorm dikenal karena fitur-fitur canggihnya yang meningkatkan produktivitas pengembang.</p>"},{"location":"tools/phpstorm/#1211-fitur-utama","title":"12.1.1 Fitur Utama","text":"<ol> <li> <p>Coding Assistance</p> <ul> <li>Autocomplete: Saran kode otomatis untuk PHP, JavaScript, HTML, dan CSS.</li> <li>Refactoring: Kemudahan dalam mengubah nama variabel, fungsi, atau kelas secara menyeluruh di seluruh proyek.</li> <li>Code Sniffer dan Fixer: Mendukung standar coding (PSR) dengan validasi dan perbaikan otomatis.</li> <li>Debugging dan Testing: Terintegrasi dengan Xdebug dan PHPUnit untuk debugging dan pengujian.</li> </ul> </li> <li> <p>Dukungan Framework</p> <ul> <li>Laravel: Dukungan Blade Template, Artisan, dan Laravel Mix.</li> <li>CodeIgniter: Penyelesaian otomatis untuk fungsi framework.</li> <li>WordPress: Integrasi dengan WordPress untuk pengembangan tema dan plugin.</li> </ul> </li> <li> <p>Database Tools</p> <ul> <li>Editor SQL bawaan dengan visualisasi struktur database.</li> <li>Mendukung MySQL, PostgreSQL, SQLite, dan lainnya.</li> </ul> </li> <li> <p>Integrasi VCS (Version Control System)</p> <ul> <li>Mendukung Git, Mercurial, SVN, dan lainnya.</li> <li>Fitur seperti diffs, merge tools, dan commit tracking langsung di IDE.</li> </ul> </li> <li> <p>Smart Code Navigation</p> <ul> <li>Kemampuan mencari definisi fungsi, kelas, atau variabel dengan cepat.</li> <li>Shortcut untuk berpindah antara file, kelas, dan metode.</li> </ul> </li> <li> <p>Integrasi Alat Lain</p> <ul> <li>Docker: Mendukung integrasi container untuk pengembangan berbasis Docker.</li> <li>Composer: Manajemen dependensi PHP dengan Composer terintegrasi.</li> <li>REST Client: Pengujian endpoint API langsung dari IDE.</li> </ul> </li> <li> <p>Support untuk Front-End Development</p> <ul> <li>Mendukung pengembangan front-end dengan fitur tambahan seperti TypeScript, React, Vue.js, dan Angular.</li> </ul> </li> </ol>"},{"location":"tools/phpstorm/#1212-keunggulan-phpstorm","title":"12.1.2 Keunggulan PHPStorm","text":"<ol> <li>Komprehensif: Mendukung hampir semua fitur pengembangan PHP modern.</li> <li>Produktivitas Tinggi: Fitur autocomplete dan debugging mengurangi waktu pengembangan.</li> <li>Dukungan Framework dan Tools: Terintegrasi dengan framework PHP dan alat seperti Docker, Composer, PHPUnit, dan banyak lagi.</li> <li>Kaya Akan Plugin: Marketplace JetBrains menyediakan banyak plugin untuk menyesuaikan kebutuhan.</li> <li>Linting dan Code Quality: Membantu menjaga kualitas kode melalui integrasi linting.</li> </ol>"},{"location":"tools/phpstorm/#1213-kekurangan-phpstorm","title":"12.1.3 Kekurangan PHPStorm","text":"<ol> <li>Berat: Memiliki konsumsi memori yang tinggi, terutama untuk proyek besar.</li> <li>Berbayar: Membutuhkan lisensi berbayar, meskipun ada opsi edukasi gratis.</li> <li>Kurva Pembelajaran: Fitur yang kaya dapat membingungkan bagi pengembang pemula.</li> <li>Harga Lisensi: Untuk penggunaan komersial, harga lisensinya cukup mahal jika dibandingkan dengan editor gratis seperti VS Code.</li> </ol>"},{"location":"tools/phpstorm/#1214-versi-edukasi-phpstorm","title":"12.1.4 Versi Edukasi PHPStorm","text":"<p>JetBrains menyediakan lisensi gratis untuk pelajar, mahasiswa, dan pengajar melalui program JetBrains Education License.</p> <p>Fitur Versi Edukasi</p> <ul> <li>Sama persis dengan versi berbayar komersial (fitur lengkap tanpa pembatasan).</li> <li>Berlaku untuk semua produk JetBrains, termasuk PHPStorm, PyCharm, IntelliJ IDEA, dan lainnya.</li> </ul> <p>Cara Mendapatkan Lisensi Edukasi</p> <ol> <li>Pendaftaran Akun JetBrains<ul> <li>Daftar akun menggunakan email institusi pendidikan (contoh: <code>@universitas.edu</code>).</li> </ul> </li> <li>Verifikasi Status Edukasi<ul> <li>Kirim dokumen pendukung (contoh: kartu mahasiswa atau surat keterangan dari institusi).</li> </ul> </li> <li>Aktivasi Lisensi<ul> <li>Setelah disetujui, lisensi berlaku selama 1 tahun dan dapat diperpanjang dengan bukti status sebagai pelajar.</li> </ul> </li> </ol> <p>Keunggulan Lisensi Edukasi</p> <ul> <li>Tidak ada biaya.</li> <li>Akses penuh ke semua fitur.</li> <li>Dukungan resmi JetBrains.</li> </ul>"},{"location":"tools/postman/","title":"12.10 Postman","text":"<p>Postman adalah alat pengujian API yang sangat populer, digunakan untuk mengembangkan, menguji, dan mendokumentasikan API secara efisien. Postman memungkinkan pengembang untuk mengirimkan permintaan HTTP, menguji respons, serta memverifikasi fungsionalitas dan kinerja API yang sedang dikembangkan. Alat ini mendukung berbagai protokol seperti REST, SOAP, dan GraphQL, serta memberikan banyak fitur yang membantu mempercepat siklus pengembangan aplikasi, terutama untuk API yang dibangun dengan FastAPI.</p>"},{"location":"tools/postman/#12101-fitur-utama-postman","title":"12.10.1 Fitur Utama Postman","text":"<ol> <li>Pengujian API yang Mudah<ul> <li>Postman memungkinkan pengiriman permintaan HTTP (GET, POST, PUT, DELETE, dll.) kepada API dan memeriksa responsnya. Hal ini mempermudah pengembang untuk menguji API secara manual dan memastikan bahwa fungsionalitas API berjalan sesuai harapan.</li> </ul> </li> <li>Mendukung Berbagai Protokol<ul> <li>Postman mendukung berbagai jenis protokol seperti REST, SOAP, dan GraphQL, yang membuatnya fleksibel untuk digunakan dalam berbagai jenis proyek API, termasuk yang menggunakan FastAPI.</li> </ul> </li> <li>Koleksi dan Pengorganisasian API<ul> <li>Postman memungkinkan pengorganisasian permintaan API ke dalam koleksi (collections), yang memudahkan pengelolaan dan pengujian berbagai API secara terstruktur.</li> </ul> </li> <li>Pengujian Otomatis dengan Skrip<ul> <li>Dengan fitur Test Scripts, Postman memungkinkan pengguna untuk menulis skrip pengujian otomatis setelah mengirimkan permintaan API. Hal ini sangat berguna untuk melakukan pengujian otomatis terhadap status kode atau data respons.</li> </ul> </li> <li>Dokumentasi API Otomatis<ul> <li>Postman dapat menghasilkan dokumentasi API otomatis berdasarkan koleksi permintaan API yang telah dibuat. Dokumentasi ini bisa dibagikan dengan tim pengembang lain atau digunakan untuk pengujian.</li> </ul> </li> <li>Lingkungan Pengujian (Environments)<ul> <li>Postman memungkinkan penggunaan environments yang menyimpan variabel untuk berbagai set pengujian (misalnya, variabel untuk URL basis yang berbeda di lingkungan pengembangan dan produksi), yang memungkinkan pengujian API di berbagai kondisi.</li> </ul> </li> <li>Penyimpanan dan Kolaborasi Tim<ul> <li>Dengan fitur Postman Teams, beberapa pengembang dapat bekerja bersama dalam pengembangan dan pengujian API, berbagi koleksi API, dan melacak perubahan dalam satu tempat.</li> </ul> </li> <li>Pengintegrasian dengan CI/CD<ul> <li>Postman mendukung integrasi dengan pipeline CI/CD untuk otomatisasi pengujian API di berbagai tahap pengembangan.</li> </ul> </li> <li>Pengujian Beban dan Kinerja<ul> <li>Postman memiliki kemampuan untuk melakukan load testing dengan mengirimkan permintaan dalam jumlah besar dan memantau kinerja API di bawah beban.</li> </ul> </li> </ol>"},{"location":"tools/postman/#12102-keunggulan-postman","title":"12.10.2 Keunggulan Postman","text":"<ol> <li>Antarmuka Pengguna yang Intuitif<ul> <li>Postman menyediakan antarmuka grafis yang ramah pengguna untuk mengirimkan dan memeriksa permintaan API, sangat cocok untuk pengembang yang tidak ingin bekerja dengan baris perintah.</li> </ul> </li> <li>Pengujian API yang Komprehensif<ul> <li>Dengan berbagai fitur seperti skrip pengujian otomatis dan pengelolaan koleksi, Postman menawarkan alat yang lengkap untuk pengujian API dari berbagai sudut.</li> </ul> </li> <li>Kolaborasi Tim yang Efisien<ul> <li>Dengan fitur kolaborasi seperti Postman Teams, tim pengembang dapat berbagi koleksi dan dokumentasi API, meningkatkan efisiensi dalam pengembangan bersama.</li> </ul> </li> <li>Dukungan Berbagai Protokol<ul> <li>Postman mendukung banyak jenis API (REST, GraphQL, SOAP), memberikan fleksibilitas untuk digunakan dengan berbagai jenis sistem backend.</li> </ul> </li> <li>Otomatisasi dan Integrasi<ul> <li>Postman dapat diintegrasikan dengan sistem CI/CD, memungkinkan pengujian API secara otomatis dalam setiap tahap pengembangan perangkat lunak.</li> </ul> </li> <li>Fitur Dokumentasi Otomatis<ul> <li>Postman secara otomatis menghasilkan dokumentasi API yang selalu terbarukan, sangat berguna untuk kolaborasi tim dan klien.</li> </ul> </li> </ol>"},{"location":"tools/postman/#12103-kekurangan-postman","title":"12.10.3 Kekurangan Postman","text":"<ol> <li>Memerlukan Sumber Daya Komputer<ul> <li>Karena Postman adalah aplikasi desktop, ia memerlukan lebih banyak sumber daya sistem dibandingkan dengan pengujian API berbasis web atau alat command-line.</li> </ul> </li> <li>Mungkin Terlalu Berat untuk Pengguna Baru<ul> <li>Bagi pengembang yang baru mengenal alat pengujian API, Postman bisa terasa sedikit rumit pada awalnya, karena banyaknya fitur yang tersedia.</li> </ul> </li> <li>Tidak Terintegrasi Secara Langsung dengan Beberapa Framework<ul> <li>Meskipun sangat kuat untuk pengujian API, Postman tidak terintegrasi langsung dengan framework pengembangan seperti FastAPI, sehingga perlu pengaturan manual untuk beberapa fitur pengujian.</li> </ul> </li> <li>Fitur Gratis Terbatas<ul> <li>Untuk tim yang lebih besar, beberapa fitur seperti kolaborasi dan integrasi otomatis membutuhkan langganan berbayar, yang mungkin terasa terbatas dalam versi gratis.</li> </ul> </li> </ol>"},{"location":"tools/postman/#12104-lisensi-dan-versi-postman","title":"12.10.4 Lisensi dan Versi Postman","text":"<ol> <li>Versi Gratis<ul> <li>Postman menawarkan versi gratis yang mencakup sebagian besar fitur dasar, yang cukup untuk pengujian API pada proyek skala kecil hingga menengah.</li> </ul> </li> <li>Versi Berbayar (Postman Pro dan Enterprise)<ul> <li>Postman juga menawarkan versi berbayar dengan fitur tambahan seperti kolaborasi tim, integrasi CI/CD, dan kemampuan untuk bekerja dengan lebih banyak koleksi dan dokumentasi API.</li> </ul> </li> </ol>"},{"location":"tools/postman/#12105-penggunaan-postman-dalam-pengembangan-fastapi","title":"12.10.5 Penggunaan Postman dalam Pengembangan FastAPI","text":"<ol> <li>Pengujian API FastAPI<ul> <li>Postman sangat cocok untuk menguji API yang dibangun dengan FastAPI, karena memungkinkan pengiriman permintaan HTTP dengan berbagai metode (GET, POST, PUT, DELETE) dan verifikasi respons API.</li> </ul> </li> <li>Dokumentasi API Otomatis<ul> <li>Postman secara otomatis menghasilkan dokumentasi API yang terstruktur, yang membantu pengembang dan pengguna lain untuk memahami cara menggunakan API FastAPI yang telah dibangun.</li> </ul> </li> <li>Pengujian Fungsionalitas<ul> <li>Dengan Postman, pengujian fungsionalitas API FastAPI dapat dilakukan dengan menulis skrip pengujian otomatis yang memverifikasi hasil respons API, memastikan API bekerja sesuai dengan yang diinginkan.</li> </ul> </li> <li>Pengujian Beban dan Kinerja<ul> <li>Postman memungkinkan pengujian kinerja API dengan mengirimkan sejumlah besar permintaan, membantu mengidentifikasi batasan atau bottleneck dalam aplikasi FastAPI.</li> </ul> </li> <li>Kolaborasi Tim Pengembangan<ul> <li>Dengan fitur Postman Teams, tim pengembang dapat bekerja bersama untuk mendokumentasikan, menguji, dan memperbaiki API FastAPI secara lebih terorganisir dan efisien.</li> </ul> </li> </ol>"},{"location":"tools/pycharm/","title":"PyCharm (Education Version)","text":""},{"location":"tools/pycharm/#123-pycharm-education-version","title":"12.3 PyCharm (Education Version)","text":"<p>PyCharm adalah Integrated Development Environment (IDE) yang dikembangkan oleh JetBrains, dirancang khusus untuk pengembangan aplikasi berbasis Python. PyCharm sangat populer di kalangan pengembang karena menawarkan fitur lengkap untuk coding Python, seperti debugging, testing, refactoring, dan integrasi dengan alat pengembang lainnya.</p>"},{"location":"tools/pycharm/#1231-fitur-utama","title":"12.3.1 Fitur Utama","text":"<ol> <li> <p>Coding Assistance</p> <ul> <li>Autocomplete Pintar: Mendukung penyelesaian kode otomatis berbasis konteks, baik untuk Python maupun framework yang digunakan.</li> <li>Highlighting Kesalahan: Menandai kesalahan sintaks dan memberikan saran perbaikan.</li> <li>Refactoring: Mendukung refactoring kode yang kompleks, seperti rename variabel, extract method, dan lainnya.</li> <li>Dukungan Python Modern: Mendukung Python 2.x dan 3.x, termasuk sintaks Python terbaru.</li> </ul> </li> <li> <p>Dukungan Framework</p> <ul> <li>Mendukung framework Python populer seperti Django, Flask, FastAPI, dan Pyramid.</li> <li>Pengelolaan template dengan dukungan untuk Jinja2 dan Mako.</li> </ul> </li> <li> <p>Debugging</p> <ul> <li>Debugger grafis bawaan yang memungkinkan penelusuran kode Python secara interaktif.</li> <li>Dukungan breakpoint bersyarat, penjelajahan call stack, dan evaluasi ekspresi dinamis.</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Mendukung framework pengujian seperti pytest, unittest, dan doctest.</li> <li>Menampilkan laporan hasil pengujian langsung di dalam IDE.</li> </ul> </li> <li> <p>Database Tools</p> <ul> <li>Alat bawaan untuk mengelola dan menjalankan query SQL di database seperti MySQL, PostgreSQL, dan SQLite.</li> <li>Menampilkan struktur database dalam format visual.</li> </ul> </li> <li> <p>Versi Kontrol</p> <ul> <li>Terintegrasi dengan alat version control seperti Git, Mercurial, dan Subversion.</li> <li>Menyediakan visual diff tools untuk membandingkan perubahan kode.</li> </ul> </li> <li> <p>Dukungan untuk Front-End</p> <ul> <li>Mendukung pengembangan front-end menggunakan HTML, CSS, dan JavaScript dalam proyek Python.</li> <li>Integrasi dengan alat modern seperti Webpack dan npm.</li> </ul> </li> <li> <p>Pengembangan Ilmiah (Scientific Development)</p> <ul> <li>Dukungan untuk Jupyter Notebook, matplotlib, NumPy, dan Pandas.</li> <li>Mode visual interaktif untuk analisis data.</li> </ul> </li> <li> <p>Dukungan Docker</p> <ul> <li>Integrasi bawaan untuk bekerja dengan container Docker.</li> <li>Dukungan deployment ke server remote.</li> </ul> </li> <li> <p>Plugin Marketplace</p> <ul> <li>Mendukung plugin untuk menambah fungsionalitas, seperti integrasi dengan framework tambahan atau alat pengembang lainnya.</li> </ul> </li> </ol>"},{"location":"tools/pycharm/#1232-keunggulan-pycharm","title":"12.3.2 Keunggulan PyCharm","text":"<ol> <li>Komprehensif: Memiliki fitur lengkap untuk semua kebutuhan pengembangan Python, termasuk pengelolaan virtual environment, testing, dan deployment.</li> <li>Efisiensi: Fitur autocomplete, debugging, dan refactoring mempercepat proses pengembangan.</li> <li>Dukungan Framework dan Alat Eksternal: Sangat cocok untuk proyek menggunakan Django, Flask, dan FastAPI.</li> <li>Scientific Tools: Cocok untuk pengembang yang bekerja dengan data sains atau machine learning.</li> <li>User-Friendly: Antarmuka yang intuitif dan mudah digunakan.</li> </ol>"},{"location":"tools/pycharm/#1233-kekurangan-pycharm","title":"12.3.3 Kekurangan PyCharm","text":"<ol> <li>Berat: Memerlukan sumber daya komputer yang lebih besar dibandingkan editor ringan seperti VS Code.</li> <li>Berbayar: Versi Professional membutuhkan lisensi, meskipun ada edisi Community yang gratis.</li> <li>Kurva Pembelajaran: Untuk pemula, fitur lengkapnya mungkin terasa membingungkan pada awalnya.</li> </ol>"},{"location":"tools/pycharm/#1234-versi-pycharm","title":"12.3.4 Versi PyCharm","text":"<ol> <li>PyCharm Professional (Berbayar)</li> </ol> <p>Dirancang untuk pengembangan profesional, dengan fitur seperti:</p> <ul> <li>Dukungan framework web (Django, Flask, FastAPI).</li> <li>Alat database dan SQL.</li> <li>Alat pengembangan ilmiah.</li> <li> <p>Deployment dan remote debugging.</p> </li> <li> <p>PyCharm Community (Gratis)</p> </li> <li> <p>Versi ringan dengan fitur dasar untuk pengembangan Python.</p> </li> <li>Tidak mendukung framework web, database, atau alat pengembangan ilmiah.</li> </ul>"},{"location":"tools/pycharm/#1235-versi-edukasi-pycharm","title":"12.3.5 Versi Edukasi PyCharm","text":"<p>Program Edukasi JetBrains</p> <p>PyCharm tersedia gratis untuk pelajar, mahasiswa, dan pengajar melalui lisensi edukasi JetBrains.</p> <p>Fitur Versi Edukasi</p> <ul> <li>Memiliki fitur yang sama dengan edisi Professional tanpa pembatasan.</li> <li>Cocok untuk pelatihan dan pengajaran Python di lingkungan akademik.</li> </ul> <p>Cara Mendapatkan</p> <ol> <li>Daftar JetBrains Account<ul> <li>Gunakan email institusi pendidikan.</li> </ul> </li> <li>Verifikasi Status<ul> <li>Kirimkan bukti status pendidikan (kartu pelajar atau surat keterangan).</li> </ul> </li> <li>Aktivasi<ul> <li>Lisensi berlaku selama 1 tahun dan dapat diperpanjang jika status pelajar masih aktif.</li> </ul> </li> </ol>"},{"location":"tools/redoc/","title":"12.12 ReDoc","text":"<p>ReDoc adalah alat dokumentasi API yang dihasilkan secara otomatis berdasarkan OpenAPI Specification (OAS). ReDoc menawarkan tampilan dokumentasi API yang bersih dan terstruktur dengan baik, memungkinkan pengembang dan pengguna untuk memahami API dengan mudah. Dibandingkan dengan Swagger UI, ReDoc lebih fokus pada penyajian dokumentasi API dengan desain yang lebih minimalis dan fungsional.</p>"},{"location":"tools/redoc/#12121-fitur-utama-redoc","title":"12.12.1 Fitur Utama ReDoc","text":"<ol> <li>Desain Responsif<ul> <li>ReDoc dirancang untuk memberikan pengalaman pengguna yang baik di berbagai perangkat, mulai dari desktop hingga perangkat mobile. Desainnya yang responsif memastikan bahwa dokumentasi API dapat diakses dengan nyaman di berbagai layar.</li> </ul> </li> <li>Pengalaman Pengguna yang Bersih dan Terstruktur<ul> <li>Antarmuka ReDoc mengutamakan kemudahan navigasi dan kejelasan, dengan tampilan yang rapi dan fokus pada penyajian informasi API yang jelas dan mudah dipahami.</li> </ul> </li> <li>Pencarian API yang Cepat<ul> <li>ReDoc menyediakan fitur pencarian yang memudahkan pengguna untuk menemukan endpoint, parameter, atau informasi tertentu di dokumentasi API.</li> </ul> </li> <li>Penyajian Dokumentasi Berdasarkan Standar OpenAPI<ul> <li>ReDoc sepenuhnya mendukung OpenAPI Specification (OAS), yang memungkinkan dokumentasi API dibuat secara otomatis berdasarkan file spesifikasi OAS.</li> </ul> </li> <li>Dukungan untuk Berbagai Jenis Data<ul> <li>ReDoc mendukung berbagai format data dan metode HTTP yang digunakan oleh API, serta memberikan penjelasan yang jelas mengenai respons dan parameter API dalam format yang mudah dipahami.</li> </ul> </li> <li>Dukungan Autentikasi<ul> <li>ReDoc memungkinkan integrasi dengan berbagai mekanisme autentikasi, seperti OAuth 2.0 dan API key, yang memungkinkan pengembang untuk mendokumentasikan cara penggunaan API yang aman.</li> </ul> </li> <li>Pemrograman Dinamis<ul> <li>Dokumentasi API yang dihasilkan dengan ReDoc bersifat dinamis dan dapat diperbarui secara langsung sesuai dengan perubahan yang dilakukan pada spesifikasi OpenAPI.</li> </ul> </li> </ol>"},{"location":"tools/redoc/#12122-keunggulan-redoc","title":"12.12.2 Keunggulan ReDoc","text":"<ol> <li>Desain yang Lebih Minimalis<ul> <li>Dibandingkan dengan Swagger UI, ReDoc memiliki desain yang lebih minimalis dan tidak terlalu banyak elemen visual, membuat dokumentasi API terlihat lebih bersih dan mudah dinavigasi.</li> </ul> </li> <li>Pengalaman Pengguna yang Lebih Fokus<ul> <li>Dengan fokus pada penyajian informasi yang terstruktur dengan baik, ReDoc memberikan pengalaman pengguna yang lebih terfokus pada pemahaman API dan mengurangi gangguan visual.</li> </ul> </li> <li>Pencarian yang Efisien<ul> <li>Fitur pencarian yang tersedia memungkinkan pengguna untuk menemukan informasi tentang API dengan lebih cepat, yang sangat berguna ketika dokumentasi API cukup besar dan kompleks.</li> </ul> </li> <li>Dokumentasi Otomatis Berdasarkan OpenAPI<ul> <li>Seperti Swagger, ReDoc memungkinkan pembuatan dokumentasi API yang sepenuhnya otomatis berdasarkan file spesifikasi OpenAPI Specification yang dapat digunakan oleh pengembang untuk mempercepat pengembangan dan integrasi API.</li> </ul> </li> <li>Kemudahan Integrasi<ul> <li>ReDoc mudah diintegrasikan dengan berbagai framework API yang mendukung OpenAPI, seperti FastAPI, dan dapat digunakan untuk menghasilkan dokumentasi API yang terstruktur dan mudah dipahami tanpa konfigurasi yang rumit.</li> </ul> </li> </ol>"},{"location":"tools/redoc/#12123-kekurangan-redoc","title":"12.12.3 Kekurangan ReDoc","text":"<ol> <li>Fitur Interaktivitas Terbatas<ul> <li>Dibandingkan dengan Swagger UI, ReDoc tidak menyediakan interaktivitas penuh dalam pengujian API. ReDoc lebih fokus pada penyajian dokumentasi, sementara Swagger UI memungkinkan pengujian API secara langsung dari antarmuka.</li> </ul> </li> <li>Tidak Sebanyak Fitur Pengujian<ul> <li>ReDoc lebih berfokus pada dokumentasi dan presentasi data daripada menyediakan alat pengujian interaktif seperti yang ada di Swagger UI.</li> </ul> </li> <li>Kurang Fleksibel untuk Kustomisasi<ul> <li>Meskipun ReDoc menyediakan beberapa opsi kustomisasi, pengembang yang membutuhkan kontrol penuh atas tampilan dan interaksi dokumentasi mungkin merasa lebih terbatas dibandingkan dengan Swagger UI.</li> </ul> </li> </ol>"},{"location":"tools/redoc/#12124-lisensi-dan-versi-redoc","title":"12.12.4 Lisensi dan Versi ReDoc","text":"<ol> <li>Versi Open Source<ul> <li>ReDoc tersedia sebagai alat open-source, yang dapat diunduh dan digunakan secara gratis. Pengguna dapat memodifikasi dan mengonfigurasi ReDoc sesuai kebutuhan mereka, dengan keterbatasan fungsionalitas yang lebih sedikit dibandingkan dengan versi berbayar.</li> </ul> </li> <li>ReDoc Pro<ul> <li>Untuk fitur tambahan dan dukungan premium, ReDoc juga menawarkan ReDoc Pro yang memungkinkan pengguna untuk menyesuaikan lebih lanjut dokumentasi mereka dan mendapatkan dukungan langsung dari tim ReDoc.</li> </ul> </li> </ol>"},{"location":"tools/redoc/#12125-redoc-dan-fastapi","title":"12.12.5 ReDoc dan FastAPI","text":"<p>Salah satu fitur unggulan FastAPI adalah kemampuannya untuk menghasilkan dokumentasi API otomatis menggunakan Swagger UI dan ReDoc. ReDoc terintegrasi secara langsung dengan FastAPI, sehingga dokumentasi API akan dihasilkan secara otomatis tanpa memerlukan konfigurasi tambahan.</p> <ol> <li>Penghasilan Dokumentasi Otomatis<ul> <li>Ketika aplikasi FastAPI dijalankan, dokumentasi API dapat diakses melalui ReDoc tanpa perlu pengaturan manual. Hal ini memungkinkan pengembang untuk dengan cepat mendapatkan dokumentasi API yang dapat dipahami dengan mudah oleh pihak lain.</li> </ul> </li> <li>Antarmuka Pengguna ReDoc di FastAPI<ul> <li>ReDoc dapat diakses melalui antarmuka web FastAPI di endpoint <code>/redoc</code> secara default. Hal ini memberi pengembang dua pilihan dokumentasi API yang dihasilkan otomatis, yaitu melalui Swagger UI dan ReDoc.</li> </ul> </li> <li>Desain yang Mudah Dinavigasi<ul> <li>ReDoc menyediakan antarmuka yang sangat bersih dan terstruktur, memudahkan pengguna untuk menavigasi dan memahami API. Ini sangat berguna bagi pengembang dan pemangku kepentingan lainnya yang membutuhkan pemahaman mendalam tentang cara API berfungsi.</li> </ul> </li> <li>Mendukung Spesifikasi OpenAPI<ul> <li>Seperti Swagger, ReDoc sepenuhnya mendukung OpenAPI Specification, yang memungkinkan pengembang untuk mendokumentasikan API secara konsisten dengan standar industri.</li> </ul> </li> </ol>"},{"location":"tools/sqlyog/","title":"SQL YOG (Enterprise Edition)","text":""},{"location":"tools/sqlyog/#125-sql-yog-enterprise-edition","title":"12.5 SQL YOG (Enterprise Edition)","text":"<p>SQLyog adalah alat manajemen database berbasis GUI (Graphical User Interface) yang dirancang untuk mempermudah pengelolaan database MySQL dan MariaDB. Dikembangkan oleh Webyog, SQLyog menggabungkan kekuatan alat administrasi MySQL berbasis command-line dengan kemudahan antarmuka berbasis Windows. Alat ini sering digunakan oleh pengembang, administrator database, dan analis data untuk mengelola database dengan lebih efisien.</p>"},{"location":"tools/sqlyog/#1251-fitur-utama-sqlyog","title":"12.5.1 Fitur Utama SQLyog","text":"<ol> <li> <p>Antarmuka Pengguna yang Intuitif</p> <ul> <li>Drag and Drop: Mempermudah interaksi dengan tabel, kolom, dan query.</li> <li>Tab Berdasarkan Query: Memungkinkan bekerja pada banyak query dalam satu jendela.</li> </ul> </li> <li> <p>Query Editor</p> <ul> <li>Syntax Highlighting: Membantu menulis query SQL dengan lebih jelas dan minim kesalahan.</li> <li>Auto-completion: Penyelesaian otomatis untuk nama tabel, kolom, atau perintah SQL.</li> <li>Snippet Manager: Fitur untuk menyimpan potongan kode yang sering digunakan.</li> </ul> </li> <li> <p>Manajemen Database</p> <ul> <li>Membuat, menghapus, atau memodifikasi tabel, database, indeks, dan relasi.</li> <li>Ekspor dan impor data dalam berbagai format seperti CSV, SQL, atau XML.</li> <li>Query Builder: Antarmuka grafis untuk membuat query tanpa menulis SQL manual.</li> </ul> </li> <li> <p>Alat Optimisasi dan Debugging</p> <ul> <li>Profiling Query: Mengidentifikasi dan mengoptimalkan query yang lambat.</li> <li>Index Advisor: Rekomendasi untuk meningkatkan performa melalui penggunaan indeks.</li> </ul> </li> <li> <p>Replikasi dan Sinkronisasi</p> <ul> <li>Sinkronisasi skema dan data antara server lokal dan remote.</li> <li>Scheduled Job: Fitur otomatisasi seperti pencadangan data, sinkronisasi, atau menjalankan query.</li> </ul> </li> <li> <p>Backup dan Restore</p> <ul> <li>Membuat backup database dengan mudah.</li> <li>Scheduled Backup: Jadwal otomatis untuk pencadangan data.</li> </ul> </li> <li> <p>Keamanan</p> <ul> <li>Mendukung koneksi SSL dan SSH Tunnel untuk pengelolaan database secara aman.</li> <li>Manajemen pengguna dan hak akses.</li> </ul> </li> <li> <p>Visual Data Comparison</p> <ul> <li>Membandingkan data antar server dan sinkronisasi secara selektif.</li> </ul> </li> <li> <p>Alat Debugging</p> <ul> <li>Visual Explain Plan: Menganalisis cara kerja query untuk mengidentifikasi masalah performa.</li> </ul> </li> </ol>"},{"location":"tools/sqlyog/#1252-keunggulan-sqlyog","title":"12.5.2 Keunggulan SQLyog","text":"<ol> <li>Antarmuka yang Ramah Pengguna<ul> <li>Mudah digunakan, bahkan oleh pemula, dengan banyak fitur berbasis klik.</li> </ul> </li> <li>Kinerja Cepat<ul> <li>Dibangun dengan fokus pada kecepatan, memungkinkan navigasi cepat pada database besar.</li> </ul> </li> <li>Kemampuan Sinkronisasi<ul> <li>Sinkronisasi data dan skema antara server secara efisien.</li> </ul> </li> <li>Automasi yang Kuat<ul> <li>Menjadwalkan pencadangan, eksekusi query, atau sinkronisasi.</li> </ul> </li> <li>Dukungan untuk Remote Server<ul> <li>Koneksi aman melalui SSH Tunnel untuk manajemen server database yang berada di jaringan yang berbeda.</li> </ul> </li> <li>Kompatibilitas Luas<ul> <li>Mendukung berbagai versi MySQL dan MariaDB.</li> </ul> </li> </ol>"},{"location":"tools/sqlyog/#1252-kekurangan-sqlyog","title":"12.5.2 Kekurangan SQLyog","text":"<ol> <li>Berbayar<ul> <li>Versi lengkap SQLyog (Enterprise) memerlukan lisensi berbayar, meskipun ada versi Community dengan fitur terbatas.</li> </ul> </li> <li>Terbatas pada MySQL/MariaDB<ul> <li>Tidak mendukung database lain seperti PostgreSQL, SQL Server, atau Oracle.</li> </ul> </li> <li>Hanya untuk Windows<ul> <li>Tidak tersedia secara native untuk macOS atau Linux, meskipun dapat dijalankan melalui emulator.</li> </ul> </li> </ol>"},{"location":"tools/sqlyog/#1253-versi-dan-harga","title":"12.5.3 Versi dan Harga","text":"<ol> <li>SQLyog Community Edition<ul> <li>Gratis dan open source, namun dengan fitur terbatas.</li> <li>Tidak mendukung replikasi, sinkronisasi, atau alat optimisasi.</li> </ul> </li> <li>SQLyog Ultimate/Enterprise Edition<ul> <li>Lisensi berbayar dengan fitur lengkap seperti sinkronisasi data, replikasi, dan alat debugging.</li> </ul> </li> </ol>"},{"location":"tools/sqlyog/#1254-penggunaan-sqlyog-dalam-proyek-pengembangan","title":"12.5.4 Penggunaan SQLyog dalam Proyek Pengembangan","text":"<ol> <li>Pembuatan Database<ul> <li>Membuat skema tabel, hubungan, dan indeks dengan antarmuka visual.</li> </ul> </li> <li>Manajemen Data<ul> <li>Mempermudah manipulasi data menggunakan query builder atau editor data berbasis tabel.</li> </ul> </li> <li>Optimisasi Kinerja<ul> <li>Menganalisis query lambat dan meningkatkan kinerja dengan rekomendasi indeks.</li> </ul> </li> <li>Backup dan Restore<ul> <li>Menyediakan pencadangan data yang mudah dengan fitur penjadwalan.</li> </ul> </li> <li>Keamanan<ul> <li>Mengelola akses pengguna dengan kontrol hak akses berbasis GUI.</li> </ul> </li> </ol>"},{"location":"tools/swagger/","title":"12.11 Swagger","text":"<p>Swagger adalah rangkaian alat untuk mendokumentasikan, menguji, dan mengelola API berbasis REST. Swagger dikenal karena kemudahan penggunaannya dan integrasinya yang kuat dalam pengembangan API. Swagger menyediakan antarmuka grafis interaktif yang memungkinkan pengembang untuk mengeksplorasi dan menguji API tanpa menulis kode tambahan.</p>"},{"location":"tools/swagger/#12111-fitur-utama-swagger","title":"12.11.1 Fitur Utama Swagger","text":"<ol> <li>Dokumentasi API Otomatis<ul> <li>Swagger memungkinkan pembuatan dokumentasi API secara otomatis berdasarkan spesifikasi yang ditulis menggunakan OpenAPI Specification (OAS), yang mendefinisikan struktur API, metode, dan format data yang digunakan. Dokumentasi ini sangat berguna bagi pengembang untuk memahami cara berinteraksi dengan API.</li> </ul> </li> <li>Antarmuka Pengguna Interaktif<ul> <li>Swagger menyediakan antarmuka pengguna berbasis web yang interaktif dan mudah digunakan. Pengguna dapat mengirimkan permintaan API langsung dari antarmuka ini, melihat respons, dan memverifikasi bahwa API berfungsi seperti yang diharapkan.</li> </ul> </li> <li>Pengujian API<ul> <li>Dengan Swagger UI, pengguna dapat langsung mengirimkan permintaan API dan menerima respons dari server, memungkinkan pengujian API secara langsung tanpa perlu menulis kode pengujian terpisah.</li> </ul> </li> <li>Validasi dan Penyesuaian API<ul> <li>Swagger memungkinkan pengembang untuk memvalidasi definisi API mereka dan menyesuaikan API berdasarkan umpan balik yang diberikan melalui antarmuka pengguna atau alat lainnya.</li> </ul> </li> <li>Integrasi dengan Framework Lain<ul> <li>Swagger dapat diintegrasikan dengan berbagai framework pengembangan API, seperti Spring, Flask, Express, dan tentunya FastAPI. Integrasi ini memudahkan pengembang untuk menghasilkan dokumentasi yang terstruktur dan dapat diperbarui dengan cepat.</li> </ul> </li> <li>Spesifikasi OpenAPI<ul> <li>Swagger menggunakan OpenAPI Specification (sebelumnya dikenal sebagai Swagger Specification) sebagai format untuk mendefinisikan API. OAS adalah standar terbuka yang digunakan untuk menggambarkan API RESTful, termasuk endpoint, jenis permintaan, parameter, dan format respons.</li> </ul> </li> <li>Fitur Autentikasi dan Otorisasi<ul> <li>Swagger memungkinkan pengelolaan dan pengujian API yang dilindungi oleh autentikasi, seperti OAuth 2.0, API key, dan autentikasi berbasis cookie.</li> </ul> </li> </ol>"},{"location":"tools/swagger/#12112-keunggulan-swagger","title":"12.11.2 Keunggulan Swagger","text":"<ol> <li>Dokumentasi API yang Mudah Dibaca<ul> <li>Swagger menghasilkan dokumentasi yang sangat terstruktur dan mudah dibaca, membantu pengembang dan pengguna API untuk memahami cara API bekerja hanya dengan melihat dokumentasi.</li> </ul> </li> <li>Antarmuka Pengguna yang Interaktif<ul> <li>Pengguna tidak hanya membaca dokumentasi, tetapi juga dapat mengujinya secara langsung melalui antarmuka grafis yang disediakan oleh Swagger UI, mempermudah pengembangan dan pengujian API.</li> </ul> </li> <li>Standar Terbuka (Open Standard)<ul> <li>Swagger mengikuti OpenAPI Specification yang telah diterima sebagai standar industri dalam mendokumentasikan API RESTful. Ini menjamin bahwa dokumentasi API dapat dipahami dan diimplementasikan oleh berbagai alat dan framework.</li> </ul> </li> <li>Pengujian dan Debugging yang Cepat<ul> <li>Dengan antarmuka interaktif dan kemampuan pengujian langsung, Swagger memudahkan pengembang untuk mengidentifikasi masalah dan memastikan API berfungsi seperti yang diharapkan.</li> </ul> </li> <li>Dukungan Berbagai Format<ul> <li>Swagger dapat menangani berbagai format data, termasuk JSON dan XML, serta mendukung berbagai metode HTTP seperti GET, POST, PUT, dan DELETE.</li> </ul> </li> </ol>"},{"location":"tools/swagger/#12113-kekurangan-swagger","title":"12.11.3 Kekurangan Swagger","text":"<ol> <li>Memerlukan Pengaturan Awal<ul> <li>Meskipun Swagger menyediakan antarmuka pengguna yang intuitif, pengaturan awal untuk menghubungkan Swagger dengan API dan menghasilkan dokumentasi bisa memerlukan beberapa konfigurasi tambahan, tergantung pada framework yang digunakan.</li> </ul> </li> <li>Tidak Semua Fitur Tersedia di Versi Gratis<ul> <li>Beberapa fitur seperti integrasi penuh dengan CI/CD atau pengelolaan API yang lebih kompleks hanya tersedia pada versi berbayar, meskipun versi dasar Swagger sudah cukup untuk sebagian besar pengujian dan dokumentasi API.</li> </ul> </li> <li>Ketergantungan pada Spesifikasi OpenAPI<ul> <li>Swagger bergantung pada spesifikasi OpenAPI untuk mendokumentasikan API, yang berarti pengembang harus mengikuti standar ini dengan ketat untuk mendapatkan manfaat maksimal dari alat ini.</li> </ul> </li> </ol>"},{"location":"tools/swagger/#12114-lisensi-dan-versi-swagger","title":"12.11.4 Lisensi dan Versi Swagger","text":"<ol> <li>Versi Open Source<ul> <li>Swagger UI dan Swagger Editor tersedia sebagai open-source dan dapat digunakan secara gratis untuk mendokumentasikan API. Ini adalah pilihan yang sangat baik untuk proyek-proyek pengembangan API internal atau aplikasi open-source.</li> </ul> </li> <li>Swagger Hub<ul> <li>Swagger Hub adalah platform berbasis cloud untuk kolaborasi tim dalam pengembangan dan dokumentasi API. Versi ini memiliki lebih banyak fitur dan dukungan, namun memerlukan langganan berbayar untuk tim besar dan proyek dengan skala lebih tinggi.</li> </ul> </li> </ol>"},{"location":"tools/swagger/#12115-swagger-dan-fastapi","title":"12.11.5 Swagger dan FastAPI","text":"<p>FastAPI secara otomatis menghasilkan dokumentasi API menggunakan Swagger UI. Dengan FastAPI, setiap API yang dibangun akan memiliki dokumentasi yang lengkap dan interaktif yang dapat diakses melalui antarmuka Swagger UI hanya dengan menjalankan aplikasi. Ini memberikan kemudahan bagi pengembang untuk mengembangkan API dan menguji API tanpa perlu menulis dokumentasi secara manual.</p> <ol> <li>Penghasilan Dokumentasi Otomatis<ul> <li>FastAPI secara otomatis menghasilkan dokumentasi API menggunakan Swagger UI hanya dengan mendeklarasikan endpoint dan menggunakan tipe data yang valid. Tidak perlu konfigurasi tambahan untuk menambahkan Swagger ke dalam proyek FastAPI.</li> </ul> </li> <li>Interaktivitas dalam Pengujian API<ul> <li>Pengguna dapat menggunakan Swagger UI untuk mengirimkan permintaan API secara langsung melalui browser dan melihat respons API. Hal ini sangat berguna untuk pengujian dan debugging API secara langsung tanpa menulis kode pengujian tambahan.</li> </ul> </li> <li>Dokumentasi OpenAPI<ul> <li>FastAPI mendukung OpenAPI Specification secara langsung. Ini berarti dokumentasi API yang dihasilkan sepenuhnya sesuai dengan standar terbuka yang dapat digunakan oleh alat lain dan sistem otomatis untuk mengintegrasikan API.</li> </ul> </li> <li>Kemudahan Integrasi dan Kolaborasi<ul> <li>Dengan Swagger UI yang sudah terintegrasi secara otomatis di FastAPI, pengembang dapat dengan mudah berbagi dokumentasi API dan memungkinkan kolaborasi antar tim tanpa perlu melakukan konfigurasi dokumentasi API secara manual.</li> </ul> </li> </ol>"},{"location":"tools/vscode/","title":"Visual Studio Code (VS Code)","text":""},{"location":"tools/vscode/#124-visual-studio-code-vs-code","title":"12.4 Visual Studio Code (VS Code)","text":"<p>Visual Studio Code (VS Code) adalah editor kode sumber terbuka (open source) yang dikembangkan oleh Microsoft. VS Code mendukung banyak bahasa pemrograman, termasuk Python, JavaScript, C++, dan lainnya.</p> <p>Dengan antarmuka yang modern dan fleksibilitas yang tinggi melalui ekstensi, VS Code menjadi salah satu alat pengembang yang paling populer di dunia.</p>"},{"location":"tools/vscode/#1241-fitur-utama","title":"12.4.1 Fitur Utama","text":"<ol> <li> <p>Antarmuka Pengguna yang Fleksibel</p> <ul> <li>Command Palette: Akses cepat ke berbagai perintah dengan shortcut atau pencarian teks.</li> <li>IntelliSense: Penyelesaian kode otomatis berdasarkan sintaks, variabel, dan definisi library.</li> <li>Custom Layout: Mendukung tema dan penyesuaian tampilan.</li> </ul> </li> <li> <p>Dukungan Multi-Bahasa</p> <ul> <li>Mendukung banyak bahasa pemrograman secara bawaan atau melalui ekstensi.</li> <li>Dukungan kuat untuk Python, JavaScript, TypeScript, Go, Java, C++, dan lainnya.</li> </ul> </li> <li> <p>Debugging</p> <p>Debugger bawaan untuk banyak bahasa dengan kemampuan:     - Breakpoints.     - Watch variable.     - Call stack navigation.     - Evaluasi ekspresi.</p> </li> <li> <p>Terminal Terintegrasi</p> <ul> <li>Terminal bawaan mendukung berbagai shell seperti Command Prompt, PowerShell, atau Bash.</li> <li>Mempermudah eksekusi perintah tanpa meninggalkan editor.</li> </ul> </li> <li> <p>Dukungan Git</p> <p>Integrasi langsung dengan Git untuk kontrol versi:         - Commit, pull, push, merge, dan resolve conflicts.         - Visual diff untuk melihat perubahan kode.</p> </li> <li> <p>Marketplace Ekstensi</p> <p>Menyediakan ribuan ekstensi untuk menambahkan fungsionalitas seperti:     - Python (Microsoft).     - ESLint untuk linting JavaScript.     - Prettier untuk format kode otomatis.     - Remote Development untuk coding di server.</p> </li> <li> <p>Dukungan Remote Development</p> <ul> <li>Remote - SSH: Memungkinkan coding pada mesin remote.</li> <li>Remote - Containers: Integrasi dengan Docker untuk bekerja dalam container.</li> </ul> </li> <li> <p>Integrasi AI dengan Copilot</p> <p>GitHub Copilot (berbayar) menggunakan AI untuk menghasilkan kode berdasarkan konteks dan komentar.</p> </li> <li> <p>Ekstensi Live Share</p> <p>Kolaborasi langsung dengan pengembang lain melalui sesi coding bersama.</p> </li> <li> <p>Linting dan Formatting</p> <ul> <li>Mendukung linting dengan ekstensi seperti Pylint, ESLint, dan flake8.</li> <li>Format kode otomatis dengan ekstensi seperti Prettier atau Black.</li> </ul> </li> </ol>"},{"location":"tools/vscode/#1242-keunggulan-visual-studio-code","title":"12.4.2 Keunggulan Visual Studio Code","text":"<ol> <li>Gratis dan Open Source<ul> <li>Tersedia secara gratis untuk semua pengguna.</li> <li>Dukungan komunitas yang besar dengan pembaruan rutin.</li> </ul> </li> <li>Ringan<ul> <li>Memiliki performa tinggi meskipun dijalankan pada komputer dengan spesifikasi rendah.</li> </ul> </li> <li>Fleksibel<ul> <li>Dapat digunakan untuk berbagai bahasa pemrograman dan alur kerja, dari pengembangan front-end hingga back-end.</li> </ul> </li> <li>Ekstensi yang Kaya<ul> <li>Marketplace menawarkan ekstensi untuk hampir semua bahasa dan framework.</li> </ul> </li> <li>Cross-Platform<ul> <li>Tersedia untuk Windows, macOS, dan Linux.</li> </ul> </li> </ol>"},{"location":"tools/vscode/#1243-kekurangan-visual-studio-code","title":"12.4.3 Kekurangan Visual Studio Code","text":"<ol> <li>Ketergantungan pada Ekstensi<ul> <li>Banyak fitur canggih bergantung pada ekstensi, sehingga pengaturan awal dapat memakan waktu.</li> </ul> </li> <li>Konsumsi RAM<ul> <li>Dengan banyak ekstensi aktif, VS Code dapat menghabiskan sumber daya sistem lebih banyak dibandingkan editor teks lainnya.</li> </ul> </li> <li>Debugging Terbatas untuk Bahasa Tertentu<ul> <li>Debugger bawaan lebih cocok untuk bahasa populer seperti Python, JavaScript, atau TypeScript. Untuk bahasa lain, memerlukan konfigurasi tambahan.</li> </ul> </li> </ol>"},{"location":"tools/vscode/#1244-penggunaan-visual-studio-code-untuk-python","title":"12.4.4 Penggunaan Visual Studio Code untuk Python","text":"<ol> <li>Menginstal Ekstensi Python<ul> <li>Cari Python (Microsoft) di Extensions Marketplace.</li> <li>Fitur: IntelliSense, linting, debugging, dan Jupyter Notebook.</li> </ul> </li> <li>Virtual Environment<ul> <li>VS Code mendeteksi dan bekerja dengan virtual environment secara otomatis.</li> </ul> </li> <li>Linting dan Formatting<ul> <li>Ekstensi seperti Pylint atau Black membantu menjaga konsistensi kode.</li> </ul> </li> <li>Debugging<ul> <li>Dukungan debugging untuk aplikasi Python dengan breakpoint, call stack, dan logging interaktif.</li> </ul> </li> </ol>"},{"location":"tools/webstorm/","title":"WebStorm (Education Version)","text":""},{"location":"tools/webstorm/#122-webstorm-education-version","title":"12.2 WebStorm (Education Version)","text":"<p>WebStorm adalah Integrated Development Environment (IDE) yang dikembangkan oleh JetBrains, dirancang khusus untuk pengembangan berbasis JavaScript dan framework front-end modern seperti React, Angular, Vue.js, serta Node.js.</p> <p>WebStorm terkenal karena kemampuannya dalam meningkatkan produktivitas pengembang dengan fitur-fitur canggih dan dukungan menyeluruh untuk ekosistem JavaScript.</p>"},{"location":"tools/webstorm/#1221-fitur-utama","title":"12.2.1 Fitur Utama","text":"<ol> <li> <p>Coding Assistance</p> <ul> <li>Autocomplete: Menawarkan saran kode otomatis untuk JavaScript, TypeScript, HTML, CSS, dan framework modern.</li> <li>Linting Otomatis: Mendukung ESLint, JSHint, dan TSLint untuk memastikan kualitas kode.</li> <li>Refactoring: Kemudahan dalam mengubah struktur kode (rename, move, extract) tanpa merusak fungsionalitas.</li> <li>Live Templates: Snippet kode yang dapat disesuaikan untuk mempercepat penulisan kode.</li> </ul> </li> <li> <p>Dukungan Framework</p> <ul> <li>React: Dukungan JSX, pengeditan langsung komponen, dan navigasi elemen.</li> <li>Angular: Integrasi Angular CLI, auto-import, dan navigasi cepat ke modul atau komponen.</li> <li>Vue.js: Mendukung single file components (SFC) dengan autocomplete dan validasi.</li> </ul> </li> <li> <p>Tools Back-End</p> <ul> <li>Node.js: Debugging bawaan untuk aplikasi Node.js.</li> <li>Express: Dukungan pengembangan server-side dengan Express.</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Terintegrasi dengan framework pengujian seperti Jest, Mocha, dan Karma.</li> <li>Menampilkan hasil pengujian langsung di IDE dengan visualisasi laporan.</li> </ul> </li> <li> <p>Built-in Debugger</p> <ul> <li>Debugging untuk aplikasi client-side dan server-side (Node.js).</li> <li>Menyediakan alat debugging langsung untuk browser Chrome.</li> </ul> </li> <li> <p>Version Control System (VCS)</p> <ul> <li>Mendukung Git, GitHub, Mercurial, dan lainnya.</li> <li>Memiliki visual diff tools untuk melihat perbedaan kode.</li> </ul> </li> <li> <p>Database Tools</p> <ul> <li>Editor SQL bawaan untuk integrasi langsung dengan database seperti MySQL dan PostgreSQL.</li> <li>Kemampuan untuk menjalankan query dan melihat hasil tanpa meninggalkan IDE.</li> </ul> </li> <li> <p>Integrasi Alat Developer</p> <ul> <li>Webpack: Dukungan untuk konfigurasi Webpack.</li> <li>Docker: Pengelolaan container langsung dari IDE.</li> <li>Task Runners: Mendukung Gulp, Grunt, dan npm scripts.</li> </ul> </li> <li> <p>Live Edit</p> <ul> <li>Melihat perubahan kode langsung di browser tanpa perlu menyegarkan halaman.</li> </ul> </li> </ol>"},{"location":"tools/webstorm/#1222-keunggulan-webstorm","title":"12.2.2 Keunggulan WebStorm","text":"<ol> <li>Komprehensif: Mendukung pengembangan penuh untuk front-end dan back-end dengan JavaScript dan TypeScript.</li> <li>Efisiensi Tinggi: Fitur seperti autocomplete, refactoring, dan debugging mengurangi waktu pengerjaan.</li> <li>Dukungan Framework Lengkap: Sangat ideal untuk proyek menggunakan framework modern.</li> <li>Linting dan Code Quality: Membantu menjaga kualitas kode secara otomatis.</li> <li>Integrasi Seamless: Mudah digunakan dengan alat pengembang seperti Git, Docker, dan task runner.</li> </ol>"},{"location":"tools/webstorm/#1224-kekurangan-webstorm","title":"12.2.4 Kekurangan WebStorm","text":"<ol> <li>Berat: Konsumsi memori tinggi, terutama saat bekerja dengan proyek besar.</li> <li>Berbayar: Membutuhkan lisensi berbayar untuk penggunaan komersial.</li> <li>Fokus pada JavaScript: Meskipun mendukung bahasa lain, WebStorm lebih diarahkan untuk pengembangan JavaScript.</li> <li>Harga Relatif Mahal: Jika dibandingkan dengan editor gratis seperti Visual Studio Code.</li> </ol>"},{"location":"tools/webstorm/#1225-versi-edukasi-webstorm","title":"12.2.5 Versi Edukasi WebStorm","text":"<p>WebStorm juga tersedia secara gratis untuk pelajar, mahasiswa, dan pengajar melalui program JetBrains Education License.</p> <p>Fitur Versi Edukasi</p> <ul> <li>Fitur yang sama dengan versi berbayar komersial tanpa pembatasan.</li> <li>Berlaku untuk semua IDE JetBrains, termasuk WebStorm.</li> </ul> <p>Cara Mendapatkan Lisensi Edukasi</p> <ol> <li>Pendaftaran Akun JetBrains<ul> <li>Daftar menggunakan email institusi pendidikan (contoh: <code>@universitas.edu</code>).</li> </ul> </li> <li>Verifikasi Status Edukasi<ul> <li>Unggah bukti status pendidikan seperti kartu pelajar atau surat keterangan.</li> </ul> </li> <li>Aktivasi Lisensi<ul> <li>Lisensi berlaku selama 1 tahun dan dapat diperbarui jika status edukasi masih aktif.</li> </ul> </li> </ol>"},{"location":"ui-guidelines/identitas-visual/","title":"Identitas Visual","text":""},{"location":"ui-guidelines/identitas-visual/#103-identitas-visual","title":"10.3 Identitas Visual","text":"<p>Pengembangan aplikasi berbasis web di lingkungan internal sampai saat ini masih mengadopsi template Pixel Admin (versi lama), yang saat ini statusnya telah usang (deprecated) dan telah merilis versi baru dari Pixel Admin.</p> <p>Namun, mulai saat ini dan pada pengembangan berikutnya, akan digunakan template baru, yaitu template Metronics dari Keenthemes sebagai sistem desain utama untuk penyusunan tampilan/user interface. Saat ini, dokumentasi dan pratinjau template (preview template) hanya dapat diperoleh dengan mengajukan permohonan langsung atau mengunjungi laman pembuatnya\u00a0di sini.</p> <p>Kedepan, dokumentasi dan pratinjau langsung template (live preview template)</p> <p>dapat diunggah ke publik sehingga dapat diakses oleh setiap pengembang di lingkungan internal.</p> <p>Adapun elemen visual yang akan ditetapkan ketentuannya meliputi:</p> <ul> <li> <p>Warna (Color Palette)</p> <p>Menjelaskan definisi penggunaan warna yang akan digunakan dalam penyusunan tampilan. Dalam template, warna dapat didefinisikan dengan menyertakan nama warna, kode warna serta penggunaannya dalam komponen UI. </p> Nama Kelas Kode primary #1B84FF success #17C653 danger #F8285A warning #F6C000 info #7239EA default #F1F1F4 <p></p> </li> <li> <p>Tipografi</p> <p>Penentuan jenis font, berat, ukuran dan style yang digunakan dalam pengembangan tampilan. Secara default, setiap template yang digunakan juga telah menyediakan <code>class</code> untuk tipografi. Pada template Metronics font family utama yang digunakan adalah Sans-Serif.</p> <p>Redaksional aplikasi umumnya terdiri terdiri dari 3 bagian, yaitu Heading, Sub-Heading, Description. Pada bagian heading dapat menggunakan tag <code>&lt;h1&gt;&lt;/h1&gt;</code>. Untuk sub-heading dapat menggunakan <code>&lt;h4&gt;&lt;/h4&gt;</code>. Sedangkan untuk bagian description, dapat menggunakan teks biasa. Untuk menambahkan elemen estetika, dapat ditambahkan jarak antar bagian. Misalnya, pada bagian heading ditambahkan class <code>mb-2</code>, kemudian dibawah sub-heading ditambahkan class <code>mb-4</code>.  Lalu untuk styling text, dapat menggunakan class <code>fw-bold</code> untuk mempertebal huruf, dan class <code>fst-italic</code> untuk mencetak miring. </p> <p>Berikut merupakan hasil penataan tipografi untuk suatu konten.</p> <p></p> </li> <li> <p>Spacing</p> <p>Spacing mengacu pada pengaturan jarak antar elemen teks untuk menciptakan tampilan yang lebih rapi, mudah dibaca, dan estetis. Spacing mencakup jarak antara huruf, kata, baris, atau elemen teks secara keseluruhan. Dalam desain grafis, spacing sangat penting karena dapat memengaruhi keterbacaan, hierarki visual, dan estetika desain. Seperti pada contoh tipografi di atas, spacing diterapkan pada elemen heading dan sub-heading dengan menambahkan class <code>mb-2</code> dan <code>mb-4</code>.</p> </li> <li> <p>Ikonografi</p> <p>Desain ikon digunakan untuk membantu navigasi dan menyampaikan fungsi dengan cepat. Ikon yang baik adalah ikon yang konsisten dan selaras dengan maksud yang hendak disampaikan, sehingga pengguna dapat memahami arti dari ikon tersebut tanpa kebingungan. </p> <p>Dalam template Metronics, sudah tersedia paket ikon build-in dari pengembang yang diberi nama KeenIcons. Keenicons menawarkan tiga style ikon yang berbeda, yaitu duotone, solid, dan outline. Pemilihan style ikon oini sepenuhnya tergantung pada keinginan atau kesepakatan pengembang project, dan tidak ada kewajiban untuk menggunakan duotone, atau solid, atau outline. Namun, disarankan untuk memilih style yang konsisten dalam satu project. Sebagai contoh, misalkan aplikasi \u201cA\u201d menggunakan style duotone dan aplikasi \u201cB\u201d menggunakan solid.</p> <p>Berikut adalah contoh kode dan ikon yang dihasilkan:</p> <pre><code>&lt;i class=\"ki-duotone ki-chart text-primary\"&gt;\n    &lt;i class=\"path1\"&gt;&lt;/i&gt;\n    &lt;i class=\"path2\"&gt;&lt;/i&gt;\n&lt;/i&gt;\n\n&lt;i class=\"ki-solid ki-chart text-warning\"&gt;&lt;/i&gt;\n\n&lt;i class=\"ki-outline ki-chart text-danger\"&gt;&lt;/i&gt;\n</code></pre> <p></p> </li> <li> <p>Ilustrasi</p> <p>Ilustrasi merupakan karya visual yang digunakan untuk menjelaskan, memperjelas, atau memperindah suatu konsep, teks, cerita, atau ide yang hendak disampaikan. Visual ini sebaiknya mencerminkan identitas merek dan memberikan nuansa yang sesuai dengan target audiens. </p> <p>Dalam template Metronics, juga disertakan beberapa gambar ilustrasi yang dapat digunakan oleh pengembang user interface. Apabila hendak menggunakan gambar ilustrasi original, tentu diperbolehkan. Sangat disarankan agar gambar ilustrasi tersebut dapat terlihat jelas pada mode terang maupun gelap. Gambar ilustrasi bawaan template Metronics terletak pada direktori <code>assets/media/ilustrations</code>.</p> </li> </ul>"},{"location":"ui-guidelines/intro/","title":"BAB 10 UI GUIDELINE","text":""},{"location":"ui-guidelines/intro/#101-latar-belakang","title":"10.1 Latar Belakang","text":"<p>Dalam pengembangan perangkat lunak, tampilan aplikasi (user interface) merupakan salah satu faktor yang memberikan dampak besar terhadap pengalaman pengguna (user experience). Dalam suatu instansi, semakin banyak dan beragamnya aplikasi dapat meningkatkan kecenderungan pengguna untuk mengingat lebih banyak pengalaman penggunaannya. UI yang konsisten, menarik, dan intuitif akan memberikan kepuasan, kemudahan, serta kenyamanan bagi pengguna dalam menggunakan aplikasi.</p> <p>Dalam pengembangan perangkat lunak, seringkali aspek estetika dan pengalaman pengguna tidak dijadikan prioritas utama dibandingkan dengan aspek fungsionalitas. Meskipun hal ini dapat dimaklumi mengingat keterbatasan waktu dan sumber daya, perlu disadari bahwa perhatian yang lebih terhadap aspek-aspek tersebut dapat berpotensi meningkatkan kesan pengguna terhadap aplikasi. Mengingat banyaknya aplikasi yang beredar dalam suatu lingkungan (yang mungkin memiliki target pengguna yang sama),\u00a0user interface\u00a0yang tertata dengan baik akan memberikan kemudahan bagi pengguna meskipun mereka harus berganti-ganti aplikasi, dengan mengurangi kebingungan dan kurva pembelajaran yang diperlukan untuk beradaptasi dengan aplikasi-aplikasi tersebut.</p> <p>Dengan adanya\u00a0UI guideline, diharapkan pengembangan produk aplikasi dapat dimaksimalkan meskipun dengan sumber daya yang terbatas, karena sebagian besar elemen\u00a0user interface\u00a0telah ditentukan atau disarankan sebelumnya oleh tim khusus dengan berbagai pertimbangan yang ada. Dengan demikian, tujuan fungsional aplikasi tetap dapat tercapai sekaligus meningkatkan tampilan aplikasi secara keseluruhan.</p>"},{"location":"ui-guidelines/komponen-ui/","title":"Komponen UI","text":""},{"location":"ui-guidelines/komponen-ui/#104-komponen-ui","title":"10.4 Komponen UI","text":"<p>Komponen UI merupakan elemen-elemen kecil dalam desain yang digunakan untuk membangun antarmuka pengguna yang konsisten dan fungsional. Dalam dokumentasi template Metronics, tersedia panduan yang lengkap mulai dari layout hingga komponen-komponen terkecilnya. Pada bagian ini, hanya akan dibahas komponen-komponen yang dianggap fundamental dan memiliki pengaruh dalam terciptanya konsistensi user interface.</p>"},{"location":"ui-guidelines/komponen-ui/#1041-navigasi","title":"10.4.1 Navigasi","text":"<p>Navigasi adalah elemen yang membantu pengguna berpindah antar layar atau bagian aplikasi. Desain navigasi yang konsisten dan intuitif sangat penting untuk menciptakan pengalaman pengguna yang baik. Dalam template ini, disediakan 2 tipe navigasi, yaitu di bagian atas dan di bagian samping. Untuk keperlua back office, admin biasanya menggunakan navigasi di bagian samping (sidebar) untuk mengakomodasi jumlah menu yang sering bertambah seiring waktu. Sedangkan untuk landing page atau portal, biasanya menggunakan navigasi di bagian atas dengan mega menu.</p> <p>Berikut merupakan contoh navigasi di sidebar di header.</p> <p></p> <p></p>"},{"location":"ui-guidelines/komponen-ui/#1042-tombol","title":"10.4.2 Tombol","text":"<p>Tombol merupakan elemen interaktif yang digunakan untuk melakukan aksi atau navigasi. Desain tombol harus jelas dan mudah dikenali oleh pengguna.</p> <p>Dalam template Metronics, disediakan beberapa style button yang dapat digunakan.</p> <p>Basic Button</p> <p></p> <p>Light Button</p> <p></p> <p>Outline Button</p> <p></p> <p>Icons Button</p> <p></p> <p>Tidak ada keharusan dalam pemilihan style tombol. Sama seperti ikon, pemilihan style sebaiknya konsisten dalam satu project agar pengguna tidak kebingungan karena perubahan style button. Namun, untuk tombol yang menggunakan ikon, dapat menggunakan ikon dan label atau hanya ikon saja sesuai kebutuhan.</p> <p>REKOMENDASI:</p> <ul> <li>Bebas menggunakan style tombol apapun, dengan catatan konsisten dalam satu project yang sama sebagai style utama.</li> <li>Diperbolehkan menggunakan kombinasi style (misalnya, button solid dan light) untuk mempertegas maksud tertentu pada setiap button. Misalnya, pada modal konfirmasi terdapat pilihan \u201cYa\u201d dan \u201cTidak\u201d. Tombol \u201cYa\u201d bisa menggunakan style solid sedangkan tombol \u201cTidak\u201d bisa menggunakan style light untuk memberikan kesan bahwa tombol \u201cYa\u201d adalah tombol yang seharusnya dieksekusi.</li> <li>Diperbolehkan menggunakan tombol dengan label saja, ikon saja, maupun kombinasi label dan ikon sesuai kebutuhan dan ketersediaan ruang.</li> <li>Jika menggunakan tombol ikon saja (tanpa label), disarankan untuk menambahkan tooltip yang muncul di atas tombol.</li> <li> <p>Gunakan warna dan ikon tombol aksi sesuai fungsi.</p> Tombol Class Ikon tambah primary ikon tambah ubah warning ikon pensil hapus danger ikon tempat sampah detail primary ikon mata export excel success ikon file (excel jika ada) cetak primary ikon printer tampilkan primary ikon kaca pembesar reset secondary ikon refresh kembali warning ikon panah kiri simpan primary ikon simpan - Meletakkan tombol pada posisi sesuai ketentuan Tombol Lokasi tampilkan, reset di bagian kanan bawah form filter. Secara berurutan, dari yang paling kanan ke kiri, terdapat tombol Tampilkan, diikuti dengan tombol Reset. tambah di bagian kanan atas dari panel utama (panel yang memuat data isian/tabel/daftar). export, cetak di bagian kanan atas dari panel utama (panel yang memuat data isian/tabel/daftar). Tombol Export dan tombol Cetak dapat saling bertukar posisi, namun harus tetap berada di sebelah kiri dari tombol Tambah. detail, ubah, hapus di dalam panel utama, tombol-tombol ini biasanya diletakkan pada tabel yang berada di kolom aksi yang terletak di paling kanan, berjajar secara horizontal. Alternatif lainnya adalah dengan menggunakan satu button group yang berisi tombol Detail, Ubah, dan Hapus yang dapat membuka menu di atasnya. Untuk tombol Ubah dan Hapus, sebaiknya selalu diletakkan selalu bersebelahan dan berada di ujung kanan. detail selain menggunakan tombol aksi, tombol Detail dapat ditempatkan pada \u201cdata utama\u201d yang unique (misalnya nomor transaksi pada daftar transaksi), kemudian diberikan label yang akan menjadi tombol yang dapat diklik. tombol aksi tambahan (contoh: Upload, Ajukan, dll) tombol aksi tambahan dapat diletakkan setelah tombol Detail dan sebelum grup tombol Ubah, Hapus. simpan, kembali di bawah form, sebelah kanan. Tombol Simpan terletak di paling kanan dan tombol Kembali di sebelah kiri. Atau, tombol Simpan berada di ujung kanan dan tombol Kembali di ujung kiri. pagination di bawah, sebelah kanan. Apabila tabel/data terlalu panjang, pagination dapat ditambahkan di atas tabel/data, sebelah kiri, berlawanan dengan kelompok tombol Tambah, Export, dan Cetak. Untuk halaman utama landing page dapat diletakkan di bawah dan di tengah. </li> </ul> <p>HINDARI:</p> <ul> <li>Penggunaan ikon yang tidak sesuai dengan label tombol.</li> <li>Penukaran warna tombol aksi yang telah ditentukan, karena dapat menimbulkan misinterpretation atau kesalahpahaman oleh pengguna.</li> </ul>"},{"location":"ui-guidelines/komponen-ui/#1043-formulirform","title":"10.4.3 Formulir/Form","text":"<p>Formulir adalah komponen yang digunakan untuk mengumpulkan input dari pengguna. Komponen formulir yang umum digunakan antara lain input teks, dropdown, checkbox, dan radio button. Pada template Metronics, terdapat berbagai variasi style form terutama pada tag <code>&lt;input&gt;</code>.</p> <p>Berikut merupakan variasi style pada form input</p> <p>Style Fill</p> <p></p> <p>Style Label</p> <p></p> <p>Untuk style lainnya yang lebih lengkap (dasar/basic dan lanjutan/advance) dapat dilihat langsung pada dokumentasi melalui tautan berikut ini.</p> <p>REKOMENDASI:</p> <ul> <li>Gunakan style outline untuk kemudahan akses pengguna atau gunakan style solid untuk lebih menekankan estetika.</li> <li>Selain input, template juga menyediakan styling untuk checkbox dan radio button.</li> <li>Gunakan style dan size form yang konsisten sama dalam satu project.</li> <li>Gunakan masking untuk menampilkan nominal dalam form.</li> <li>Apabila menggunakan icon, pastikan icon yang digunakan seuai dengan isian form. Jika tidak menemukan yang sesuai, lebih baik tidak menggunakan icon.</li> <li>Selalu gunakan select2 untuk dropdown karena fitur pencariannya sangat dibutuhkan pengguna.</li> <li>Untuk mendapatkan panjang yang seragam, beberapa form dapat digabung dalam satu atau beberapa baris kelompok. Contohnya adalah input untuk kelurahan, kecamatan, kabupaten, provinsi, atau password dan re-type password.</li> </ul> <p>HINDARI:</p> <ul> <li>Menggunakan style input form yang transparan.</li> <li>Menggunakan placeholder apabila keterangannya sama dengan label.</li> <li>Menggunakan radio button dan checkbox tanpa styling dari template karena dapat merusak tatanan antarmuka akibat bentuk yang kontras.</li> <li>Membuat daftar form dengan panjang yang berbeda.</li> </ul>"},{"location":"ui-guidelines/komponen-ui/#1044-cardpanel","title":"10.4.4 Card/Panel","text":"<p>Card/Panel adalah komponen yang digunakan untuk menampilkan informasi atau konten dalam satu wadah dengan format yang terstruktur dan mudah dibaca. Card sering digunakan untuk menyajikan data atau objek dengan berbagai elemen seperti gambar, teks, dan tombol dengan memanggil class <code>card</code>. Secara umum card terdiri dari 3 bagian, yaitu header, body dan footer.</p> <p>REKOMENDASI:</p> <ul> <li>Tidak semua bagian card diperlukan, jadi gunakan hanya bagian yang sekiranya dibutuhkan.</li> </ul> <p>HINDARI:</p> <ul> <li>Meletakkan tombol pada footer card karena dapat membuat footer terlihat gemuk; sebaiknya diletakkan di body card.</li> <li>Menggunakan card dalam card, atau menambahkan margin dan padding pada card karena akan membuang banyak ruang.</li> </ul>"},{"location":"ui-guidelines/komponen-ui/#1045-modal","title":"10.4.5 Modal","text":"<p>Modal adalah jendela interaktif yang muncul di atas konten aplikasi untuk menampilkan informasi penting atau meminta input dari pengguna tanpa meninggalkan halaman yang sedang dilihat.</p> <p>REKOMENDASI:</p> <ul> <li>Gunakan ukuran modal sesuai dengan konten. Apabila konten banyak, dapat menggunakan modal dengan ukuran besar.</li> <li>Jika ragu mengenai size modal yang akan digunakan, sebaiknya pilih modal dengan ukuran sedang.</li> </ul> <p>HINDARI:</p> <ul> <li>Menumpuk modal (stacking) lebih dari dua. Demi kenyaman pengguna, maksimal stacking modal hanya dua. Jika memungkinkan, usahakan menggunakan satu modal saja. Apabila terpaksa menggunakan dua modal, maka modal kedua haruslah berupa modal \u201cprompt\u201d.</li> </ul>"},{"location":"ui-guidelines/komponen-ui/#1046-loading-state-kosong","title":"10.4.6 Loading &amp; State Kosong","text":"<p>Indikator loading digunakan untuk memberitahukan pengguna bahwa aplikasi sedang memproses atau mengambil data, sehingga pengguna mengetahui bahwa aplikasi belum selesai merespons.</p> <p>State kosong adalah kondisi di mana aplikasi tidak memiliki data atau informasi untuk ditampilkan, dan perlu memberi tahu pengguna bahwa tidak ada konten yang tersedia saat ini.</p> <p>REKOMENDASI:</p> <ul> <li>Gunakan loader hanya pada komponen yang sedang diproses, atau gunakan loader untuk satu halaman penuh.</li> <li>Gunakan loader hingga tombol aksi yang digunakan tertutup, agar mencegah klik berulang, atau nonaktifkan tombol yang telah di klik hingga proses selesai.</li> </ul> <p>HINDARI:</p> <ul> <li>Menampilkan hasil kosong tanpa keterangan.</li> </ul>"},{"location":"ui-guidelines/komponen-ui/#1047-notifikasialert","title":"10.4.7 Notifikasi/Alert","text":"<p>Notifikasi/Alert digunakan untuk memberikan informasi penting kepada pengguna, baik berupa pesan kesalahan, peringatan, atau konfirmasi dari suatu aksi.</p> <p>REKOMENDASI:</p> <ul> <li>Gunakan <code>prompt</code> untuk memberikan respon notifikasi.</li> <li>Prompt sebaiknya muncul di pojok kanan atas.</li> <li>Untuk notifikasi berhasil, gunakan warna primary, sedangkan untuk yang gagal, gunakan warna danger.</li> <li>Gunakan <code>alert</code> untuk menampilkan informasi tambahan (bukan respon dari suatu aksi).</li> </ul> <p>HINDARI:</p> <ul> <li>Menggunakan alert sebagai notifikasi.</li> </ul>"},{"location":"ui-guidelines/komponen-ui/#1048-promptkonfirmasi","title":"10.4.8 Prompt/Konfirmasi","text":"<p>Prompt atau konfirmasi diperlukan untuk mengonfirmasi ulang suatu aksi guna menghindari ketidaksengajaan. Umumnya, prompt dibuat dengan modal size small, dilengkapi dengan redaksional tambahan dan tombol aksi konfirmasi.</p> <p>Prompt yang akan digunakan terdiri dari 4 bagian, yaitu:</p> <ol> <li>Icon aksi (wajib)</li> <li>Konfirmasi utama (wajib)</li> <li>Deskripsi tambahan (opsional)</li> <li>Tombol aksi (wajib), dengan posisi TRUE di sebelah kanan dan FALSE di sebelah kiri</li> </ol> <p>Berikut adalah contoh prompt yang direkomendasikan:</p> <pre><code>&lt;div class=\"modal-body pt-0\"&gt;\n    &lt;div class=\"text-center mb-4\"&gt;\n                &lt;i class=\"ki-duotone ki-trash text-danger fs-5x\"&gt;\n                        &lt;span class=\"path1\"&gt;&lt;/span&gt;\n                        &lt;span class=\"path2\"&gt;&lt;/span&gt;\n                        &lt;span class=\"path3\"&gt;&lt;/span&gt;\n                        &lt;span class=\"path4\"&gt;&lt;/span&gt;\n                        &lt;span class=\"path5\"&gt;&lt;/span&gt;\n                &lt;/i&gt;\n    &lt;/div&gt;\n    &lt;div class=\"text-center\"&gt;Are you sure wanna get rid of this data?&lt;/div&gt;\n    &lt;div class=\"small text-center mt-2 text-muted\"&gt;\n        Deleted data can't be restored forever\n      &lt;/div&gt;\n    &lt;div class=\"text-center mt-10\"&gt;\n        &lt;button type=\"button\" class=\"btn btn-light\" data-bs-dismiss=\"modal\"&gt;Cancel&lt;/button&gt;\n        &lt;button type=\"button\" class=\"btn btn-danger ms-3\"&gt;Sure&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p></p>"},{"location":"ui-guidelines/layout/","title":"Layout","text":""},{"location":"ui-guidelines/layout/#105-layout","title":"10.5 Layout","text":"<p>Dalam pengembangan aplikasi berbasis web di lingkungan internal universitas, konsistensi tata letak (layout) memegang peranan penting untuk memastikan pengalaman pengguna yang seragam di seluruh sistem. Layout yang terstandar tidak hanya memudahkan pengguna untuk beradaptasi dengan berbagai sistem, tetapi juga mencerminkan identitas universitas yang profesional dan terintegrasi.</p> <p>Bagian ini menyajikan pedoman tata letak utama yang harus diikuti oleh pengembang, mencakup elemen-elemen penting seperti susunan form, tabel data, navigasi, dan modal. Standarisasi ini bertujuan agar setiap aplikasi internal memiliki struktur halaman yang intuitif, estetis, dan sesuai dengan praktik desain modern. Dengan mengikuti pedoman ini, setiap pengembangan mandiri oleh fakultas atau unit dapat tetap sejalan dengan prinsip desain yang telah ditetapkan.</p> <p>Tata letak yang direkomendasikan berikut juga dilengkapi dengan contoh visual untuk mempermudah implementasi oleh pengembang.</p>"},{"location":"ui-guidelines/layout/#1051-layout-dasar-halaman","title":"10.5.1 Layout Dasar Halaman","text":"<p>Penempatan Header, Sidebar, dan Konten Utama</p> <ul> <li> <p>Header</p> <p>Bagian header merupakan kumpulan menu yang biasa digunakan pada portal Simaster. Secara umum, mencakup menu, notifikasi, dan informasi profil pengguna. Letak header berada di bagian teratas halaman dan akan sticky atau tetap terlihat meskipun pengguna melakukan scroll down kebawah halaman </p> </li> <li> <p>Sidebar</p> <p>Sidebar berisi menu-menu yang akan menavigasi pengguna ke halaman-halaman yang ada pada sistem. Sidebar terletak di bagian paling kiri halaman.</p> </li> <li> <p>Konten utama</p> <p>Konten utama adalah pusat data yang akan ditampilkan di sistem. Letaknya berada di bawah header dan di sebelah kanan sidebar. </p> </li> </ul> <p></p>"},{"location":"ui-guidelines/layout/#1052-struktur-formulir","title":"10.5.2 Struktur Formulir","text":"<p>Tata letak elemen input, tombol aksi, dan validasi</p> <ul> <li>Form disusun secara vertikal (baris demi baris).</li> <li> <p>Label dapat memiliki 2 tipe, yaitu selalu di atas input, atau di samping input. Penggunaan label pada input harus konsisten di semua sistem yang terkait.</p> <ul> <li>Label ditempatkan di sisi kiri input:</li> </ul> <p></p> <ul> <li>Label ditempatkan di sisi atas input:</li> </ul> <p></p> </li> <li> <p>Tambahkan placeholder untuk penjelasan tambahan.</p> <p>Placeholder ini berfungsi sebagai informasi tambahan yang ditampilkan ketika input belum diisi. </p> </li> <li> <p>Tombol Submit atau Simpan ditempatkan di pojok kanan bawah.</p> </li> </ul>"},{"location":"ui-guidelines/layout/#1053-struktur-table","title":"10.5.3 Struktur Table","text":"<p>Desain tabel dengan filter, pagination, dan aksi baris.</p> <p></p> <ul> <li>Header tabel: harus dicetak tebal (bold) dengan menggunakan huruf kapital seluruhnya atau capitalize (huruf besar diawal setiap kata).</li> <li>Baris tabel: harus memiliki pembatas untuk memisahkan data antara setiap baris, agar lebih jelas dan mudah dibaca.</li> <li> <p>Tambahkan tombol aksi di sisi kanan setiap baris, seperti tombol aksi Lihat, Edit, dan Hapus.</p> <ul> <li> <p>Tombol aksi dapat berupa sebuah tombol yang memiliki banyak opsi. Ketika tombol tersebut diklik, akan menampilkan beberapa aksi sekaligus.</p> <p></p> </li> <li> <p>Tombol aksi juga bisa berupa ikon yang merepresentasikan aksi tertentu, seperti ikon tong sampah untuk menghapus, ikon pensil untuk mengedit, dan lainnya.</p> <p></p> </li> </ul> </li> <li> <p>CTA Button: Tombol aksi utama seperti Tambah, Export, dan lainnya, harus ditempatkan di pojok kanan atas tabel. Tombol ini digunakan untuk tindakan penting yang berkaitan langsung dengan tabel.</p> </li> <li> <p>Filter: Sediakan fitur filter di atas tabel, diikuti dengan tombol \"Apply Filter\" atau \"Reset.\"</p> <ul> <li> <p>Untuk fitur filterisasi dengan banyak parameter, disarankan untuk menggunakan pendekatan modal guna mengoptimalkan ruang dan menjaga tampilan tetap rapi dalam satu halaman.</p> <p></p> </li> <li> <p>Apabila parameter filter yang tersedia hanya 1 atau 2, disarankan untuk meletakkan filter langsung pada bagian header table. Hal ini bertujuan untuk mengoptimalkan ruang dan mempermudah akses pengguna dalam melakukan filter.</p> <p></p> </li> <li> <p>Alternatif lain adalah dengan menggunakan pendekatan tambahan panel di sebelah kiri halaman sebagai tempat filter. Pendekatan ini dapat memberikan ruang yang lebih luas untuk menampilkan lebih banyak parameter filter jika diperlukan.</p> <p></p> </li> </ul> </li> <li> <p>Search: Sediakan input search untuk memudahkan pengguna dalam mencari data yang ada dalam tabel. Input pencarian ini harus ditempatkan di bagian atas tabel agar mudah diakses.</p> </li> <li>Pagination: Tambahkan navigasi halaman di bawah tabel untuk memungkinkan pengguna berpindah antar halaman data yang lebih banyak. Navigasi ini dapat mencakup tombol Previous, Next, serta nomor halaman untuk mempermudah navigasi.</li> <li>Tambahkan dropdown list pada pojok kanan bawah tabel untuk mengatur jumlah data yang ditampilkan per halaman. Opsi yang dapat disediakan antara lain seperti 10 data, 20 data, 50 data, dan seterusnya. Hal ini memberikan fleksibilitas kepada pengguna untuk memilih jumlah data yang ingin ditampilkan sesuai dengan preferensi mereka.</li> </ul>"},{"location":"ui-guidelines/layout/#1054-struktur-modal","title":"10.5.4 Struktur Modal","text":"<p>Penempatan konten modal, tombol aksi, dan tata letak. </p> <ul> <li> <p>Ukuran modal sesuaikan kebutuhan:</p> <ul> <li>Small Modal (Ukuran terkecil)</li> </ul> <p></p> </li> <li> <p>Medium Modal (Ukuran medium)</p> <p></p> </li> <li> <p>Full Modal (Ukuran penuh)</p> <p></p> </li> <li> <p>Penempatan modal: modal selalu muncul di tengah layar dengan background overlay transparan.</p> </li> <li>Struktur modal:<ul> <li>Judul modal ditempatkan di bagian atas modal (misalnya: \u201cTambah Data\u201d atau \u201cEdit Data\u201d).</li> <li>Konten modal ditempatkan di bagian tengah modal (misalnya berupa form, teks penjelasan atau yang lain).</li> <li>Tombol aksi ditempatkan di bagian bawah modal (misalnya: aksi \"Simpan\" dan \"Batal\").</li> <li>Modal harus memiliki tombol \"Close\" atau ikon \"X\" di sudut kanan atas untuk menutup modal, jika tidak ingin melanjutkan aksi.</li> </ul> </li> </ul>"},{"location":"ui-guidelines/layout/#1056-profil","title":"10.5.6 Profil","text":"<p>Desain halaman ini khusus untuk menampilkan profil pengguna, seperti dosen, tenaga kependidikan (tendik), atau mitra. Struktur halaman menempatkan informasi utama di bagian atas (hero section) dan atribut lainnya di bagian bawah. Jika terdapat banyak data dengan kategori yang beragam, dapat menggunakan tab untuk memisahkan data.</p> <p></p> <p>Untuk data statis ditampilkan dengan struktur label di sebelah kiri dan isian data di sebelah kanan, disusun rapi menyesuaikan panjang kontennya. Adapun untuk data dinamis berupa form input, susunannya mengikuti struktur form sebagaimana dijelaskan di poin 10.5.2 Struktur Form diatas.</p> <p></p>"},{"location":"ui-guidelines/layout/#1058-halaman-lain","title":"10.5.8 Halaman lain","text":"<p>Selain komponen utama seperti form, tabel, dan navigasi, sistem informasi internal universitas sering kali memerlukan halaman khusus yang dirancang untuk memenuhi kebutuhan tertentu. Halaman-halaman ini, meskipun tidak selalu menjadi bagian dari alur utama pengguna, tetap memegang peranan penting dalam memberikan pengalaman yang lengkap, fungsional, dan konsisten.</p> <ol> <li> <p>Halaman login</p> <p></p> </li> <li> <p>Halaman Dashboard</p> <p></p> </li> <li> <p>Halaman Persuratan</p> <p></p> </li> <li> <p>Kalender Jadwal</p> <p></p> </li> <li> <p>Halaman Error 404, 500, dan lain-lain</p> <p></p> <p></p> </li> </ol> <p>Pedoman ini memberikan panduan visual dan fungsional untuk setiap jenis halaman, mencakup tata letak elemen, hierarki konten, dan penggunaan komponen desain yang sesuai. Dengan menerapkan standar ini, pengembang dapat memastikan bahwa setiap halaman, meskipun bersifat khusus, tetap harmonis dengan sistem utama.</p>"},{"location":"ui-guidelines/pembaharuan-pemeliharaan/","title":"Pembaharuan & Pemeliharaaan","text":""},{"location":"ui-guidelines/pembaharuan-pemeliharaan/#106-pembaharuan-dan-pemeliharaan","title":"10.6 Pembaharuan dan Pemeliharaan","text":"<p>Dokumen UI Guideline ini akan diperbarui sesuai kebutuhan untuk memastikan bahwa pedoman yang disediakan tetap relevan dan sesuai dengan perkembangan teknologi, kebutuhan pengguna, serta perubahan dalam standar desain. Pembaharuan dapat dilakukan berdasarkan hasil evaluasi penggunaan, umpan balik dari pengguna, serta adaptasi terhadap tren desain terkini yang dapat meningkatkan kualitas pengalaman pengguna (user experience). </p> <p>Tim akan selalu siap menerima masukan dan memberikan respons sesuai kebutuhan, guna memastikan kualitas dan keberlanjutan pedoman desain tetap efektif dan sesuai dengan kebutuhan pengguna. Untuk pertanyaan, klarifikasi, atau masukan terkait dokumen UI Guideline ini, pihak yang berkepentingan dapat menghubungi tim pengembang dan desain melalui roadmap yang dapat diakses pada web https://roadmap.dti.ugm.ac.id</p>"},{"location":"ui-guidelines/tujuan/","title":"Tujuan","text":""},{"location":"ui-guidelines/tujuan/#102-tujuan","title":"10.2 Tujuan","text":"<p>Berikut merupakan tujuan pengembangan\u00a0UI guideline\u00a0untuk setiap pengembangan aplikasi dalam suatu lingkungan:</p> <ul> <li>Konsistensi desain: Dengan adanya\u00a0UI guideline, dapat menjamin konsistensi elemen antarmuka/tampilan di seluruh produk aplikasi yang dikembangkan.</li> <li>Peningkatan pengalaman pengguna: Desain antarmuka yang terstruktur dan konsisten akan memudahkan pengguna dalam menyelesaikan tugas, mengurangi frustrasi, dan meningkatkan kenyamanan penggunaan.</li> <li>Percepatan proses desain dan pengembangan: Dengan adanya\u00a0UI guideline\u00a0yang telah disusun sebelumnya, baik proses desain maupun pengembangan dapat dilakukan dengan lebih efisien, serta mengurangi risiko kesalahan, dan revisi yang tidak relevan.</li> <li>Penguatan branding: Dengan tampilan visual yang konsisten, akan memperkuat identitas yang mencerminkan nilai dan karakter. Selain itu, hal ini juga membuat aplikasi lebih mudah dikenali oleh pengguna.</li> </ul>"}]}